<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis入门教程]]></title>
    <url>%2F2019%2F08%2F30%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis1.Mybatis简介:​ ​ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。 持久层： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。 优点： 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价 缺点：慢（相对于内存而言） 2.为什么要使用mybatis​ 在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 3.mybatisDemomybatis的环境搭建​ 第一步：创建maven工程并导入坐标 ​ 第二步：创建实体类和dao接口（mybatis可以只有接口就能实现对数据库的增删改查，而且实体类就是要实体类的属性和数据库的表对应起来） ​ 第三步：创建mybatis的主配置文件 SqlMapConfig.xml（名字可以随意） ​ 第四步：创建映射配置文件 IUserDao.xml（名字可以随意） ​ 搭建注意事项: ​ 第一个:创建IUserDao.xml和IUserDao.java 在mybatis中 他把持久层的操作接口名称和映射文件叫做:Mapper ​ 第二个：在idea中创建目录的时候，他和包是不一样的， ​ 第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同 ​ 第四个：映射配置文件的操作配置（select）,id属性的取值必须是dao接口的方法名 ​ 第五个：映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定类名 首先Bean包Account.java 12345678910111213141516171819202122232425262728293031323334353637383940package cn.Bean;public class Account &#123; private Integer id; private String name; private Double money; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125; 然后dao包下的IDao.java接口 123456789101112package cn.dao;import cn.Bean.Account;import java.util.List;/** * 获取所有的Account信息 */public interface IDao &#123; public List&lt;Account&gt; getAccountAll();&#125; 然后创建主配置文件MybatisConfig.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt;&lt;!--defult填写的子类必须也有--&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置连接数据库--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--配置映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="cn/config/IDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 然后穿件cn目录下config目录下的IDao.xml映射IDao.java的配置文件，注意xml文件和java文件必须是统一限定目录 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace填写IDao接口的全限定类名--&gt;&lt;mapper namespace="cn.dao.IDao"&gt; &lt;!--配置查询所有 id必须是IDao方法的名称,resultType必须是实体类 --&gt; &lt;select id="getAccountAll" resultType="cn.Bean.Account"&gt; select * from account; &lt;/select&gt;&lt;/mapper&gt; 最后是测试类 12345678910111213141516171819202122232425262728293031import cn.Bean.Account;import cn.dao.IDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123; @org.junit.Test public void getALl() throws IOException &#123; //1.读取配置文件 InputStream in= Resources.getResourceAsStream("MybatisConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IDao dao=session.getMapper(IDao.class); //5.使用代理对象执行方法 List&lt;Account&gt; users=dao.getAccountAll(); for (Account user : users) &#123; System.out.println(user); &#125; &#125;&#125; 打印信息为 123456Sat Jul 27 15:54:14 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.Account&#123;id=1, name='aaa', money=600.0&#125;Account&#123;id=2, name='bbb', money=1200.0&#125;Account&#123;id=3, name='ccc', money=1000.0&#125;Account&#123;id=4, name='hhh', money=1000.0&#125;Account&#123;id=5, name='hhh', money=200.0&#125; 如果需要保存数据则把IDao.xml改成以下 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace填写IDao接口的全限定类名--&gt;&lt;mapper namespace="cn.dao.IDao"&gt; &lt;!--配置查询所有 id必须是IDao方法的名称,resultType必须是实体类--&gt; &lt;select id="getAccountAll" resultType="cn.Bean.Account"&gt; select * from account; &lt;/select&gt; &lt;!--通过里面配置selectKey标签的方式可以获取插入数据后所对应的自增长id的值--&gt; &lt;select id="addAccount" parameterType="cn.Bean.Account"&gt; &lt;!--selectKey 会将 SELECT LAST_INSERT_ID()的结果放入到传入的model的主键里面， keyProperty 对应的model中的主键的属性名，这里是 user 中的id，因为它跟数据库的主键对应 order AFTER 表示 SELECT LAST_INSERT_ID() 在insert执行之后执行,多用与自增主键， BEFORE 表示 SELECT LAST_INSERT_ID() 在insert执行之前执行，这样的话就拿不到主键了， 这种适合那种主键不是自增的类型 resultType 主键类型 --&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt;&lt;/selectKey&gt; insert INTO account(name,money) values(#&#123;name&#125;,#&#123;money&#125;) &lt;/select&gt;&lt;/mapper&gt; 值得一提的是：resultType属性可以类型有简单类型或者pojo对象，或者pojo对象的包装对象（pojo对象的列表）。pojo对象就是javabean或者说是实体类对象 ​ 然后上述xml文件配置中就是用了OGNL表达式 OGNL表达式中省略的get关键字，即user.getName()变成了user.name; 在mybatis中标签属性resultType中提供了user对象的包名，所以可以直接使用name来达到user.name相同的效果 测试类里面： 1234567891011121314151617181920212223242526272829303132333435363738import cn.Bean.Account;import cn.dao.IDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123; @org.junit.Test public void getALl() throws IOException &#123; //1.读取配置文件 InputStream in= Resources.getResourceAsStream("MybatisConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IDao dao=session.getMapper(IDao.class); //5.使用代理对象执行方法 Account ac=new Account(); ac.setName("hha"); ac.setMoney(99999.0); dao.addAccount(ac); List&lt;Account&gt; users=dao.getAccountAll(); for (Account user : users) &#123; System.out.println(user); &#125; //如果没有正确提交到数据库需要手动提交事务 //session.commit(); &#125;&#125; 注解配置​ 首先可以把IDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句，同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名 实体类对象的属性名称与mysql数据库里面的列名不同解决方案：#### 原因：​ mysql数据库里面的列不能喝实体类对象的属性进行对应，说以要解决这个问题必须从解决对应关系下手 - 使用mysql的别名进行对应 - 使用mybatis里面的resultMap标签进行对应匹配（然后标签里面的resultType属性换成resultMap属性来使用配置的resultMap标签里面的内容） ## mybatis连接池 ### 连接池数据源分类 UNPOOLED 不使用连接池的数据源 POOLED 使用连接池的数据源 JNDI 使用JNDI实现的数据源]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键操作]]></title>
    <url>%2F2019%2F06%2F27%2FIDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[IDEA 快捷键操作1.搜索跳转 作用 快捷键 备注 多个窗口之间跳转 ctrl+alt+[或者] [跳转到上一个窗口,]跳转到下一个窗口 导航栏跳转 alt+数字键 侧边栏上面标注数字 万能搜索键 按两次shift键 可以打开万能的搜索窗口 跳转到上次编辑的地方 ctrl+shift+backspace 可以定位到上次编辑的地方 跳转到上次浏览的地方 ctrl+alt+左箭头 跳转到上次浏览的地方 跳转到上次浏览的地方返回 ctrl+alt+右箭头 跳转到上次浏览的地方返回 打开最近文件浏览列表 ctrl+E 方便快速的多文件跳转 文件标签 ctrl+F11 给文件添加标签 文件标签跳转 ctrl+标签名称 方便阅读别源代码 添加到喜爱代码库 alt+shift+f 放到类上面添加类到列表里面，放到方法上面添加方法到列表里面 搜索字符串 ctrl+shift+f 搜素所有的字符串 2.代码小助手注意定义 live Template动态模板还有postfix点模板 对选中的大小写进行转换 ctrl+shift+u 对选中的大小写进行转换 选中当前选中的元素进行多行处理 ctrl+shift+alt+j 选中当前选中的元素进行多行处理 格式化代码 ctrl+alt+L 格式化代码 重构变量 shift+f6 重构变量 重构方法 ctrl+f6 重构方法 抽取变量 ctrl+alt+v 抽取变量 将选中的代码块抽取成为函数 ctrl+alt+m 将选中的代码块抽取成为函数 查看选中的类或者接口的继承关系 Ctrl+shift+u 查看选中的类或者接口的继承关系]]></content>
      <categories>
        <category>学习</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>IDEA</tag>
        <tag>IDE</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法树状数组]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%AE%97%E6%B3%95%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[算法:树状数组1.适用场景​ 可以解决大部分基于区间上的更新以及求和问题 2.介绍1.单点查询 我们先从数组讲起(这个就不需要普及了吧)； A数组是我们传入数据的数组 C数组使我们建立起来的树状数组 然后就能显而易见的发现一个规律 12345678C1 = A1C2 = A1+A2C3 = A3C4 = A1+A2+A3+A4C5 = A5C6 = A5+A6C7 = A7C8 = A1+A2+A3+A4+A5+A6+A7+A8 接下来我们引入lowbit这个概念：(这个地方有一点需要注意：lowbit(0)会陷入死循环 ) 1234inline int lowbit(int x)&#123; return x &amp; (-x);&#125; 这返回的是这个数字最高位的1; 在这之前，又要引入一个补码的概念： 补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 请注意，这里的第一位是指的是符号位，而不是数字位(这是1，因此数字位只有1) 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 因此，&amp;是求与的一个符号，意思是 a 和 b 同时为 1 的时候返回这个最高位(不包括符号位) 在刚刚的找规律过程中，我们通过规律总结出了以下性质(lowbit是为了帮助程序代码的实现) 我们可以得到树状数组的一些性质：对于c[i]，他的儿子节点取决于i的所有因子中最多有2^j次幂，则向前取2^j个数作为儿子，即[i-2^j+1,i]。(这个时候就需要lowbit来帮助实现) 举一个栗子： 6的最大2次方因子为2，即2^1，则向前取2个数，则c[6]=a[5]+a[6]； 8的最大2次方因子为8，即2^3，则向前取8个数，则c[8]=a[1]+a[2]+…+a[8]。 2.单点修改 当我们要对最底层的值进行更新时，那么它相应的父亲节点存储的和也需要进行更新， 我们建立的树状数组结构是一个完整的结构，因此修改一个点也会需要所有相应的其父亲节点的点来修改，这样我们就实现了树状数组的修改。 代码如下： 12345678910void modify(int x,int k) //将 x 增加 k&#123; if(x &lt; 1) return ; while(x &lt;= n) &#123; c[i] += k; x += lowbit(x); //去寻找它的父亲 &#125; &#125; 3.单点查询 单点查询由于我们向前统计，因此需要向前查找，这个就不需要讲了吧(没弄明白请看上面) 1234567891011121314int query(int pos)&#123; int sum=0; for(int i=pos;i;i-=lowbit(i)) sum += c[pos]; /*两种写法 while(pos &gt; 0) &#123; sum += c[pos]; pos -= lowbit(pos); &#125; */ return sum;&#125; 1234567891011121314151617181920212223//这是完整的操作void change(int p, int x)&#123; //给位置p增加x while(p &lt;= n) &#123; sum[p] += x; p += p &amp; -p; &#125;&#125;int ask(int p)&#123; //求位置p的前缀和 int res = 0; while(p) &#123; res += sum[p]; p -= p &amp; -p; &#125; return res;&#125;int query(int l, int r)&#123; //区间求和 return ask(r) - ask(l - 1);&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架教程]]></title>
    <url>%2F2019%2F03%2F10%2FSpringMVC%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SpringMVC框架教程前言为开发团队选择一款优秀的MVC框架是件难事儿，在众多可行的方案中决择需要很高的经验和水平。你的一个决定会影响团队未来的几年。要考虑方面太多： 1、简单易用，以提高开发效率。使小部分的精力在框架上，大部分的精力放在业务上。 2、性能优秀，这是一个最能吸引眼球的话题。 3、尽量使用大众的框架（避免使用小众的、私有的框架），新招聘来的开发人员有一些这方面技术积累，减低人员流动再适应的影响。 简介​ pring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架或集成其他MVC开发框架，如Struts]1(现在一般不用)，Struts 2(一般老项目使用)等。 SpringMVC框架优势1.清晰的角色划分：控制器(controller)、验证器(validator)、命令对象(command obect)、表单对象(form object)、模型对象(model object)、Servlet分发器(DispatcherServlet)、处理器映射(handler mapping)、试图解析器(view resoler)等等。每一个角色都可以由一个专门的对象来实现。 2.强大而直接的配置方式：将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在web控制器中对业务对象和验证器validator)的引用。 3.可适配、非侵入：可以根据不同的应用场景，选择何事的控制器子类(simple型、command型、from型、wizard型、multi-action型或者自定义)，而不是一个单一控制器(比如Action/ActionForm)继承。 4.可重用的业务代码：可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类。 5.可定制的绑定(binding)和验证(validation)：比如将类型不匹配作为应用级的验证错误，这可以保证错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象，需要手动解析它并转换到业务对象。 6.可定制的handler mapping和view resolution：Spring提供从最简单的URL映射，到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活。 7.灵活的model转换：在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成。 8.可定制的本地化和主题(theme)解析：支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity(不需要额外的中间层)等等。 9.简单而强大的JSP标签库(Spring Tag Library)：支持包括诸如数据绑定和主题(theme)之类的许多功能。他提供在标记方面的最大灵活性。 10.JSP表单标签库：在Spring2.0中引入的表单标签库，使用在JSP编写表单更加容易。 11.Spring Bean的生命周期：可以被限制在当前的HTTp Request或者HTTp Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。 SpringMVC与Struts2框架的对比拦截机制1、Struts2 a、Struts2框架是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype（否则会出现线程并发问题），然后通过setter，getter吧request数据注入到属性。b、Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。c、Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了2、SpringMVCa、SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。b、在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。 性能方面 SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。 四、拦截机制Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 配置方面spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。SpringMVC可以认为已经100%零配置。 设计思想Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。 集成方面SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 注解详解RequestMapping介绍你可以使用@RequestMapping来映射URL，比如/test到某个Controller类，或者是某个具体的方法。通常类上的注解@RequestMapping用来标记请求的路径，方法上的@RequestMapping注解的作用将是映射到特定的URL到某个具体的处理方法。 作用被添加注解的方法参数就是发起请求的参数，返回值就是通过跳转的页面名字 参数： value,请求的URL路径，支持URL模板，正则表达式。这也是我们最常用的一种映射方 method(多个)，指定接收请求的方法，有GET,POST,PUT等，RequestMethod枚举类，如果没有按规则会抛405 Method Not Allowed params(多个) 指定请求的参数，例如parame=”user” ，那么请求中必须携带user参数的key，如果是parame=”user=123” ，那么参数就key必须是user,value必须是123,否则不能正常执行而且抛出400 错误的请求 headers(多个) 指定请求的头 consumes,允许的媒体类型Media Types ），如consumes ＝ ”application/ison ”， 对应于请求的HTTP 的Content-Type 。 @RequestParam作用：在SpringMVC中如果方法上被添加了·RequestMappring注解且方法有参数，那么必须传入与方法参数同名的的参数名，当使用了这个就可以实现传入产生非同名范围:参数内示例 123456789@RequestMapping("/list")/***传入的参数必须与user同名，而非必须和username同名*/public String test(@RequestParam("user") String username )&#123; return null;&#125; @RequestBady作用：获取请求提的内容，其格式是key:value的格式，其中get请求不适用（get请求没有请求体，它把的参数在url中）,该注解经常使用在异步的方式中范围：参数内注意:方法的名字不能与请求的任何参数同名，因为在Springmvc框架中，任何同名的都被看成同名封装.示例 12345678@RequestMapping("/list")/***注意，方法的名字不能与请求的任何参数同名，因为在Springmvc框架中，任何同名的都被看成同名封装，*/public String test(@RequestBady String bady)&#123; System.out.println(bady);//打印结果将会是key：value的形式 return null;&#125; @PathVariable(REST编程风格)作用: 带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 主要是根据请求方法进行类的区别 范围：参数内 示例: 123456789/***通过使用PathVariable注解实现占位符上数据的获取*参数发送格式应该是请求的url例如xxx/list/12*/@RequestMapping("/list/&#123;sid&#125;")public String test(@PathVariable(name="sid") String id)&#123; System.out.println(id);//结果因该为12 return null;&#125; @ModelAttribute作用： ​ 来处理传入的参数少的问题 ​ 添加在方法上面时候，该方法会优先执行 ​ 添加在参数上面的时候，需要一个map集合来处理传入的参数少的问题 范围：方法上和参数上 示例： 假设有个user的javaBean对象 ​ 第一种，注解添加在方法上 123456789@RequestMapping("/list/modelAttribute")public String test(User user)&#123; System.out.println(user); return null;&#125;@ModelAttributepublic User modelAttribute(User user)&#123;//返回值必须三user类型才能保证接下来的方法接收到参数,参数时user类本方法才能获取到传入的参数 System.out.println("先执行,同时可以做一些其他操作，比如补全user对象不全的信息");&#125; 第二种,注解添加在参数内 123456789@RequestMapping("/list/modelAttribute")public String test(@ModelAttribute("abc") User user)&#123;//获取abc的对象存入user System.out.println(user); return null;&#125;public void modelAttribute(User user,Map&lt;String,User&gt; map)&#123;//返回值就不是必须的，但是参数必须有个map，,map&lt;String,User&gt; System.out.println("先执行,同时可以做一些其他操作，比如补全user对象不全的信息"); map.put("abc",user);//进行一些操作&#125; spring 请求参数绑定绑定简述​ 在SpringMVC中，被添加@RequestMapping的方法的参数就是请求的参数 简要介绍首先javabean类对象 1234567891011121314151617181920212223242526272829package com.qs304;import java.util.List;import java.util.Map;public class Beans &#123; private Integer account; private String password; private Person person; private Map&lt;String,String&gt; map; private List&lt;String&gt; list;&#125;class Person&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + '&#125;'; &#125;&#125; 参数绑定接收方法 123456789@Controller@RequestMapping("parme")public class HelloController &#123; @RequestMapping(value = "/hello",method = RequestMethod.POST) public String helloSpringMVC(Beans beans)&#123;//返回值表示要跳转的jsp页面的名字 System.out.println(beans); return "success"; &#125;&#125; jsp页面的提交 12345678&lt;form action="parme/hello" method="post"&gt; account&lt;input type="text" name="account"&gt;&lt;br/&gt; password&lt;input type="text" name="password"&gt;&lt;br/&gt; pseron.name&lt;input type="text" name="person.name"&gt;&lt;br/&gt; mapkey&lt;input type="text" name="map[key]"&gt;&lt;br/&gt; list&lt;input type="text" name="list[0]"&gt;&lt;br/&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; SpringMVC五大组件DispatcherServlet:前端控制器​ 用户请求到达前端控制器，是整个流程控制的中心 HandlerMapping:处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 ViewResolver:视图解析器ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 Handler:处理器Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 View:视图SpringMVC框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 SpringMVC 框架快速搭建演示首先使用maven创建web项目 然后导入坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;qs.304&lt;/groupId&gt; &lt;artifactId&gt;SpringMVCDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SpringMVCDemo Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SpringMVCDemo&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 然后在web.xml配置前端控制器并且设置为第一次加载的时候加载spring容器 1234567891011121314151617181920212223&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置spring前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载spring容器--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--设置启动项目就加载spring容器--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 之后创建springmvc.xml文件配置视图解析器，并且指定视图解析器扫描的包和文件后缀 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.qs304"/&gt; &lt;!--配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--配置参数--&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启springmvc注解支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 之后配置控制器controller 12345678910111213package com.qs304.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String helloSpringMVC()&#123;//返回值表示要跳转的jsp页面的名字 System.out.println("哈哈哈"); return "success"; &#125;&#125; 这是目录结构 springmvc框架运行流程]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA动态代理]]></title>
    <url>%2F2019%2F02%2F27%2FJAVA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[JAVA动态代理前言：​ 最近在学习spring框架，但是在学习（切面编程）aop的时候老师讲到了一个动态代理，这个东西听着很晕乎，听说在学习javaweb的时候讲filter过滤器也是这个原理，╮(╯▽╰)╭无奈当时没有注意底层也就没有学会，现在正好有机会就把这个动态代理好好学习一下吧。 1.什么是代理代理模式的定义：​ 代理模式给某一个对象提供一个代理对象，并有代理对象控制原对象的引用（╮(╯▽╰)╭，定义都是这么的晦涩难懂） 例子：​ 假如你现在想购买一个笔记本，于是乎当然只关心价格和性能售后啊，而且购买渠道要方便啊，当然厂家生产笔记本后不可能把货物分发到全球各地因为地球太大了，但是消费者想要购买的方便啊，对于消费者来说他要购买方便也就是买电脑的地方离自己比较近，并不关心厂家怎么把电脑弄过来，而且对于厂家来说他只要把电脑做出来做好售后就行了，为什么费这么大劲在各地建立销售网点呢，好钢当然是用在刀刃上面啦。于是乎电脑城这个奸商聚集地就出来了（带着有色眼镜看待的这个问题，不要喷我），奸商正好把厂家和消费者连接起来。而且消费者想维修之类的必须经过代理商也就是电脑城的奸商才能和厂家联系，于是乎这个代理商就起到了代理的作用。 2. 要想知道动态代理首先要知道代理模式的应用场景### 需求和分析：​ 假设有个需求，需要你不修改原有代码的基础上对一个类（Person）的功能进行增强，这下怎么办呢？ ​ 其实可以这样，首先写一个用来增强那个Person那个类的类并且继承Person类实现的那个接口，就叫他Proxy类吧，然后在Proxy类创建的时候可以吧Person这个类当做参数传进去，然后在Proxy类中调用同名的方法（哒哒哒，这就完成啦），其实这个过程就是静态代理模式。也就是说代理对象 = 增强代码 + 目标对象（原对象） 大概就是这样样子，画图比较丑，而且不会用xmind（╮(╯▽╰)╭） 静态代理模式的缺点：​ 这样有什么缺点呢，假设我们有很多个类需要被增强，那么我们要给每一个类都写一个对应的代理类，那么这样也忒麻烦了，代理类你这么麻烦搞的大家都不想和你玩了。 3.动态代理前言​ 动态代理之前要说其实还有一个class类，这个东西比较复杂，（先埋个坑，以后在填坑），class这个类可以获取任意类的构造方法，属性等等等之类的，也就是说我们可以用来复制一个类，代理类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。也就是说接口拥有代理类对象和目标对象共同的类信息，但是类信息不能创建对象。于是乎jdk提供了java.lang.reflect.InvocationHandler接口和java.lan.reflect.Proxy类。 Proxy类​ Proxy有个静态方法：getProxyClass(ClassLoader,interfaces),只要你给他传入类加载器和一组接口，他就会给你返回代理Class对象。 ​ 通俗点说就是，你给他传入接口的Class中，复制类结构到新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。 所以Proxy.getProxyClass()这个方法的本质就是用Class造Class 动态代理的作用：​ Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大； ​ 可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用； ​ 解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。 ### 代码演示电脑生产厂家类（被代理对象） 12 电脑城坑人类（代理对象） 12 销售接口: 12 Main类 12]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码注意细节]]></title>
    <url>%2F2019%2F02%2F20%2F%E4%BB%A3%E7%A0%81%E6%B3%A8%E6%84%8F%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[代码注意细节1.设计细节springspring配置类中父子关系的配置类更好 mysqlmysql中要严格遵守三大范式才能设计比较好的数据库 mysql中使用外键约束要注意进行级联操作，否则必须先修改依赖表 2.编码细节]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架]]></title>
    <url>%2F2019%2F01%2F15%2FSpring%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Spring框架1.Spring简介: 为从大小与开销两方面而言Spring都是轻量的 通过控制反转（IoC）的技术达到松耦合的目的 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发 包含并管理应用对象的配置和生命周期，所以spring是一种容器 将简单的组件配置、组合成为复杂的应用，这个意义上是框架 2.spring的核心 控制反转（IoC）和面向切面编程（AOP） 1.什么事控制反转呢？​ 控制反转loC主要是用来解决耦合的问题的，一个类直接依赖另一个类，这样耦合性是很高的，但是我们可以通过创建一个工厂模式，对象创建另一个对象的时候通过查找map容器，如果map容器不存在，就在本地配置文件中查找类的类名来获取类。这样就把类与类之间的关系转化为了类与工厂与类的关系，从而解决了耦合性的问题。 控制反转loC演示首先创建两个类 Main类是主方法类用来调用Demo方法类里面的toString方法，通过loC控制反转调用 在resources包下面创建一个xml配置文件 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- id表示调用这个类的时候写的类名，class表示类的包名加类名,其中Java目录下的表示根目录 使用注解@Component 类型首字母要小写 --&gt; &lt;bean id="Demo" class="Demo"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;/beans&gt; 12345//ApplicationContext接口的实现对象ClassPathXmlApplicationContext来获取容器ApplicationContext ac= new ClassPathXmlApplicationContext("bean.xml");//通过反射机制获取Bean对象Demo de=ac.getBean("Demo",Demo.class);de.toString(); ApplicationContext接口的继承关系 ApplicationContext:读取配置文件的时候立即加载对象（单例对象适用，经常使用）BeanFatory:遇见getBean的时候才加载对象（多例对象适用）ApplicationConxt接口常用的实现类ClassPathXmlAppliationContext:加载类路径下的配置文件，要求配置文件必须在类路径下FileSystemXmlApplicationContext:加载磁盘任意路径下的配置文件AnnotationConfigAppliationContext:读取注解创建容器3.spring的核心容器Beans(管理bean)Core(核心)Context(上下文（配置文件）)Expresslon Language(SpEl表达式)3.SpringBeanSpringBean创建的三种方式12345678910&lt;!--第一种创建方式id表示调用这个类的时候写的类名，class表示类的包名加类名,其中Java目录下的表示根目录--&gt;&lt;!--使用默认无参构造方法创建--&gt; &lt;bean id="Demo" class="Demo"&gt;&lt;/bean&gt;&lt;!--第二种，使用普通工厂中的方法创建对象,并存入spring容器--&gt; &lt;!--创建Fatory工厂类--&gt; &lt;bean id="Fatory" class="DeFatorymo"&gt; &lt;/bean&gt; &lt;!--获得Service类通过Fatory工厂里面的getService方法--&gt; &lt;bean id="Service" fatory-bean="Fatory" fatory-method="getService"&gt;&lt;/bean&gt;&lt;!--第三种，使用工厂中静态方法创建对象，并存入spring容器--&gt; &lt;bean id="Service" class="Service" facctory-method="getService"&gt;&lt;/bean&gt; SpringBean的作用范围和生存周期Bean标签的scope属性可以指定对象的作用范围 singleton单例对象（默认）解析xml出生，也就是和容器一样 prototype多例对象 ，使用时出生，当对象长时间不使用，而且没有对象引用 的时候被垃圾回收器销毁 request作用于web应用的请求范围 session作用于web的应用的会话范围 global-session:作用于集群环境的会话范围，全局的会话范围 4.Spring注入概述（经常变化的数据不适合注入）​ 平常的Java开发中，程序员在某个类中需要依赖其它类的方法。 ​ 通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理。 ​ Spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过Spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。 ​ 依赖注入的另一种说法是”控制反转”。通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员。 ​ 而控制反转是指new实例工作不由我们程序员来做而是交给Spring容器来做。 详解如果使用注解的方式首先要在xml约束中添加 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--然后告诉spring创建容器时时要扫描的包--&gt; &lt;context:component-scan base-package="&lt;包名&gt;"&gt;&lt;/context:component-scan&gt; ​ 基本数据类型包装类型和String ​ 其他Bean类型（在配置文件中或者注解配置过的Bean） ​ 其他类型/集合类型 注入的方式使用构造函数​ 首先创建一个类,通过构造方法给成员变量进行赋值 12345678910111213141516171819202122import java.util.Date;public class Bean &#123; private int age; private String name; private Date newDate; @Override public String toString() &#123; return "Bean&#123;" + "age=" + age + ", name='" + name + '\'' + ", newDate=" + newDate + '&#125;'; &#125; private Bean(int age, String name, Date newDate)&#123; this.age=age; this.name=name; this.newDate=newDate; &#125;&#125; XML里面这样配置 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- constructor-arg标签属性详解-------------------------------------------------查找构造方法属性： type通过指定数据类型进行查找 index通过指定下标进行查找，下标从0开始 name通过名字进行查找（最常用的方式）---------------------------------------------------赋值： value给对象进行赋值，非String类型能自动转换，特殊类型需要使用rel rel指定其他Ioc核心容器里面的bean对象进行赋值--------------------------------------------------- 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功 弊端：改变了bean实例化的方式，使我们在创建对象时，如果用不大这些数据，也必须提供 --&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;constructor-arg name="age" value="12"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="name" value="哈哈哈哈"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="newDate" ref="newDate"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="newDate" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用set方法（更常用）首先创建如下Bean对象 给里面的成员属性进行赋值 123456789101112131415161718192021222324252627import java.util.Date;public class Bean &#123; private int age; private String name; private Date newDate; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setNewDate(Date newDate) &#123; this.newDate = newDate; &#125; @Override public String toString() &#123; return "Bean&#123;" + "age=" + age + ", name='" + name + '\'' + ", newDate=" + newDate + '&#125;'; &#125;&#125; 然后XML配置文件写 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;!-- constructor-arg标签属性详解-------------------------------------------------查找构造方法属性： name通过set方法名字进行查找---------------------------------------------------赋值： value给对象进行赋值，非String类型能自动转换，特殊类型需要使用rel rel指定其他Ioc核心容器里面的bean对象进行赋值--------------------------------------------------- 优势：创建对象的时候没有明显的限制，可以直接使用默认的无参构造方法进行构建 弊端：如果某个成员变量必须被赋值，则获取对象是有可能set方法没有被执行 --&gt; &lt;property name="age" value="12"&gt;&lt;/property&gt; &lt;property name="name" value="哈哈哈哈"&gt;&lt;/property&gt; &lt;property name="newDate" ref="newDate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="newDate" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 针对复杂的集合数据类型进行set注入Bean类 12345678910111213141516171819202122232425262728293031import java.util.Arrays;import java.util.Date;import java.util.List;import java.util.Map;public class Bean &#123; private String[] strs; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; @Override public String toString() &#123; return "Bean&#123;" + "strs=" + Arrays.toString(strs) + ", list=" + list + ", map=" + map + '&#125;'; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public void setStrs(String[] strs) &#123; this.strs = strs; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125;&#125; XML配置 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;property name="strs"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="123" value="aaa"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 使用注解代替xml配置的注解@Configuration：说明当前类是一个配置类​ @ComponentScan:指定spring在创建容器时要扫描的包 ​ 属性 value和basePackages作用一样 ​ 等同于在xml中的: 1&lt;context:component-scan base-package="&lt;类路径&gt;"&gt;&lt;/context:component-scan&gt; 当使用了AnnotationConfigApplicationContext();这个类的时候可以不使用这个标签，但是如果有多个配置类，需要在ComponentScan注解中包含另一个配置类，并且另一个配置类必须使用Configuration注解来表示他是一个注解类，或者使用import来避免使用Configuration注解这个问题 演示 1234567891011package com.cofing;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.ComponentScan;//首先要声明当前类是一个注解类@Configurable@ComponentScan("类路径")public class Config &#123;&#125; @import导入其他配置类 （有这个注解的配置类也被称为父配置类，那么被包含的配置类被称为子配置类）如果使用AnnotationConfigApplicationContext();导入了主配置类，那么可以通过在主配置类上面填写@import导入其他配置类，而且此时不能被@ComponentScan注解替代 创建对象的注解@Component 作用把当前类对象存入spring容器中​ 属性：value,用于指定bean的id，当我们不写的时候，默认值是当前类名的首字小写 和上面作用一样Controller:用在表现层 Service:用在业务层 Repository:用在持久层 注入数据的注解@Autowired:​ 作用：自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，或者和他的接口父类类型匹配，就注入成功，如果有多个匹配类型按照名字相同的进行匹配，否则匹配失败。 出现位置:可以是变量上，也可以是方法上细节：在使用注解注入时，set方法就不说必须的了。@Qualifier:在按照类型注入的基础之上再按照名称注入，给类成员注入时不能单独使用，给方法参数注入是可以单独使用​ 属性： value:要注入bean的id @Resource: 可以单独使用​ 属性为：name直接按照id进行注入 上面的三个注入都只能对其他bean类型进行注入，不能对基本类型和String类型进行注入，而且集合类型只能使用xml进行注入。 @value作用，用于注入基本类型和String类型的数据而且可以使用spEL表达式@Bean:作用吧当前方法的返回值作为bean对象存入spring的ioc容器中​ 属性：name用于指定bean的id,当不写时，默认值是当前方法的名称 改变作用范围的注解@Scope :用于指定bean的作用范围 不声明默认是单例的​ 属性:value:指定范围的取值，常用取值:singleton prototype ​ 和生命周期相关的注解@PreDestroy​ 作用:用于指定销毁方法 @PostConstruct​ 作用:用于自定初始化方法 @PropertySource 作用:用来指定properties文件的位置（然后@Value标签就可以用spEL表达式去获取值）​ 属性value：指定文件的名称和路径 ​ 关键字classpath表示类路径下 JAVA的动态代理代理模式 （可以进一步增强代码的复用性）​ 代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。​ 按照代理的创建时期，代理类可以分为两种。 ​ 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。​ 动态代理：在程序运行时，运用反射机制动态创建而成。 (个人觉的类似于javaweb的监听器概念) 接下来代码演示 Main.java 123456789101112131415161718192021222324252627282930import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Main &#123; public static void main(String[] args) &#123; final Factory fatory=new Factory(); //消费者通过动态代理购买商品 //ClassLoader:类加载器，加载代理对象的字节码，和被代理对象相同的类加载器 //Class[] 让代理对象和被代理对象有相同方法，固定写法 //InvoactionHandler 用于代理的方法 IProxy proxy=(IProxy) Proxy.newProxyInstance(fatory.getClass().getClassLoader(), fatory.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的热河接口和方法都会经过该方法 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行方法所需要的参数 * @return 和配代理对象具有相同的返回值 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(method.getName().equals("salfMoney")==true)&#123; System.out.print("代理商坑人了"); &#125; return method.invoke(fatory,args); &#125; &#125;); proxy.salfMoney(5000); &#125;&#125; Factory.java 123456789/** * 生产厂家,被代理类 * 要想使用动态代理模式必须要继承一个接口 */public class Factory implements IProxy&#123; public void salfMoney(float money) &#123; System.out.print("卖了"+money+"元"); &#125;&#125; Iproxy.java 1234567/** * 代理接口 */public interface IProxy &#123; //销售商品接口 public void salfMoney(float money);&#125; AOP编程实例​ 使用spring Aop编程除了要加入Spring的spring-aop jar包，还要加入aspectjrt.jar，aspectjweaver.jar，以及aopalliance_1.0.jar 以下两个是与aspectj相关的包,用来支持切面编程的 aspectjrt包是aspectj的runtime包 aspectjweaver是aspectj的织入包 Cglib包是用来动态代理用的,基于类的代理 1.切入点表达式​ 例如：dao包下public void addAccount(int i);和dao包下的public int reAccount(); ​ 手写访问修饰符可以省略不写 12//匹配public void addAccount(int i)可以写成void addAccount(int) 1.返回值类型可以使用通配符* 表示任意返回值2.包名必须用·进行分割 比如 * . * . *形式3.或者使用* .. 匹配多级目录4.方法名称也可以使用通配符 *5.参数列表可以使用float之类的基本数据类型，如果是复杂数据类型需要些包名加类名如果参数列表使用 * 进行通配符匹配只能匹配有参数的方法，要想匹配所有参数列表的需要使用 ..进行匹配2. 4种通知类型1234&lt;aop:before method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:before&gt;&lt;!--前置通知--&gt;&lt;aop:after-returning method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after-returning&gt;&lt;!--后置通知--&gt;&lt;aop:after-throwing method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after-throwing&gt;&lt;!--异常通知--&gt;&lt;aop:after method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after&gt;&lt;!--最终通知--&gt; 环绕通知是spring框架为我们提供的一种可以做在代码中手动控制增强方法合适执行的一种方式如果觉得配置execution比较麻烦可以使用切入点表达式解决项目目录通过xml的方式实现AOP开发步骤​ 1.把通知bean交给spring来管理（LogMessage类） ​ 2.使用aop:config标签表明开始配置切面 ​ 3.使用aop:aspet标签表明配置切面 ​ id属性，是给切面提供一个唯一标识 ​ ref属性：是指定通知类bean的id ​ 4.在aop:aspet标签的内部使用对应标签来配置通知的类型 ​ aop:before标识前置通知 ​ method属性，用于指定Logger类中那个方法是前置通知 pom.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;AOPDmo&lt;/groupId&gt; &lt;artifactId&gt;AOPDmo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; LogMessage.java 用于增强service类的前置 123456789101112package log;/** * 打印日志类 * 用来增强其他类 */public class LogMessage &#123; public void logMessage()&#123; System.out.print("执行了争抢方法的内容"); &#125;&#125; Iservice接口 123456789package service;/** * service接口 */public interface Iservice &#123; public void addAccout(); public void deletAccount(int i);&#125; Service类 123456789101112package service;public class Service implements Iservice&#123; public void addAccout() &#123; System.out.print("添加了账户"); &#125; public void deletAccount(int i) &#123; System.out.print("删除了账户信息"); &#125;&#125; springconfig.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="logmessage" class="log.LogMessage"&gt;&lt;/bean&gt; &lt;bean id="service" class="service.Service"&gt;&lt;/bean&gt; &lt;!--开始aop配置--&gt; &lt;aop:config&gt; &lt;!--开始配置切面--&gt; &lt;aop:aspect id="aoplog" ref="logmessage"&gt; &lt;!--进行前置切面配置--&gt; &lt;aop:before method="logMessage" pointcut="execution(public void service.Service.addAccout())"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; main.java 12345678910111213import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import service.Iservice;import service.Service;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("springconfig.xml"); //注意--必须是service的接口类型， Iservice ser= (Iservice) ac.getBean("service"); ser.addAccout(); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++语言位运算基本用法和骚操作]]></title>
    <url>%2F2018%2F08%2F27%2FCC%2B%2B%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C/C++语言位运算基本用法和骚操作前言:​ 前几天打了徐州ACM的网络模拟赛，其中有个题觉得很容易做出来，但是死活都是卡时间和卡内存，于是乎就百度了一下题解（╮(╯▽╰)╭手动狗头），结果学到了一个新的算法，叫做区间数组，然后就学了学，结果学的云里雾里的，其中区间数组核心的一个确定区间的函数 123lowbit(int x)&#123; return x&amp;(-x);&#125; 更是云里雾里。然后就结束今天的新的吧。 位运算基本用法 操作符 作用 解释 &amp; 位AND 如果 x 和 y 都为 1，则得到 1；如果 x 或 y 任何一个为 0，或都为0，则得到 0 | 位OR 如果 x 或 y 为 1，或都为 1，则得到 1；如果 x 和 y 都为 0，则得到 0 ^ 位 XOR 如果 x 或 y 的值不同，则得到 1；如果两个值相同，则得到 0 ~ 位 NOT（I的补码） 如果 x 为 0，则得到 1，如果 x 是 1，则得到 0 运算符 意义 示例 结果 &lt;&lt; 向左移位 x&lt;&lt;y x 的每个位向左移动 y 个位 &gt;&gt; 向右移位 x&gt;&gt;y x 的每个位向右移动 y 个位 骚操作判断一个整形最后一位是否是1(用来判断奇偶数)123if(n&amp;1)&#123; printf("是奇数");&#125; ### 演示​ 将输入的一个n（int类型整数）转换成二进制小数（n&gt;=0） 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(void)&#123; int n; while(true) &#123; cin&gt;&gt;n; stack&lt;int&gt; sta; while(n&gt;0)//输出二进制末尾小数打印出并且进行移位 &#123; if(n&amp;1) sta.push(1); else sta.push(0); n&gt;&gt;=1; &#125; while(!sta.empty()) &#123; cout&lt;&lt;sta.top(); sta.pop(); &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow入门教程]]></title>
    <url>%2F2018%2F05%2F27%2F1.tensorflow%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1.tensorflow基本介绍1.TensorFlow 简介​ TensorFlow是一个基于数据流编程的符号数学系统，被广泛应用于各类机器学习算法的编程实现，其前身是谷歌的神经网络算法库 2.TensorFlow基本术语张量（tensor）：​ 张量就是基于向量和矩阵的推广，通俗点理解就是可以将标量看成零阶张量，向量看成一阶张量，矩阵就是二阶张量。 图（graph）​ 代表着一段内存地址，也可以理解成所有的节点和张量的集合 节点（op）​ 每个运算和张量都是一个节点，每个节点就是一个op 会话(Session)​ 会话的作用就是执行图的计算，众所周知在TensorFlow中会话之前的都是图的定义或者是op的定义，只能表示关系不参与计算，所以需要用会话让图真正的执行起来 2.张量（tensor）的使用以及注意事项1.张量的基本概念​ 张量就是基于向量和矩阵的推广，通俗点理解就是可以将标量看成零阶张量，向量看成一阶张量，矩阵就是二阶张量。 2.张量的数据类型 数据类型 Python类型 描述 DT_FLOAT tf.float32 32位浮点数 DT_DOUBLE tf.float64 64位浮点数（精度和float32精度一致） DT_INT64 tf.int64 64位有符号整数 DT_INT32 tf.int32 32位有符号整数（精度和int32精度一致） DT_INT13 tf.int16 16位有符号整数 DT_INT8 tf.int8 8位有符号整数 DT_STRING tf.string 可变长度的字节数组，每一个张量元素都是一个字节数组。 DT_BOOL tf.bool 布尔型 DT_COMPLEX64 tf.compiex64 由两个32位浮点数组组成的复数：实数和虚数 DT_QINT32 tf.qint32 用于量化Ops的8位有符号整数 DT.QINT8 tf.qint8 用于量化Ops的8位有符号整形 DT_QUINT8 tf.quint8 用于量化Ops的8位无符号整形 3.张量的代码12345678#导入tensorflow包，简写为tfimport tensorflow as tf#定义一个3.0的常量的张量tensor=tf.constant(3.0)#显示tensor的结果print(tensor)#结果将会是：Tensor("Const:0", shape=(), dtype=float32) 其中Const表示进行的op操作名字shape表示张量的维度,()表示标量，（1）表示向量，（2，3）表示2行3列的张量dtype表示张量的数据类型4.生成张量创建一个常数张量tf.constant(value,dtype=None,shape=None,name=”Const”) 创建一个dtype类型的维度为shape的常数张量 固定值初始化tf.zeros([n,m],tf.dtype)获取一个n行m列的零元素tf.dtype类型的张量 tf.ones([n,m],tf.dtype)获取一个n行m列的1元素tf.dtype类型的张量 随机值初始化tf.random_normal([n,m],mean=2.0,stddev=4,seed=12)创建一个n行m列的正态分布（高斯分布）平均值为2.0，方差为4,随机种子为12张量 5.占位符1tf.placeholder(dtype,shape,name) dtype张量的数据类型 shape张量的维度 [2,3]生成一个2行3列的占位符,[None,3]表示生成一个不确定行和3列的占位符 6.张量的维度调整区别如果调整的过程中生成了新的张量，这种调整称作动态调整 静态调整语法: 张量名字.set_shape([n,m]) 调整张量为n行m列 注意 静态张量只能调整之前不确定维度的张量，比如shape=[None,3]的张量 动态调整语法: tf.reshape(tensor,shape,name=None)动态张量会生成新的张量而且可以跨维度修改，也就是二阶张量可以向n阶张量改变，但是改变前和改变后其总个数必须一致，如果不知道具体维度，需要填写成-1 7.改变张量的类型1tf.cast(x,dtype,name="None") 将x张量转换为dtype类型的张量 1tf.cast([[1,2,3],[4,5,6],[7,8,9]],tf.float32) 将列表从整形转换成float32类型 8.张量的切片和扩展 1tf.concat(value,axis,name="concat") 可以将连个张量拼接起来 value 可以是个列表 axis 表示按行合并还是按列合并 0表示按行合并，1表示按列合并 1234567891011121314151617181920212223242526import tensorflow as tf#定义两个列表a=[[1,2,3],[4,5,6]]b=[[7,8,9],[10,11,12]]#合并两个列表hangCat=tf.concat([a,b],axis=0)lieCat=tf.concat([a,b],axis=1)#由于上面只是搭建了个图结果并没有实际运行,接下来进行实际运行。with tf.Session() as sess: print("行合并") print(sess.run(hangCat)) print("列合并") print(sess.run(lieCat)) #运行结果为：行合并[[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]]列合并[[ 1 2 3 7 8 9] [ 4 5 6 10 11 12]] 3.会话（Session）​ 会话的作用就是执行图的计算，众所周知在TensorFlow中会话之前的都是图的定义或者是op的定义，只能表示关系不参与计算，所以需要用会话让图真正的运行起来 基本写法12with tf.Session() as sess: sess.run(fetches,feed_dict=None,options=None,run_metadata=None) 1.run方法fetches 运行ops和计算tensorfeed_dict 可选项（字典类型），提取使用占位符之后给图提供数据4.变量（Variable）​ 变量是一种特殊的张量，也是一种op,它能够被存储持久化，他们的值就是张量，默认被训练 1.变量的定义1tf.Variable(initial_balue=None,name=None,trainable=True) initial_value 值 可以用正态分布或者固定生成张量的值 注意：使用变量的时候必须先运行全局初始化初始化 tf.global_variables_initializer() 例子： 12345678910import tensorflow as tf#使用正态分布分配变量的值var=tf.Variable(tf.random_normal([2,3],mean=2.0,stddev=1.0))#开启会话并运行初始化with tf.Session() as sess: #运行初始化(运行全局初始化变量前变量var并未被真正赋值) sess.run(tf.global_variables_initializer()) print(sess.run(var)) 4.TensorBoard 的使用和用法1.TensorBoard的简介​ TensorBoard是Tensorflow的可视化工具，它可以通过Tensorflow程序运行过程中输出的日志文件可视化Tensorflow程序的运行状态。TensorBoard和Tensorflow程序跑在不同的进程中，TensorBoard会自动读取最新的TensorFlow日志文件，并呈现当前TensorFlow程序运行的最新状态。 2.TensorBoard代码写入事务文件需要找到TensorFlow包里面的事务包summary里面的FileWriter方法 1tf.summary.FileWriter(logdir,graph=None) logdir事务文件的绝对路径graph写出事务文件的图1234#收集变量tf.summary.scalar(name="",tensor)#收集损失函数和准确率tf.summary.histogram(name="",tensor)#收集高纬度的变量参数tf.summary.image(name="",tensor)#收集输入的图片张量，能显示图片 name 表示TensorBoard里面显示的名称tensor表示要收集的张量123mergin=tf.summary.merge_all()#收集所有的张量summary=sess.run(mergin)#每次迭代都要运行的合并FileWriter.add_summary(summary,i)#每次迭代都要添加到事务文件 3.TensorBoard的演示​ 首先代码 1234567891011121314151617#通过两个变量的相加演示tensorboard的用法import tensorflow as tf#定义两个正态分布的随机变量var1=tf.Variable(tf.random_normal([2,3],mean=2.0,stddev=1.0))var2=tf.Variable(tf.random_normal([2,3],mean=3.0,stddev=2.0))#定义加法opadd=tf.add(var1,var2)init_variable=tf.global_variables_initializer()#开启会话with tf.Session() as sess: #初始化变量 sess.run(init_variable) #导出事务文件 tf.summary.FileWriter("./board",graph=sess.graph) print(sess.run(add)) ​ 然后启动命令行，打出下列命令 1tensorboard --logdir="D:\code\python\tensortflow\board" ​ 之后显示命令行下面显示如下信息 1TensorBoard 1.5.1 at http://By:6006 (Press CTRL+C to quit) 这就表示TensorBoard正常启动了，在浏览器输入（http://By:6006）就能正常访问tensorboard了 5.损失函数1.均方误差​ 计算方法是求预测值与真实值之间距离的平方和 ​ 公式如图所示： 6.梯度下降算法1.基本思想梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。2.代码1tf.tarin.GradientDescentOptimizer(learning_rate) learning_rate 学习率 通常填写0.0到1.0之间的浮点数6.简单的线性回归案例12345678910111213141516171819202122232425262728293031#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢?import tensorflow as tf#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(0.1).minimize(loss)#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): sess.run(train_op) print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) 7.梯度爆炸12345678910111213141516171819202122232425262728293031#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢?import tensorflow as tf#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(1).minimize(loss)#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): sess.run(train_op) print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) 1.简述​ 上述代码学习率是1，运行后就会发现权重和偏置变成了NAV，这就是梯度爆炸，也就是说学习率过大或者神经网络模型的某些原因就会导致梯度爆炸，但是学习率也不能过小，过小会得不到好的效果。 2.解决方法 重新设计神经网络 调整学习率 使用梯度阶段（在训练过程中检查和限制梯度的大小） 使用激活函数 8.模型的保存和加载1.代码1234saver=tf.train.Saver(var_list=None,max_to_keep=5)#在会话里面saver.restpre(sess,"")#读取模型saver.save(sess,"")#保存模型 var_list:自定要保持和还原的变量。他可以作为一个dict或者一个列表传进去max_to_keep:制定要保留的最近检查点文件的最大数量，创建新的文件的时候会删除比较旧的文件，默认值5“” 这个路径包含路径和文件名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢import tensorflow as tfimport os#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(0.1).minimize(loss)#收集张量tf.summary.scalar("loss",loss)tf.summary.histogram("W",w)#合并所有的收集到的张量margin=tf.summary.merge_all()#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#定义保存saver=tf.train.Saver()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) # 读取模型 if os.path.exists("./model/checkpoint"): saver.restore(sess, "./model/123") #写出事务文件 fileWiter=tf.summary.FileWriter("./board",graph=sess.graph) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): summary = sess.run(margin) sess.run(train_op) fileWiter.add_summary(summary,i) # 运行变量的合并 print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) saver.save(sess,"./model/123") 2.保存的文件格式​ .data-00000-of-00001和.index文件 ​ checkpoint文件：checkpoint_dir目录下还有checkpoint文件，该文件是个文本文件，里面记录了保存的最新的checkpoint文件以及其它checkpoint文件列表。在inference时，可以通过修改这个文件，指定使用哪个model。加载restore时的文件路径名是以checkpoint文件中的“model_checkpoint_path”值决定的。 ​ 保存模型时，只会保存变量的值，placeholder里面的值不会被保存。 9.队列机制1.简述​ TensorFlow提供了专门的队列机制,专门用来处理文件读取的问题 2.代码1queue=tf.FIFOQueue(capatity,dtype)#定义一个队列 capatity 队列的容量dtype队列存储的数据类型1queue.dequeue()#出队列并且移除 12queue.enqueue()#入队列int=queue.enqueue_many(list)#入队一个列表元素 演示:1234567891011121314151617181920#定义一个队列，不断出队列和入队列import tensorflow as tf#定义一个队列queue=tf.FIFOQueue()#添加队列元素int=queue.enqueue_many([[1.0,2.0,3.0],])#定义图结构item=queue.dequeue()data=item+1en=queue.enqueue(data)#开始执行图结构with tf.Session() as sess: #运行添加元素结构 sess.run(int) for i in range(20): sess.run(en) for i in range(queue.size().eval()): print(queue.dequeue().eval()) 10.文件读取1.文件读取的过程1.构造文件队列2.构造阅读器3.对于每个样本进行解码4.批处理文件2.文件读取的API介绍构造文件队列1tf.tarin.string_inpput_producer(string_tensor,shuffle=True) string_tensor 含有文件名的一阶张量（包含路径以及文件名的列表）shuffle 是否乱序 默认乱序num_epochs 过几遍数据，默认无限过数据构造文件阅读器 所有阅读器解码出来形状都是不固定的，注意后边进行形状固定 要根据文件类型选择对应的文件阅读区 每个read方法返回key，和value参数，其中key表示文件名称，value表示每个样本 文本文件和CSV文件: 12class reader=tf.TextLineReader()#构造文件阅读器 reader.read(file_queue)#读取一个样本 文本文件阅读器，默认按行读取，（因为对于csv文件和文本文件来说，一行就是一个样本）return 返回阅读器实例read(file_queue)file_queue 从队列里面读取内容二进制文件阅读器12class reader=tf.FixedLengthRecordReader(record_bytes)#构造文件阅读器 reader.read(file_queue)#读取一个样本文件 读取每个样本是按固定数量的字节读取的二进制文件record_bytes:整形，指定每次读取的字节数return 返回阅读器实例图片文件阅读器12class reader=tf.WholeFileReader()#构造图片文件阅读器 reader.read(file_queue)#读取一个图片样本 每个样本进行解码CSV文件解码1tf.decode_csv(value,record_defaults=None) value表示待解码的内容record_defaults 表示每个样本如何解码，并且缺失的时候的默认值 [[1]]表示一个样本按整形解码，缺失的时候为1，[[“None”],[1.0]] 表示样本有两个第一个按string类型解码，缺失的时候是None,第二个按float类型解码，丢失按1.0处理图片文件解码 123456tf.image.decode_jpeg(contents)#将JPEG编码的图像解码为uint8的张亮#return:uint8张量3-D形状[height,width,hannels]tf.image.decode_png(contents)#将PNG图片的图像解码为uint8或者uint16的张量#return:张量类型，3-D形状[height,width,hannels] 图片文件缩放 123tf.image.resize_images(images,size)images:4-D形状[batch,height,width,channels]或者3-D的形状的张量[height,width,channels]size图片的新尺寸，new_height,new_width 管道批处理文件 12#批处理 batch_size表示每批的数量，num_threads进行的线程数量，capacity批处理管道的容量 ones,twos=tf.train.batch([one,two],batch_size=6,num_threads=1,capacity=9) 3.文件读取的简单演示1234567891011121314151617181920212223242526272829303132333435363738394041424344#1.构造文件队列（路径加文件名）#2.构造文件阅读器#3.按每个样本解码（转化为张量 ）#4.构造批处理###在同目录下有个data文件夹，里面的csv文件里面都有两行且都是string类型import tensorflow as tfimport os#找到对应的文件目录获取文件路径加列表def fileRead(path): fileName=os.listdir(path) filePath=[os.path.join(path,file) for file in fileName] return filePathdef csvRead(fileList): #构造文件队列 fileQueue=tf.train.string_input_producer(fileList) #构造阅读器 reader=tf.TextLineReader() key,value=reader.read(fileQueue) #对文件进行解码 #设定每行的类型以及每行的默认值 cord=[["None"],["None"]] one,two=tf.decode_csv(value,record_defaults=cord) #批处理 batch_size表示每批的数量，num_threads进行的线程数量，capacity批处理管道的容量 ones,twos=tf.train.batch([one,two],batch_size=6,num_threads=1,capacity=9) return ones,twosif __name__ == "__main__": fileList=fileRead("./data") one,two=csvRead(fileList) with tf.Session() as sess: #定义一个线程协调器 coord=tf.train.Coordinator() #开启一个线程 thread=tf.train.start_queue_runners(sess,coord=coord) print(sess.run([one,two])) #回收子线程 coord.request_stop() coord.join(thread) 图片文件的读取简单演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#读取当前文件夹下面的data目录下面所有的jpg格式图片的信息#步骤# 1.获取path文件下面的所有图片的全路径列表# 2.构造文件队列# 3.构造图片阅读器# 4.图片解码# 5.图片缩放# 6.图片调整维度# 7.批处理import tensorflow as tfimport os#读取path目录下所有的图片信息def getPath(path): fileNames=os.listdir(path) filePath=[os.path.join(path,fileName) for fileName in fileNames] return filePath#读取图片并进行批处理def readImg(filePathList): #1.构造文件队列 fileQueue=tf.train.string_input_producer(filePathList) #1.构造图片阅读器 reader=tf.WholeFileReader() key,value=reader.read(fileQueue) print("构造完阅读器",value) #3.图片解码 image=tf.image.decode_jpeg(value) print("解码",image) #4.图片缩放 reImage=tf.image.resize_images(image,[200,200]) print("图片放缩后",reImage) #5.图片定型 静态调整 reImage.set_shape([200,200,3]) print("图片静态调整后",reImage) #文件批处理 jpg=tf.train.batch([reImage],batch_size=5,num_threads=2,capacity=5) return reImageif __name__ == "__main__": filePathList=getPath("./data") jpg=readImg(filePathList) #开启会话 with tf.Session() as sess: #定义一个线程协调器 coord=tf.train.Coordinator() #定义一个线程 thread=tf.train.start_queue_runners(sess,coord=coord) print(sess.run(jpg)) #回收子线程 coord.request_stop() coord.join(thread) 注意打印结果: 构造完阅读器 Tensor(“ReaderReadV2:1”, shape=(), dtype=string)解码 Tensor(“DecodeJpeg:0”, shape=(?, ?, ?), dtype=uint8)图片放缩后 Tensor(“Squeeze:0”, shape=(200, 200, ?), dtype=float32)图片静态调整后 Tensor(“Squeeze:0”, shape=(200, 200, 3), dtype=float32) 11.交叉熵损失计算和softMax计算1.softMax计算​ 假设我们有一个数组，V，Vi表示V中的第i个元素，那么这个元素的Softmax值就是 ​ 可以计算n个结果之间发生的概率 2.交叉熵损失​ 可以和onehost编码与softMax计算损失 123456#SoftMax和交叉熵损失计算tf.nn.softmax_cross_entropy_with_logits(babels=None,logits=None,name)#计算logits和labels之间的交叉熵损失#labels:真实值#logits:预测值#return:返回所有样本的损失值列表 3.演示12345678910111213141516def argmax(input, axis=None, name=None, dimension=None, output_type=dtypes.int64)numpy.argmax(a, axis=None, out=None) 返回沿轴axis最大值的索引。Parameters: input: array_like，数组axis : int, 可选，默认情况下，索引的是平铺的数组，否则沿指定的轴。 out : array, 可选 如果提供，结果以合适的形状和类型被插入到此数组中。 Returns: index_array : ndarray of ints 索引数组。它具有与a.shape相同的形状，其中axis被移除。 12345678910111213141516171819202122232425262728293031323334353637383940#简单的神经网络识别手写数字#1.定义占位符#2.搭建神经网络#3.计算损失#4.反向传播优化损失#5.计算准确率#6.开启会话训练import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets("./MNIST_data", one_hot=True)def imgNn(): #1.定义占位符 xDist=tf.placeholder(tf.float32,[None,784]) yTrue=tf.placeholder(tf.float32,[None,10]) #2.初始化变量搭建神经网络 w=tf.Variable(tf.random_normal([784,10],mean=0.0,stddev=1.0)) b=tf.Variable(tf.random_normal([10],mean=0.0,stddev=1.0)) y=tf.matmul(xDist,w)+b #3.计算平均交叉熵损失率 loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=yTrue,logits=y)) #4.反向传播最小优化学习率0.1 trainOp=tf.train.GradientDescentOptimizer(0.1).minimize(loss) #5.计算准确率 arg_max会反正正确结果的下标 1表示按同行比较 0表示同列 equal_list=tf.equal(tf.arg_max(yTrue,1),tf.arg_max(y,1)) acuracy=tf.reduce_mean(tf.cast(equal_list,tf.float32)) initOp=tf.global_variables_initializer() #6.开启会话开始训练 with tf.Session() as sess: sess.run(initOp) for i in range(3000): #取出特征值和目标值 minstX,minstY=mnist.train.next_batch(50) sess.run(trainOp,feed_dict=&#123;xDist:minstX,yTrue:minstY&#125;) print("%d步准确率%f" % (i,sess.run(acuracy,feed_dict=&#123;xDist:minstX,yTrue:minstY&#125;)))if __name__ =="__main__": imgNn() 12.卷积神经网络1.概述​ 卷积神经网络（Convolutional Neural Networks / CNNs / ConvNets）与普通神经网络非常相似，它们都由具有可学习的权重和偏置常量(biases)的神经元组成。每个神经元都接收一些输入，并做一些点积计算，输出是每个分类的分数，普通神经网络里的一些计算技巧到这里依旧适用。 具有三维体积的神经元(3D volumes of neurons) ​ 卷积神经网络利用输入是图片的特点，把神经元设计成三个维度 ： width, height, depth(注意这个depth不是神经网络的深度，而是用来描述神经元的) 。比如输入的图片大小是 32 × 32 × 3 (rgb)，那么输入神经元就也具有 32×32×3 的维度。 2.卷积神经网络分层卷积层—&gt;激活层—&gt;池化层—&gt;全连接层##### 卷积层：​ 卷积神经网路中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过反向传播算法优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网络能从低级特征中迭代提取更复杂的特征。 激活层：​ 通过Relu激活函数可以增加网络的非线性分割能力 池化层：​ 用来减少数据量 3.填充算法SAME：​ 当filter过滤到边缘的时候自动填充0 - 越过边缘取样，取样的面积和输入的图像像素长度和宽度相同VALID： 当filter过滤到边缘的时候跳过，所有会丢失部分特征，取样的面积和输入的图像像素长度和宽度会略小 计算公式为：输入体积大小h1 * w1 * d1 ，filter数量为k,filter大小为f,步长为s,填充大小为p 那么 h2=(h1-f+2p)/s+1 w2=(w1-f+2p)/s+1 d2=k 4.API介绍12#卷积层tf.nn.conv2d(input,filter,strides=,padding=,name=None) input: 输入的4-D张量，具有[batch,height,width,channel],类型为float32，或者float64([每批数,图片长度，图片宽度，图片通道数])filter:指定过滤器4-D随机初始化的张量：,类型为float32或者float64([过滤器长度，过滤器宽度，输入的通道数，输出的通道数])，——- 注意需要传入4-D张量，而不是简单的填入维度strides:strides=[1,stride,stride,1],步长（[1，长上步长，宽上步长，1]）padding=:”SAME”，“VALID”，使用的填充算法类型.12#relu激活函数tf.nn.relu(feacutes,name=None) features:卷积后加上偏置的结果return :结果12#池化tf.nn.max_pool(value,ksize=,strides=,padding=,name=None) value:4-D tensor形状[batch,height,width,channels]，也就是激活函数处理后的结果ksize池化窗口大小，[1,ksize,ksize,1]步长大小,[1,strides,strides,1]padding :”SAME”,”VALID”填充算法5.演示两层卷积神经网络识别手写数字​ 1.输入数据形状[None,784] ##### 第一层卷积神经网络卷积层​ 2.因为卷积API的input即输入为4-D张量，所以动态改变形状改为[None,28,28,1],使用32个filter的5*5大小，步长为1，SAME填充算法的过滤器且卷积后输出的形状为[None,28,28,32]，有多少个filter就有多少个偏置所以为32，权重就是每个filter的值. ###### 激活层​ 3.不改变数据大小，所以输出还是[None,28,28,32] ###### 池化​ 4.大小为2 *2，步长为2，填充算法为“SAME”(这里SAME后的大小比原来小)将[None,28,28,32]的图像池化为[None,14,14,32] 第一层卷积神经网络卷积层​ 2.因为卷积API的input即输入为4-D张量，输入为[None,14,14,32],使用64个filter的5*5大小，步长为1，SAME填充算法的过滤器且卷积后输出的形状为[None,14,14,64]，有多少个filter就有多少个偏置所以为64,权重就是每个filter的值. 激活层​ 3.不改变数据大小，所以输出还是[None,14,14,64] 池化​ 4.大小为2*2，步长为2，填充算法为“SAME”(这里SAME后的大小比原来小)将[None,14,14,64]的图像池化为[None,7,7,64] 全连接层​ 因为池化后数据为[None,7,7,64],而且矩阵乘法只能处理二维数据，所以动态调整形状为[None,7 * 7 *64],又因为输出是10种结果，所以全连接层为[7 * 7 *64,10],所以权重[7 * 7 *64,10]偏置有10个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475##### 两层卷积神经网络识别手写数字import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datadef getVarRandom_normal(shape): return tf.Variable(tf.random_normal(shape=shape,mean=0.0,stddev=1.0))#搭建神经网络def conV(): #1.定义占位符 xDist=tf.placeholder(tf.float32,[None,784]) yTrue=tf.placeholder(tf.float32,[None,10]) #2.搭建第一层卷积网络 filter 有32个 大小为5*5，步长为1， with tf.name_scope("con1"): xshape=tf.reshape(xDist,[-1,28,28,1]) filterW=getVarRandom_normal([5,5,1,32]) b=getVarRandom_normal([32]) #卷积层 con1=tf.nn.conv2d(xshape,filterW,strides=[1,1,1,1],padding="SAME")+b #激活层 relu=tf.nn.relu(con1) #池化层 大小为2*2 步长为2 [None,28,28,32]----&gt;[None,14,14,32] pool=tf.nn.max_pool(relu,ksize=[1,2,2,1],strides=[1,2,2,1],padding="SAME") #3.搭建第二层卷积网络 filter有64个，大小为5*5，步长为1 with tf.name_scope("con2"): filterW2=getVarRandom_normal([5,5,32,64]) b1=getVarRandom_normal([64]) #卷积层 con2=tf.nn.conv2d(pool,filterW2,strides=[1,1,1,1],padding="SAME")+b1 #激活层 relu2=tf.nn.relu(con2) #池化层 pool2=tf.nn.max_pool(relu2,ksize=[1,2,2,1],strides=[1,2,2,1],padding="SAME") #全连接层 w3=getVarRandom_normal([7*7*64,10]) b3=getVarRandom_normal([10]) shape = tf.reshape(pool2, [-1, 7*7*64]) grop=tf.matmul(shape,w3)+b3 return xDist,yTrue,gropif __name__ == "__main__": xDist,yTrue,opInt=conV() mnist = input_data.read_data_sets("./MNIST_data", one_hot=True) #计算平均交叉熵损失 loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=yTrue,logits=opInt)) #反向传播 trainOp=tf.train.GradientDescentOptimizer(0.00001).minimize(loss) #计算准确率 equal_list = tf.equal(tf.argmax(yTrue, 1), tf.argmax(opInt, 1)) acuracy = tf.reduce_mean(tf.cast(equal_list, tf.float32)) initOp = tf.global_variables_initializer() # 6.开启会话开始训练 with tf.Session() as sess: sess.run(initOp) for i in range(3000000): # 取出特征值和目标值 minstX, minstY = mnist.train.next_batch(50) sess.run(trainOp, feed_dict=&#123;xDist: minstX, yTrue: minstY&#125;) print("%d步准确率%f" % (i, sess.run(acuracy, feed_dict=&#123;xDist: minstX, yTrue: minstY&#125;)))]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>TensorFlow</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用入门]]></title>
    <url>%2F2018%2F05%2F27%2FGit%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Git使用入门前言​ 之前在网上接私活的时候使用了一下github,当时一下都惊艳到我了，（见识短╮(╯▽╰)╭），当时因为用的c#语言开发，使用的vs2017，他继承的那个git是中文的，特别好用，但是也导致了我啥也没学会，正好今天有空，就填补一下这个大坑吧 简介​ 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。（百度粘贴过来的，╮(╯▽╰)╭） 概念介绍​ git可以将工作区（Working Directory）的代码放到暂存区，最后统一把暂存区的代码合并到我们的git仓库中（这个仓库其实还是本地的仓库）。（╮(╯▽╰)╭我觉得解释的很不清楚） 12345st=&gt;start: git仓库e=&gt;end: 工作空间item=&gt;subroutine: 暂存区e-&gt;item-&gt;st 使用git工具要先进行初始化1234git config --global user.name "yang295513"//这个name一定要填写github上面的名称git config --global user.email "15993343299@163.com"//对应的邮箱//这个不是必须的但是新建git仓库就要进去进行这个命令，然后git工具会生成一个隐藏文件.gitgit init 就这样，之后就可以愉快的玩耍了 指令介绍 指令名 作用 注释 git status 显示当前文件的状态 用来确定文件在三个区的位置 git add 文件名.文件类型 将文件添加到暂存区 把工作空间的文件添加到暂存区 git commit -m “提交描述” 把暂存区所有的文件提交到仓库 提交描述用来标识文件的改动，也就是说本次提交的注释 git push 将本地代码提交到git远程 仓库中 将本地代码提交到git远程仓库中 git clone 仓库地址 将远程git的代码下载下来 案例演示首先这里新建了一个演示项目 然后我们通过git clone命令把这个项目下载下来，其中项目的链接在这里： 然后我们使用git工具克隆下来 这是本地生成的文件 其中那个.git的隐藏文件就隐藏着配置信息 githubTest就是咱们的测试信息 githubTest文件里面的信息可以看到和我们的远端github仓库中的一模一样 接下来我们在本地创建一个Test.java的类，来模拟我们的项目 然后使用git add命令和git commit -m和git push命令依次提交到git远端仓库中 然后去github来查看是否已经被提交了 完美,收场，学习新东西去不不不，还有一些使用细节得介绍一下 你提交了那些文件那些文件才会被替换，也就是说你同时修改了A和B文件，那三连 都是针对B文件的，那么你提交到远端git仓库在只会修改你提交的B文件，没有B文件进行创建,有B文件更新 如果提交到远端失败的话，要注意是否是name和Email书写错误，或者说该仓库是priavte（私有的）如果是私有的去对应配置文件下修改账号密码即可]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
      </tags>
  </entry>
</search>
