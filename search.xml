<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot入门]]></title>
    <url>%2F2019%2F10%2F20%2Fspringboot%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[springboot入门概述: 什么是springboot 它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。 它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架 使用springboot有什么好处回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要： 1）配置 web.xml，加载 spring 和 spring mvc 2）配置数据库连接、配置日志文件 3）配置家在配置文件的读取，开启注解 4）配置mapper文件 ….. 而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了… 划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。 快速入门 1.导入maven坐标12345678910111213141516171819202122232425&gt; &lt;properties&gt;&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&gt; &lt;/properties&gt;&gt; &lt;parent&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&gt; &lt;/parent&gt;&gt; &gt; &gt; &lt;dependencies&gt;&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&gt; &lt;/dependency&gt;&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;junit&lt;/groupId&gt;&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt;&gt; &lt;version&gt;4.11&lt;/version&gt;&gt; &lt;scope&gt;test&lt;/scope&gt;&gt; &lt;/dependency&gt;&gt; &lt;/dependencies&gt;&gt; 2.新建springboot入口（其他包必须与此类在同级目录或者子包下 ）123456789101112&gt; package com.qs304;&gt; &gt; import org.springframework.boot.SpringApplication;&gt; import org.springframework.boot.autoconfigure.SpringBootApplication;&gt; &gt; @SpringBootApplication&gt; public class SpringbootRunMain &#123;&gt; public static void main(String[] args) &#123;&gt; SpringApplication.run(SpringbootRunMain.class,args);&gt; &#125;&gt; &#125;&gt; 3.编写controller123456789101112131415&gt; package com.qs304.controller;&gt; &gt; import org.springframework.stereotype.Controller;&gt; import org.springframework.web.bind.annotation.RequestMapping;&gt; import org.springframework.web.bind.annotation.ResponseBody;&gt; &gt; @Controller&gt; public class HellpController &#123;&gt; @RequestMapping("/hello")&gt; @ResponseBody&gt; public String helloWorld()&#123;&gt; return "HelloWorld";&gt; &#125;&gt; &#125;&gt; 然后浏览器输入ip+项目名称就能访问了 Springboot研究 1.POM文件1.父项目（一般作为依赖管理）123456&gt; &lt;parent&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&gt; &lt;/parent&gt;&gt; 这个starter父项目还依赖了一个叫spring-boot-dependencies的父项目spring-boot-starter-parent(定义了每一个依赖的版本,管理springboot版本仲裁中心，定义了所有的依赖版本)1234567891011121314151617181920212223&gt; &lt;properties&gt;&gt; &lt;!-- Dependency versions --&gt;&gt; &lt;activemq.version&gt;5.14.5&lt;/activemq.version&gt;&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;&gt; &lt;appengine-sdk.version&gt;1.9.59&lt;/appengine-sdk.version&gt;&gt; &lt;artemis.version&gt;1.5.5&lt;/artemis.version&gt;&gt; &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt;&gt; &lt;assertj.version&gt;2.6.0&lt;/assertj.version&gt;&gt; &lt;atomikos.version&gt;3.9.3&lt;/atomikos.version&gt;&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt;&gt; &lt;caffeine.version&gt;2.3.5&lt;/caffeine.version&gt;&gt; &lt;cassandra-driver.version&gt;3.1.4&lt;/cassandra-driver.version&gt;&gt; &lt;classmate.version&gt;1.3.4&lt;/classmate.version&gt;&gt; &lt;commons-beanutils.version&gt;1.9.3&lt;/commons-beanutils.version&gt;&gt; &lt;commons-collections.version&gt;3.2.2&lt;/commons-collections.version&gt;&gt; &lt;commons-codec.version&gt;1.10&lt;/commons-codec.version&gt;&gt; &lt;commons-dbcp.version&gt;1.4&lt;/commons-dbcp.version&gt;&gt; &lt;commons-dbcp2.version&gt;2.1.1&lt;/commons-dbcp2.version&gt;&gt; &lt;commons-digester.version&gt;2.1&lt;/commons-digester.version&gt;&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt;&gt; ...&gt; &lt;/properties&gt;&gt; 没有被定义的依赖还是需要我们手动进行版本的定义的 2.依赖&lt;dependency&gt;12345&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&gt; &lt;/dependency&gt;&gt; spring-boot-starter-web：​ spring-boot-starter:是springboot的场景启动器，帮我们导入了web模块相关的依赖 也就是所还有很多其他的场景 springbot将所有的功能抽取出来，做成了一个个的starters（启动器）,只需要在项目里面引入这些相关场景，就能把需要的功能导入进来。 @SpringBootApplication: Spring Boot 应用标注在某个类上说明这个类似SpringBoot的主配置类,springBoot就是运行这个类的main方法来启动SpringBoot应用:@SpringBootApplication里面的注解 1234567891011121314151617&gt; @Target(&#123;ElementType.TYPE&#125;)&gt; @Retention(RetentionPolicy.RUNTIME)&gt; @Documented&gt; @Inherited&gt; @SpringBootConfiguration&gt; @EnableAutoConfiguration&gt; @ComponentScan(&gt; excludeFilters = &#123;@Filter(&gt; type = FilterType.CUSTOM,&gt; classes = &#123;TypeExcludeFilter.class&#125;&gt; ), @Filter(&gt; type = FilterType.CUSTOM,&gt; classes = &#123;AutoConfigurationExcludeFilter.class&#125;&gt; )&#125;&gt; )&gt; @ConfigurationPropertiesScan&gt; @SpringBootConfiguration:Spring Boot配置类标注在某个类上，表示这是一个SpringBoot的配置类: @SpringBootConfiguration:Spring里面的注解有 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration( proxyBeanMethods = false) Configuration：使用这个注解表示这个类是一个配置类（配置类也是一个组件）EnableAutoConfiguration：开启自动配置(以前手写SSM框架整合的时候需要我们手写配置，现在SpringBoot通过这个注解开启自动配置，这样自动配置才能生效)@EnableAutoConfiguration这个注解里面的注解有: 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;) @AutoConfigurationPackage：自动配置包@AutoConfigurationPackage里面的注解 12345@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;) ​ @import：给容器导入组件 最后，由SpringBootApplication标注的类，的所在包和下面的子包里面所有组件扫描到Spring容器中; yml配置文件SpringBoot默认会使用两个全局配置文件 application.properties application.yml yml简介 YAML (YAML Aint Markup Language)是一种标记语言，通常以.yml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C/C++, Ruby, Python, Perl, C#, PHP等。 yml的优点 YAML易于人们阅读。 YAML数据在编程语言之间是可移植的。 YAML匹配敏捷语言的本机数据结构。 YAML具有一致的模型来支持通用工具。 YAML支持单程处理。 YAML具有表现力和可扩展性。 YAML易于实现和使用。 yml的语法1.约定 k: v表示键值对关系，（注意冒号后面必须有一个空格) 使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是一个层级的 大小写敏感 使用缩进时不允许使用tab键，只能使用空格 松散的表示，java中对于驼峰命名法，可以用原名或者使用-代替驼峰（bean的lastName属性，可以使用lastName或者last-name） 在yml语法中，空值可以使用null表示 键值对关系 字符串默认不用加单引号或者双引号 “”双引号；会转义字符串里面的特殊字符， ‘’单引号不会转义里面的字符 list数组类型行内写法使用[]，展开使用- map类型行内写法使用{}，展开使用k: v 日期使用 2019/01/01 文档块使用—-隔开，可以把不同的配置文件写入一个yml配置文件中 演示 123456789101112ren: #普通的int类型 id: 10 #String类型 name: 100 #list类型，里面是String类型 list: ["我是双引号我换行码？\n换行",'我是单引号我换行码?\n不换行'] #string类型,使用null string: null #运行结果: #Person&#123;id=10, name='100', list=[我是双引号我换行码？ #换行, 我是单引号我换行码?\n不换行], string=''&#125; @Value和@ConfigurationProperties注解的区别 @ConfigurationProperties @Value 功能 批量注入文件中的属性 一个一个指定 松散绑定（松散语法） 支持 不支持 spel 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 总结 @Value只能获取基本数据类型 @ConfigurationProperties可以获取map,list等封装类型的值 配置文件yaml和properties都可以获取到值 如果只是需要在业务逻辑中获取一下配置文件中的某个值，使用@Value 如果要是把javabean和配置文件进行11映射，使用@ConfigurationProperties @ConfigurationProperties默认是从全局配置文件中获取值的 @PropertySource与@ImportResource的区别PropertySource自定义配置文件，多用于配置文件与实体属性映射 在从配置文件里面获取值，与javaBean做映射时存在一个问题，我们从主配置文件（application.yml）里面读取会导致主配置文件特别臃肿，为了按照不同模块自定义不同的配置文件引入了@PropertySource 演示： 12345678910person.propertiesperson.lastName=李四person.age=25person.birth=2017/12/15person.boss=trueperson.maps.key1=value1person.maps.key2=value2person.lists=a,b,cperson.dog.name=dogperson.dog.age=2 javabean 12345678@PropertySource(value = &#123;"classpath:person.properties"&#125;)//通过类路径修改默认配置文件@ConfigurationProperties(prefix = "person")//加载配置文件@Componentpublic class Person &#123; private String lastName; private Integer age; private boolean isBoss; private Date birth; @ImplementResources 一般情况下我们自定义的xml配置文件默认情况下这个bean是不会加载到Spring容器中来的，于是乎我们需要@ImportResoure注解将这个配置文件加载进来 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.chentongwei.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; 总结： @PropertySource 用于引入.Properties或者 *.yml 用于给javabean注入值 @ImportResource 用于引入.xml 类型的配置文件 在spring boot中已经被配置类替代 @PropertySource 一般用在javabean的类名上 @ImportResource一般用于启动类上 SpringBoot配置文件占位符前言: 在springboot的配置文件中，我们可以使用springboot提供的一些随机数或者使用我们在配置文件中定义的值 随机数12345678910person.propertiesperson.lastName=$&#123;person.properties&#125;person.age=25person.birth=2017/12/15person.boss=trueperson.maps.key1=$&#123;random.int[1024,65536]&#125;person.maps.key2=value2person.lists=a,b,cperson.dog.name=dogperson.dog.age=2 ${random.value} - 类似uuid的随机数，没有”-“连接 ${random.int} - 随机取整型范围内的一个值 ${random.long} - 随机取长整型范围内的一个值 ${random.long(100,200)} - 随机生成长整型100-200范围内的一个值 ${random.uuid} - 生成一个uuid，有短杠连接 ${random.int(10)} - 随机生成一个10以内的数 ${random.int(100,200)} - 随机生成一个100-200 范围以内的数 占位符12person.propertiesperson.lastName=$&#123;person.properties&#125;#引用person.properties的值 SpringBoot配置Profile多环境支持1.多Profile文件​ 我们在主配置文件编写的时候，文件名可以是 application-{profile}.yml或者application-{profile}.properties ,都行，以下用yml为主。以下主配置文件表示 application.yml 编写一个名为 application-dev.yml文件： 12server: port: 8081 123#编写一个名为application-prod.yml文件：server: port: 8082 先启动springboot项目，发现启动的端口为 81(application.yml中指定的端口为 81) ，也就是说默认启动的是application.yml的环境。 2.yml多文档块支持配置文件中也支持使用多文档块的方式创建多环境，是用 — (三个-)表示一个文档块 ，如果不指定启动别的文档块，默认启动第一个文档块，可以通过 spring.profiles.actice=dev 来指定启动别的文档块。 12345678910111213141516server: port: 8081spring: profiles: #指定启动的环境 active: dev---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod 这样启动的时候就会使用dev这个环境 3.使用命令指定环境在idea里面有一个run configurations中指定参数 –spring.profiles.active=dev也可以指定环境]]></content>
  </entry>
  <entry>
    <title><![CDATA[pageHelper入门]]></title>
    <url>%2F2019%2F10%2F20%2FpageHelper%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[pageHelper入门前言 之前写web网页的时候使用的是SQL语句中的limit进行分页，无意间发现这种分页写法特别傻屌（╮(╯▽╰)╭），假如你每页有100条数据，你要查询第100页的数据，那么这个SQL语句做的事情就是获取前100100大概这个范围的数据，然后把前100000条数据丢弃，这样是非常浪费性能的，所有我就学习了pageHelper这个分页插件 快速入门步骤 1.使用maven导入依赖 123456&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;&gt; &lt;version&gt;5.1.2&lt;/version&gt;&gt; &lt;/dependency&gt;&gt; 2.在配置文件中配置拦截器插件 第一种：使用spring的属性配置 12345678910111213141516&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;&gt; &lt;!-- 注意其他配置 --&gt;&gt; &lt;property name="plugins"&gt;&gt; &lt;array&gt;&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt;&gt; &lt;property name="properties"&gt;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt;&gt; &lt;value&gt;&gt; params=value1&gt; &lt;/value&gt;&gt; &lt;/property&gt;&gt; &lt;/bean&gt;&gt; &lt;/array&gt;&gt; &lt;/property&gt;&gt; &lt;/bean&gt;&gt; 第二种使用mybatis配置 12345678910111213141516&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;&gt; &lt;!-- 注意其他配置 --&gt;&gt; &lt;property name="plugins"&gt;&gt; &lt;array&gt;&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt;&gt; &lt;property name="properties"&gt;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt;&gt; &lt;value&gt;&gt; params=value1&gt; &lt;/value&gt;&gt; &lt;/property&gt;&gt; &lt;/bean&gt;&gt; &lt;/array&gt;&gt; &lt;/property&gt;&gt; &lt;/bean&gt;&gt; 3.编写需要分页的controller 1234567891011121314151617181920&gt; //获取第1页，10条内容，默认查询总数count&gt; PageHelper.startPage(1, 10);&gt; List&lt;Country&gt; list = countryMapper.selectAll();&gt; //用PageInfo对结果进行包装&gt; PageInfo page = new PageInfo(list);&gt; //测试PageInfo全部属性&gt; //PageInfo包含了非常全面的分页属性&gt; assertEquals(1, page.getPageNum());&gt; assertEquals(10, page.getPageSize());&gt; assertEquals(1, page.getStartRow());&gt; assertEquals(10, page.getEndRow());&gt; assertEquals(183, page.getTotal());&gt; assertEquals(19, page.getPages());&gt; assertEquals(1, page.getFirstPage());&gt; assertEquals(8, page.getLastPage());&gt; assertEquals(true, page.isFirstPage());&gt; assertEquals(false, page.isLastPage());&gt; assertEquals(false, page.isHasPreviousPage());&gt; assertEquals(true, page.isHasNextPage());&gt; 导航栏演示 12345678910111213141516171819202122232425262728293031323334&gt; &lt;div class="row"&gt;&gt; &lt;div class="col-md-6"&gt;当前是第$&#123;pageInfo.pageNum&#125;,页一共有$&#123;pageInfo.pages&#125;页,共有$&#123;pageInfo.total&#125;条数据&lt;/div&gt;&gt; &lt;div class="col-md-6"&gt;&gt; &lt;nav aria-label="Page navigation"&gt;&gt; &lt;ul class="pagination"&gt;&gt; &gt; &lt;c:if test="$&#123;pageInfo.pageNum!=1&#125;"&gt;&gt; &lt;li&gt;&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageInfo.prePage&#125;" aria-label="Previous"&gt;&gt; &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt;&gt; &lt;/a&gt;&gt; &lt;/li&gt;&gt; &lt;/c:if&gt;&gt; &gt; &lt;li class="$&#123;pageInfo.pageNum==1?"disabled":""&#125;"&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageInfo.firstPage&#125;"&gt;首页&lt;/a&gt;&lt;/li&gt;&gt; &gt; &lt;c:forEach items="$&#123;pageInfo.navigatepageNums&#125;" var="pageNum"&gt;&gt; &lt;li class="$&#123;pageInfo.pageNum==pageNum?"disabled":""&#125;"&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageNum&#125;"&gt;$&#123;pageNum&#125;&lt;/a&gt;&lt;/li&gt;&gt; &lt;/c:forEach&gt;&gt; &gt; &lt;li class="$&#123;pageInfo.pageNum==pageInfo.pages?"disabled":""&#125;"&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageInfo.lastPage&#125;"&gt;末页&lt;/a&gt;&lt;/li&gt;&gt; &gt; &lt;c:if test="$&#123;pageInfo.pageNum!=pageInfo.navigateLastPage&#125;"&gt;&gt; &lt;li&gt;&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageInfo.nextPage&#125;#" aria-label="Next"&gt;&gt; &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt;&gt; &lt;/a&gt;&gt; &lt;/li&gt;&gt; &lt;/c:if&gt;&gt; &lt;/ul&gt;&gt; &lt;/nav&gt;&gt; &lt;/div&gt;&gt; &lt;/div&gt;&gt; 参数介绍 3. 分页插件参数介绍分页插件提供了多个可选参数，这些参数使用时，按照上面两种配置方式中的示例配置即可。 分页插件可选参数如下： dialect：默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 下面几个参数都是针对默认 dialect 情况下的参数。使用自定义 dialect 实现时，下面的参数没有任何作用。 helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页。你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 重要提示： 当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 pageHelper属性1234567891011121314151617181920212223242526272829303132333435363738//当前页private int pageNum;//每页的数量private int pageSize;//当前页的数量private int size;//由于startRow 和endRow 不常用，这里说个具体的用法//可以在页面中"显示startRow 到endRow 共size 条数据"//当前页面第一个元素在数据库中的行号private int startRow;//当前页面最后一个元素在数据库中的行号private int endRow;//总记录数private long total;//总页数private int pages;//结果集private List&lt;T&gt; list;//前一页private int prePage;//下一页private int nextPage;//是否为第一页private boolean isFirstPage = false;//是否为最后一页private boolean isLastPage = false;//是否有前一页private boolean hasPreviousPage = false;//是否有下一页private boolean hasNextPage = false;//导航页码数private int navigatePages;//所有导航页号private int[] navigatepageNums;//导航条上的第一页private int navigateFirstPage;//导航条上的最后一页private int navigateLastPage;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>分页</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery入门教程]]></title>
    <url>%2F2019%2F10%2F17%2FjQuery%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[jQuery入门教程 jQuery就是一个js库，它极大地简化了js的编程，因此jQuery也很容易学习和使用。 入门演示这个隐藏了body标签下div这个长200px和宽200px粉色的盒子，并且打印一行话 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $("div").hide(); alert("asfda"); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery顶级对象$ $是jQuery的一个别称，在代码中可以使用$符号代替jQuery，通常目的都是为了简化操作。 $是jQuery的顶级对象，相当于原生javaScript中的window 演示1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $("div").hide(); alert("asfda"); &#125;); //下面的和上面的效果完全一致 jQuery(function()&#123; jQuery("div").hide(); alert("asfda"); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery对象和DOM对象 使用原生js获取的对象就是DOM对象 使用JQuery中的$获取的对象就是jQuery对象 他们之间可以相互转化，但是不相互转化之前不能使用对方的属性和方法 演示123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; //获取原生的DOM对象 console.dir(document.querySelector('div')); //获取jQuery对象 console.dir($('div')); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery和DOM对象相互转化DOM对象转化为JQuery对象 1$(&lt;DOM对象&gt;) jQuery对象转化DOM对象 12$(&lt;jQuer对象&gt;)[&lt;index&gt;]//下标访问的方式$(&lt;jQuer对象&gt;).get(&lt;index&gt;) 演示1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; //1.获取原生的DOM对象 var DOMClass=document.querySelector('div'); //转化jQuery对象 var parseJquery=$(DOMClass); //2.获取jQuery对象 var jQueryClass=$('div'); //转化为DOM对象,因为这个代码里面只有一个div所有通过下标访问0下标就可以得到 var parseDOM=jQueryClass[0]; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery选择器1.基础选择器 名称 用法 描述 ID选择器 $(“#id”) 获取指定的ID元素 全选选择器 $(“*”) 获取所有元素 类选择器 $(“.class”) 获取同一类class的元素 标签选择器 $(“div”) 获取同一标签的所有元素 并集选择器 $(“div,p,li”) 获取多个元素 交集选择器 $(“li,current”) 交集选择器 演示123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; //通过类选择器获取类为css的div盒子 console.dir($(".css")); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery隐式迭代 在jQuery中会对jQuery对象进行隐式迭代 也就是说jQuery会对获取到的所有对象迭代执行相同的操作，这样可以极大的简化我们编写的代码 演示12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;1&lt;/div&gt; &lt;div class="css"&gt;2&lt;/div&gt; &lt;div class="css"&gt;3&lt;/div&gt; &lt;div class="css"&gt;4&lt;/div&gt; &lt;script&gt; $(function()&#123; //利用jQuery的隐式迭代修改全部div的背景颜色 $('div').css("background-color","blue"); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery筛选选择器 可以在获取的jQuery对象伪数组中筛选 语法 用法 描述 :first $(“li:first”) 获取li后面第一个li元素 :last $(“li:last”) 获取li伪数组中的最后一个元素 :eq(&lt; index &gt;) $(“li:eq(2)”) 获取li伪数组中的2下标元素 :odd $(“li:odd”) 获取到li元素中,选择索引号为奇数的元素 :even $(“li:even”) 获取到li元素中,选择索引号为偶数的元素 演示修改指定位置div的颜色 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;1&lt;/div&gt; &lt;div class="css"&gt;2&lt;/div&gt; &lt;div class="css"&gt;3&lt;/div&gt; &lt;div class="css"&gt;4&lt;/div&gt; &lt;script&gt; $(function()&#123; //利用jQuery的隐式迭代修改全部div的背景颜色 $('div:eq(2)').css("background-color","blue"); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery筛选方法 语法 用法 说明 parent() $(“li”).parent() 查找li的父亲节点 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，最近一级的（亲儿子） find(selector) $(“ul”).find(“li”) 相当于$(“ul li”)，后代选择器 siblings(selector) $(“.first”).siblings(‘li’) 查找兄弟节点不包括本身 nextAll([expr]) $(“.first”).nextAll() 查找当前元素之后所有同辈元素 prevtAll([expr]) $(“.last”).prevAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(‘div’).hasClass（”protected”) 检查当前的元素是否有包含特定的类，如果有返回true eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”) 演示让2下标的div盒子后面的div盒子变色 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;1&lt;/div&gt; &lt;div class="css"&gt;2&lt;/div&gt; &lt;div class="css"&gt;3&lt;/div&gt; &lt;div class="css"&gt;4&lt;/div&gt; &lt;script&gt; $(function()&#123; //利用jQuery的隐式迭代修改全部div的背景颜色 $('div:eq(2)').nextAll().css("background-color","blue"); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery排他思想 所谓排他是想也就是实现多选一的效果，设置当前元素的样式，清除兄弟元素的样式 核心函数就是$(“button”).siblings(“button”); 演示点击按钮变色，其余按钮清除原来颜色 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;script&gt; $(function()&#123; //隐式迭代 $("button").click(function(event) &#123; //当前元素添加效果 $(this).css("background","blue"); //清除兄弟节点的效果 $(this).siblings('button').css("background",""); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery链式编程 实际上链式操作仅仅是通过对象上的方法最后 return this 把对象再返回回来，对象当然可以继续调用方法啦，所以就可以链式操作了 演示将上面那个按钮排他变色案例改编 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;script&gt; $(function()&#123; //隐式迭代 $("button").click(function(event) &#123; //链式编程 $(this).css("background","blue").siblings('button').css("background",""); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>jQuery</tag>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis逆向工程--MybatisGenerator]]></title>
    <url>%2F2019%2F10%2F14%2FMybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-MybatisGenerator%2F</url>
    <content type="text"><![CDATA[Mybatis逆向工程 mybatis需要手动编写mapper和接口，以及pojo对象，这对于一个大型工程来说特别消耗时间，所有也就有了自动生成的工具就是MybatisGenerator 使用步骤1.导入maven坐标 12345 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt; 2.配置Generator配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt;&lt;!-- 配置数据库连接--&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/ssm" userId="root" password="111"&gt; &lt;/jdbcConnection&gt;&lt;!-- java类型解析不需要动--&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt;&lt;!-- 指定javabean生成位置--&gt; &lt;javaModelGenerator targetPackage="com.qs304.entity" targetProject=".\src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt;&lt;!-- 映射文件生成位置--&gt; &lt;sqlMapGenerator targetPackage="config.mapper" targetProject=".\src\resource"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt;&lt;!-- 指定dao接口生成位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.qs304.dao" targetProject=".\src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt;&lt;!-- 指定每个表的生成策略--&gt; &lt;table tableName="tbl_emp" domainObjectName="Emplovee"/&gt; &lt;table tableName="tbl_dept" domainObjectName="Department"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3.然后新建一个java文件读取配置文件开始自动生成pojo对象和接口文件和mybatis配置文件 123456789101112131415161718192021222324252627import org.junit.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class Generator &#123; @Test public void mybatisGenerator() throws InterruptedException, SQLException, IOException, XMLParserException, InvalidConfigurationException &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("D:\\code\\SSMCRUD\\src\\test\\mybatisGenerator.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[快速搭建java项目配置文件模板]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[web.xml(包含Spring和SpringMVC)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;!-- 中文乱码处理 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring配置文件信息 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- ContextLoaderListener监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 日志配置 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/springmvc/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/errors/404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/errors/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; applicationContext.xml(含C3P0配置和mybatis配置文件整合)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;!-- 配置扫描范围--&gt; &lt;context:component-scan base-package="com.qs304"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Component"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; &lt;/context:component-scan&gt;&lt;!--加载数据源配置文件--&gt; &lt;context:property-placeholder location="classpath:config/db.properties"/&gt;&lt;!-- 配置C3P0数据源--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close" &gt; &lt;property name="driverClass" value="$&#123;jdbc.driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 扫描 po 包，使用别名 --&gt; &lt;property name="typeAliases" value="com.qs304.entity"&gt;&lt;/property&gt; &lt;!-- 扫描映射文件 --&gt; &lt;property name="mapperLocations" value="classpath:config/mapper/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置扫描 dao 包，动态实现 dao 接口，注入到 spring 容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.ischoolbar.programmer.dao" /&gt; &lt;/bean&gt; &lt;!-- 事务管理器 （JDBC） --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;aop:config&gt;&lt;!-- 切入点表达式--&gt; &lt;aop:pointcut id="txPointcut" expression="execution(* com.qs304.servlet..*(..))"/&gt;&lt;!-- 配置事务增强--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/&gt; &lt;/aop:config&gt;&lt;!-- 配置事务增强事务如何切入--&gt; &lt;tx:advice id="txAdvice"&gt; &lt;tx:attributes&gt;&lt;!-- 所有的方法都是事务方法--&gt; &lt;tx:method name="*"/&gt;&lt;!-- get开头的方法认为是查询进行调优--&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 启动声明式事务驱动 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; springmvc.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd"&gt; &lt;!-- 只需要扫描包中的 Controller 注解 --&gt; &lt;context:component-scan base-package="com.ischoolbar.programmer.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- 启动 mvc 注解驱动 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 启动定时任务 --&gt; &lt;task:annotation-driven/&gt; &lt;!-- 静态资源处理 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 上传文件大小限制 --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;10485760&lt;/value&gt; &lt;/property&gt; &lt;!-- 请求的编码格式, 和 jsp 页面一致 --&gt; &lt;property name="defaultEncoding"&gt; &lt;value&gt;UTF-8&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 后台访问拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;!--&lt;mvc:mapping path="/grade/*"/&gt;--&gt; &lt;mvc:exclude-mapping path="/system/login"/&gt; &lt;mvc:exclude-mapping path="/system/get_cpacha"/&gt; &lt;mvc:exclude-mapping path="/h-ui/**"/&gt; &lt;mvc:exclude-mapping path="/easyui/**"/&gt; &lt;mvc:exclude-mapping path="/home-resources/**"/&gt; &lt;mvc:exclude-mapping path="/home/**"/&gt; &lt;bean class="com.ischoolbar.programmer.interceptor.LoginInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;/beans&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>Spring</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
        <tag>习惯</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合教程和步骤]]></title>
    <url>%2F2019%2F10%2F02%2FSSM%E6%95%B4%E5%90%88%E6%95%99%E7%A8%8B%E5%92%8C%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[SSM整合教程和步骤步骤1.配置spring和springmvc以及mybatis配置文件 2.配置web.xml文件先整合spring与springmvc 3.测试spring与springmvc整合情况 4.整合spring与springmvc与mybatis 教程1.配置spring和springmvc以及mybatis配置文件spring.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--开启注解扫描但是不扫描Controller注解包含的类--&gt; &lt;context:component-scan base-package="com.qs304"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; springmvc.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--开启注解扫描但是只扫描Controller注解包含的类--&gt; &lt;context:component-scan base-package="com.qs304.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!--因为一会要使用注解，所有开启注解扫描,注解只扫描Controller--&gt; &lt;!--配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.配置web.xml文件先整合spring与springmvc web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--配置监听器加载spring框架--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置springxml文档路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器映射拦截说有路径下 &lt;url-pattern&gt;/&lt;url-pattern/&gt;匹配类似于/xxxx的URL，不会匹配到/xxx.xxx类型的URL&lt;url-pattern&gt;/*&lt;url-pattern/&gt;会匹配所有类型、所有后缀的URL，包括：/xxx、/xxx.xxx --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.测试springmvc与spring整合情况4.整合spring与springmvc与mybatis首先单独写mybatis配置文件，例如名字叫做mybatis.xml mybatis.xml 然后测试mybatis能运行 之后吧mybatis配置文件整合到spring.xml配置文件中 spring.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.qs304"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!-- Spring整合mybatis框架--&gt;&lt;!-- 配置连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/demo"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="111"/&gt; &lt;/bean&gt;&lt;!-- 工厂注入来配置sqlsession--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt;&lt;!-- 配置接口所在的包--&gt; &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.qs304.dao"/&gt; &lt;/bean&gt;&lt;/beans&gt; 之后就运行成功啦，完结散花、]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis深入理解XML配置文件]]></title>
    <url>%2F2019%2F09%2F28%2FMybatis%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Mybatis体系结构SqlSessionFactory​ SqlSessionFactory是mybatis的关键对象，它是单个数据库映射关系经过编译后的内存镜像，SqlSessionFactor对象通过SqlSessionFactorBuilder对象创建获得。 SqlSessionFactorBuilder​ SqlSessionFactorBuilder可以从XML配置文件或者一个预先定制的Configguration的实例为核心构建，它是线程安全的。 SqlSession​ SqlSession也是mybatis的关键对象，它是执行持久化操作的对象，类似JDBC中的Connection对象，它是应用程序与持久化层之间执行交互操作的一个单线程对象， 每个线程都应该有他自己的SqlSession实例，SqlSession的实例不能共享，也是线程不安全的，所有绝对不能将SqlSession实例的引用放在一个类的静态字段中，也绝对不能放在任何类型的管理范围中，比如Serlvet中的HTTPSession对象中。 Mybatis的配置文件结构 configuration配置 propertes 属性 typeAliases 类型命名（别名） typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transationManager 事务管理器 dataSource 数据源 databaseIDProvider 数据库厂商标识 mapping 映射器 propertes 这些属性都是外部配置然后可以动态替换的演示:​ 在类路径下新建一个db.properties的java配置文件 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisusername=adminpassword=123456 然后在Mybatis主配置文件中添加元素 1&lt;properties resource="db.properties"/&gt; 之后就可以使用EL表达式获取对应的值 123456&lt;dataSoure type="POOLED"&gt; &lt;property name="driver" value="$&#123;dirver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt;&lt;/dataSoure&gt; settings设置这是Mybatis中非常重要的调整设置，他会改变Mybatis的运行时行为 配置参考 1234567891011121314151617&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="30"/&gt; &lt;setting name="defaultFetchSize" value="200"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt; typeAliases类型命名​ 类型别名时为java类型设置的一个短名字，存在的意义在于减少冗余的全限定类名 方法一1234&lt;!--这样配置后任何使用到com.qs304.beans.User的地方都能使用user代替--&gt;&lt;typeAliases&gt; &lt;typeAlias alias="user" type="com.qs304.beans.User"&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; 方法二1234&lt;!--别名默认为类名首字母小写，指定这个包名后，mybatis会在下面的包中搜索--&gt;&lt;typeAliases&gt; &lt;pakage name="com.qs304.bean"/&gt;&lt;/typeAliases&gt; 若使用了注解这别名为注解的值，没有使用就是类名首字母小写 Mybatis已经为许多常见的java类型内建了相应的类型别名他们都是大小写不敏感的 参考：https://blog.csdn.net/lyf_ldh/article/details/77949004 mapper映射器Mybatis需要开发者告诉它去哪寻找映射文件这也就有了mapper 12345678910&lt;mappers&gt; &lt;!--使用类路径查找资源文件--&gt; &lt;mapper resource="com/qs304/dao/IStudent.xml"/&gt; &lt;!--使用绝对路径查找--&gt; &lt;mapper url="file:///C:/IStudent.xml"/&gt; &lt;!--使用接口查找--&gt; &lt;mapper class="com.qs304.dao.IStudent"/&gt; &lt;!--使用包名查找--&gt; &lt;package name="com.qs304.dao"/&gt;&lt;/mappers&gt; 深入理解Mapper XML映射文件SQL映射文件常用的元素 select 映射查询语句 insert 映射插入语句 update 映射删除语句 sql 可被其他语句引用的可重用语句块 cahe 给定命名空间的缓存配置 cache-ref 给其他命名空间缓存配置引用 resultMap 最复杂也是最强大的元素，用来描述如何从数据库结果集中加载对象 &lt;select&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;select &lt;!-- 1. id（必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句 一个命名空间（namespace）对应一个dao接口 这个id也应该对应dao里面的某个方法（sql相当于方法的实现），因此id应该与方法名一致 --&gt; id="selectUser" &lt;!-- 2. parapeterType（可选配置，默认由mybatis自动选择处理） 将要传入语句的参数的完全限定名或别名，如果不配置，mybatis会通过ParamterHandler根据参数类型默认选择合适的typeHandler进行处理 paramterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --&gt; parapeterType="int" &lt;!-- 3. resultType（resultType 与 resultMap 二选一配置） 用来指定返回类型，指定的类型可以是基本类型，也可以是java容器，也可以是javabean --&gt; resultType="hashmap" &lt;!-- 4. resultMap（resultType 与 resultMap 二选一配置） 用于引用我们通过 resultMap 标签定义的映射类型，这也是mybatis组件高级复杂映射的关键 --&gt; resultMap="USER_RESULT_MAP" &lt;!-- 5. flushCache（可选配置） 将其设置为true，任何时候语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false --&gt; flushCache="false" &lt;!-- 6. useCache（可选配置） 将其设置为true，会导致本条语句的结果被二级缓存，默认值：对select元素为true --&gt; useCache="true" &lt;!-- 7. timeout（可选配置） 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数，默认值为：unset（依赖驱动） --&gt; timeout="10000" &lt;!-- 8. fetchSize（可选配置） 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为：unset（依赖驱动） --&gt; fetchSize="256" &lt;!-- 9. statementType（可选配置） STATEMENT, PREPARED或CALLABLE的一种，这会让MyBatis使用选择Statement, PrearedStatement或CallableStatement，默认值：PREPARED --&gt; statementType="PREPARED" &lt;!-- 10. resultSetType（可选配置） FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为：unset（依赖驱动） --&gt; resultSetType="FORWORD_ONLY"&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对多和多对一以及多对多]]></title>
    <url>%2F2019%2F09%2F28%2FMybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E4%BB%A5%E5%8F%8A%E5%A4%9A%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[ORM和MybatisORM​ ORM 全称为:object/relation mapping（对象\关系数据库映射），简单来说就是一种规范，它的出现就是为了解决面向对象编程语言与关系数据库发展不均衡的产物，允许开发者利用面向对象语言的简单易用性又能利用关系数据库的技术优势，于是把关系数据库包装成面向对象模型，这个工具就是ORM。 基本映射方式数据表映射类​ 持久化类被映射到一个数据表，即一个表对应一个Model类 数据表的行映射（即实例）​ 数据表的每行映射一个对象 数据库表列（字段）映射对象的属性​ 数据库表的每列映射一个对象 一对多和多对一查询一个班有多个学生，一个学生一个班 班级表12345CREATE TABLE `class` ( `id` int(11) NOT NULL AUTO_INCREMENT, `class_name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4; 学生表12345678CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `class_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `class_id` (`class_id`), CONSTRAINT `class_id` FOREIGN KEY (`class_id`) REFERENCES `class` (`id`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4; 首先导入pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qs304&lt;/groupId&gt; &lt;artifactId&gt;MybatisQuery&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; pojo对象班级12345678910111213141516171819202122232425262728293031323334353637383940414243package com.qs304.beans;import java.io.Serializable;import java.util.List;public class Clazz implements Serializable &#123; private Integer id; private String className; private List&lt;Student&gt; students; @Override public String toString() &#123; return "Clazz&#123;" + "id=" + id + ", className='" + className + '\'' + ", students=" + students + '&#125;'; &#125; public List&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(List&lt;Student&gt; students) &#123; this.students = students; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getClassName() &#123; return className; &#125; public void setClassName(String className) &#123; this.className = className; &#125;&#125; 学生123456789101112131415161718192021222324252627282930313233343536373839404142package com.qs304.beans;import java.io.Serializable;public class Student implements Serializable &#123; private Integer id; private String name; private Clazz clazz; public Clazz getClazz() &#123; return clazz; &#125; public void setClazz(Clazz clazz) &#123; this.clazz = clazz; &#125; @Override public String toString() &#123; return "Student&#123;" + "id=" + id + ", name='" + name + '\'' + ", clazz=" + clazz + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125;&#125; utils包123456789101112131415package com.qs304.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class SqlFactory &#123; public static SqlSessionFactory getSqlFactory() throws IOException &#123; InputStream in=Resources.getResourceAsStream("mybatisConfig.xml"); return new SqlSessionFactoryBuilder().build(in); &#125;&#125; dao包123456789101112131415161718192021222324package com.qs304.dao;import com.qs304.beans.Clazz;import com.qs304.beans.Student;import java.util.List;public interface ImplDao &#123; /** * 一对多查询 * 根据班级id获取班级所有的学生以及班级信息 * @param id 班级id * @return Clazz 班级对象 */ public Clazz findClazzById(int id); /** * 多对一查询 * 根据学生id获取对应学生所在班级以及个人信息 * @param id 学生id * @return Student 学生对象 */ public Student findStudentById(int id);&#125; dao包xml文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qs304.dao.ImplDao"&gt; &lt;!--一对多映射配置--&gt; &lt;resultMap id="clazzStudentMap" type="com.qs304.beans.Clazz"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="className" column="class_name"&gt;&lt;/result&gt; &lt;collection property="students" ofType="student" &gt; &lt;id property="id" column="sid"&gt;&lt;/id&gt; &lt;result property="name" column="name"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;resultMap id="studentClazzMap" type="com.qs304.beans.Student"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="name" column="name"&gt;&lt;/result&gt; &lt;association property="clazz" column="class_id"&gt; &lt;id property="id" column="sid"&gt;&lt;/id&gt; &lt;result property="className" column="class_name"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findClazzById" parameterType="int" resultMap="clazzStudentMap"&gt; select class.*, student.id as sid,student.name from class left outer join student on class.id=student.class_id where class.id=#&#123;id&#125;; &lt;/select&gt; &lt;select id="findStudentById" parameterType="int" resultMap="studentClazzMap"&gt; select student.*,class.id as sid,class.class_name from student,class where class.id=student.class_id and student.id=#&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; resourcesdb.properties1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/testusername=rootpassword=111 mybatisConfig.xml文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="db.properties"/&gt; &lt;typeAliases&gt; &lt;package name="com.qs304.beans"/&gt; &lt;/typeAliases&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name="com.qs304.dao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; lof4j配置文件log4j.properties 1234567891011121314log4j.rootLogger = WARN,stdoutlog4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%p][%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l] %m%nlog4j.appender.D = org.apache.log4j.RollingFileAppenderlog4j.appender.D.File = log/Wifi_sy/Wifi_sy_warn.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = WARN log4j.appender.D.MaxFileSize = 10240KBlog4j.appender.D.MaxBackupIndex = 3 log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c:%L:[%p]] %m%n 测试类123456789101112131415161718192021222324252627282930313233343536373839404142import com.qs304.beans.Clazz;import com.qs304.beans.Student;import com.qs304.dao.ImplDao;import com.qs304.utils.SqlFactory;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.logging.Logger;public class test &#123; SqlSession sqlSession=null; SqlSessionFactory sqlSessionFactory=null; @Before public void befor() throws IOException &#123; sqlSessionFactory= SqlFactory.getSqlFactory(); sqlSession=sqlSessionFactory.openSession(); &#125; @Test public void test()&#123; ImplDao dao=sqlSession.getMapper(ImplDao.class); Clazz clazz=dao.findClazzById(1); System.out.printf(clazz.toString()); &#125; @Test public void test1()&#123; ImplDao dao=sqlSession.getMapper(ImplDao.class); Student student=dao.findStudentById(1); System.out.printf(student.toString()); &#125; @After public void after()&#123; sqlSession.commit(); sqlSession.close(); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis第二天（连接池，动态SQL语句）]]></title>
    <url>%2F2019%2F09%2F16%2Fmybatis%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%88%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mybatis连接池连接池数据源分类 UNPOOLED 不使用连接池的数据源 POOLED 使用传统的javax.sql.DataSource连接池的数据源 JNDI 使用JNDI实现的数据源 mybatis动态SQL语句作用：为了解决手动拼接SQL的麻烦元素:（注意由于markedown语法问题标签有空格） 标签名 说明 &lt; if &gt; 判断语句，用于但条件分支判断 &lt; choose &gt;(&lt; when &gt;,&lt; otherwise &gt;) 相当于switch语句，用于多条件分支判断 &lt; where &gt;,&lt; trim &gt;,&lt; set &gt; 辅助元素，用于处理一些SQL拼接，特殊字符问题 &lt; bind &gt; 从OGNL表达式中创建一个变量，并将其绑定到上下文，常用于模糊查询的Sql语句 代码演示：​ 假设有下面这个类 123456public class Person&#123; private Integer id; private String name; private Integer age; ...//以下的get和set方法以及toString方法省略&#125; &lt;if&gt;标签123456789101112131415161718192021&lt;select id="findPersonByidAndname" parameterType="com.qs304.domain.Person" resultType="com.qs304.domain.Person"&gt; select * from persons where 1=1 &lt;if test="id != null"&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test="name"&gt; and name = #&#123;name&#125; &lt;/if&gt;&lt;/select&gt;&lt;!--如果使用了where标签就可以不写where 1=1和and之类的--&gt;&lt;select id="findPersonByidAndname" parameterType="com.qs304.domain.Person" resultType="com.qs304.domain.Person"&gt; select * from persons &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test="name"&gt; name = #&#123;name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &lt;foreach&gt; 元素1234567891011121314&lt;!-- 判断id是否在这个集合里面 select * from pesrsons where id in(1,2,3,4); 类似这样--&gt;&lt;select id="findPersonByIds" parameterType="List" resultType="com.qs304.domain.Person"&gt; select * from pesrsons where id in &lt;!-- 判断为空可以用 list.size&gt;0--&gt; &lt;foreach item="id" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; item：配置的是循环中当前的元素。 index：配置的是当前元素在集合的位置下标。 collection：配置的list是传递过来的参数类型（首字母小写），它可以是一个array、list（或collection）、Map集合的键、POJO包装类中数组或集合类型的属性名等。 open和close：配置的是以什么符号将这些集合元素包装起来。 separator：配置的是各个元素的间隔符。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis入门教程]]></title>
    <url>%2F2019%2F08%2F30%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis1.Mybatis简介:​ ​ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。 持久层： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。 优点： 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价 缺点：慢（相对于内存而言） 2.为什么要使用mybatis​ 在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 3.mybatisDemomybatis的环境搭建​ 第一步：创建maven工程并导入坐标 ​ 第二步：创建实体类和dao接口（mybatis可以只有接口就能实现对数据库的增删改查，而且实体类就是要实体类的属性和数据库的表对应起来） ​ 第三步：创建mybatis的主配置文件 SqlMapConfig.xml（名字可以随意） ​ 第四步：创建映射配置文件 IUserDao.xml（名字可以随意） ​ 搭建注意事项: ​ 第一个:创建IUserDao.xml和IUserDao.java 在mybatis中 他把持久层的操作接口名称和映射文件叫做:Mapper ​ 第二个：在idea中创建目录的时候，他和包是不一样的， ​ 第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同 ​ 第四个：映射配置文件的操作配置（select）,id属性的取值必须是dao接口的方法名 ​ 第五个：映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定类名 maven坐标 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 首先Bean包Account.java 12345678910111213141516171819202122232425262728293031323334353637383940package cn.Bean;public class Account &#123; private Integer id; private String name; private Double money; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125; 然后dao包下的IDao.java接口 123456789101112package cn.dao;import cn.Bean.Account;import java.util.List;/** * 获取所有的Account信息 */public interface IDao &#123; public List&lt;Account&gt; getAccountAll();&#125; 然后创建主配置文件MybatisConfig.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt;&lt;!--defult填写的子类必须也有--&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置连接数据库--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--配置映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="cn/config/IDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 然后穿件cn目录下config目录下的IDao.xml映射IDao.java的配置文件，注意xml文件和java文件必须是统一限定目录 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace填写IDao接口的全限定类名--&gt;&lt;mapper namespace="cn.dao.IDao"&gt; &lt;!--配置查询所有 id必须是IDao方法的名称,resultType必须是实体类 --&gt; &lt;select id="getAccountAll" resultType="cn.Bean.Account"&gt; select * from account; &lt;/select&gt;&lt;/mapper&gt; 最后是测试类 12345678910111213141516171819202122232425262728293031import cn.Bean.Account;import cn.dao.IDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123; @org.junit.Test public void getALl() throws IOException &#123; //1.读取配置文件 InputStream in= Resources.getResourceAsStream("MybatisConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IDao dao=session.getMapper(IDao.class); //5.使用代理对象执行方法 List&lt;Account&gt; users=dao.getAccountAll(); for (Account user : users) &#123; System.out.println(user); &#125; &#125;&#125; 打印信息为 123456Sat Jul 27 15:54:14 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.Account&#123;id=1, name='aaa', money=600.0&#125;Account&#123;id=2, name='bbb', money=1200.0&#125;Account&#123;id=3, name='ccc', money=1000.0&#125;Account&#123;id=4, name='hhh', money=1000.0&#125;Account&#123;id=5, name='hhh', money=200.0&#125; 如果需要保存数据则把IDao.xml改成以下 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace填写IDao接口的全限定类名--&gt;&lt;mapper namespace="cn.dao.IDao"&gt; &lt;!--配置查询所有 id必须是IDao方法的名称,resultType必须是实体类--&gt; &lt;select id="getAccountAll" resultType="cn.Bean.Account"&gt; select * from account; &lt;/select&gt; &lt;!--通过里面配置selectKey标签的方式可以获取插入数据后所对应的自增长id的值--&gt; &lt;select id="addAccount" parameterType="cn.Bean.Account"&gt; &lt;!--selectKey 会将 SELECT LAST_INSERT_ID()的结果放入到传入的model的主键里面， keyProperty 对应的model中的主键的属性名，这里是 user 中的id，因为它跟数据库的主键对应 order AFTER 表示 SELECT LAST_INSERT_ID() 在insert执行之后执行,多用与自增主键， BEFORE 表示 SELECT LAST_INSERT_ID() 在insert执行之前执行，这样的话就拿不到主键了， 这种适合那种主键不是自增的类型 resultType 主键类型 --&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt;&lt;/selectKey&gt; insert INTO account(name,money) values(#&#123;name&#125;,#&#123;money&#125;) &lt;/select&gt;&lt;/mapper&gt; 值得一提的是：resultType属性可以类型有简单类型或者pojo对象，或者pojo对象的包装对象（pojo对象的列表）。pojo对象就是javabean或者说是实体类对象 ​ 然后上述xml文件配置中就是用了OGNL表达式 OGNL表达式中省略的get关键字，即user.getName()变成了user.name; 在mybatis中标签属性resultType中提供了user对象的包名，所以可以直接使用name来达到user.name相同的效果 测试类里面： 1234567891011121314151617181920212223242526272829303132333435363738import cn.Bean.Account;import cn.dao.IDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123; @org.junit.Test public void getALl() throws IOException &#123; //1.读取配置文件 InputStream in= Resources.getResourceAsStream("MybatisConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IDao dao=session.getMapper(IDao.class); //5.使用代理对象执行方法 Account ac=new Account(); ac.setName("hha"); ac.setMoney(99999.0); dao.addAccount(ac); List&lt;Account&gt; users=dao.getAccountAll(); for (Account user : users) &#123; System.out.println(user); &#125; //如果没有正确提交到数据库需要手动提交事务 //session.commit(); &#125;&#125; 注解配置​ 首先可以把IDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句，同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名 实体类对象的属性名称与mysql数据库里面的列名不同解决方案：原因：​ mysql数据库里面的列不能和实体类对象的属性进行对应，说以要解决这个问题必须从解决对应关系下手 使用mysql的别名进行对应 使用mybatis里面的resultMap标签进行对应匹配（然后标签里面的resultType属性换成resultMap属性来使用配置的resultMap标签里面的内容）]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键操作]]></title>
    <url>%2F2019%2F06%2F27%2FIDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[IDEA 快捷键操作1.搜索跳转 作用 快捷键 备注 多个窗口之间跳转 ctrl+alt+[或者] [跳转到上一个窗口,]跳转到下一个窗口 导航栏跳转 alt+数字键 侧边栏上面标注数字 万能搜索键 按两次shift键 可以打开万能的搜索窗口 跳转到上次编辑的地方 ctrl+shift+backspace 可以定位到上次编辑的地方 跳转到上次浏览的地方 ctrl+alt+左箭头 跳转到上次浏览的地方 跳转到上次浏览的地方返回 ctrl+alt+右箭头 跳转到上次浏览的地方返回 打开最近文件浏览列表 ctrl+E 方便快速的多文件跳转 文件标签 ctrl+F11 给文件添加标签 文件标签跳转 ctrl+标签名称 方便阅读别源代码 添加到喜爱代码库 alt+shift+f 放到类上面添加类到列表里面，放到方法上面添加方法到列表里面 搜索字符串 ctrl+shift+f 搜素所有的字符串 2.代码小助手注意定义 live Template动态模板还有postfix点模板 对选中的大小写进行转换 ctrl+shift+u 对选中的大小写进行转换 选中当前选中的元素进行多行处理 ctrl+shift+alt+j 选中当前选中的元素进行多行处理 格式化代码 ctrl+alt+L 格式化代码 重构变量 shift+f6 重构变量 重构方法 ctrl+f6 重构方法 抽取变量 ctrl+alt+v 抽取变量 将选中的代码块抽取成为函数 ctrl+alt+m 将选中的代码块抽取成为函数 查看选中的类或者接口的继承关系 Ctrl+shift+u 查看选中的类或者接口的继承关系]]></content>
      <categories>
        <category>学习</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>IDEA</tag>
        <tag>IDE</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法树状数组]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%AE%97%E6%B3%95%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[算法:树状数组1.适用场景​ 可以解决大部分基于区间上的更新以及求和问题 2.介绍1.单点查询 我们先从数组讲起(这个就不需要普及了吧)； A数组是我们传入数据的数组 C数组使我们建立起来的树状数组 然后就能显而易见的发现一个规律 12345678C1 = A1C2 = A1+A2C3 = A3C4 = A1+A2+A3+A4C5 = A5C6 = A5+A6C7 = A7C8 = A1+A2+A3+A4+A5+A6+A7+A8 接下来我们引入lowbit这个概念：(这个地方有一点需要注意：lowbit(0)会陷入死循环 ) 1234inline int lowbit(int x)&#123; return x &amp; (-x);&#125; 这返回的是这个数字最高位的1; 在这之前，又要引入一个补码的概念： 补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 请注意，这里的第一位是指的是符号位，而不是数字位(这是1，因此数字位只有1) 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 因此，&amp;是求与的一个符号，意思是 a 和 b 同时为 1 的时候返回这个最高位(不包括符号位) 在刚刚的找规律过程中，我们通过规律总结出了以下性质(lowbit是为了帮助程序代码的实现) 我们可以得到树状数组的一些性质：对于c[i]，他的儿子节点取决于i的所有因子中最多有2^j次幂，则向前取2^j个数作为儿子，即[i-2^j+1,i]。(这个时候就需要lowbit来帮助实现) 举一个栗子： 6的最大2次方因子为2，即2^1，则向前取2个数，则c[6]=a[5]+a[6]； 8的最大2次方因子为8，即2^3，则向前取8个数，则c[8]=a[1]+a[2]+…+a[8]。 2.单点修改 当我们要对最底层的值进行更新时，那么它相应的父亲节点存储的和也需要进行更新， 我们建立的树状数组结构是一个完整的结构，因此修改一个点也会需要所有相应的其父亲节点的点来修改，这样我们就实现了树状数组的修改。 代码如下： 12345678910void modify(int x,int k) //将 x 增加 k&#123; if(x &lt; 1) return ; while(x &lt;= n) &#123; c[i] += k; x += lowbit(x); //去寻找它的父亲 &#125; &#125; 3.单点查询 单点查询由于我们向前统计，因此需要向前查找，这个就不需要讲了吧(没弄明白请看上面) 1234567891011121314int query(int pos)&#123; int sum=0; for(int i=pos;i;i-=lowbit(i)) sum += c[pos]; /*两种写法 while(pos &gt; 0) &#123; sum += c[pos]; pos -= lowbit(pos); &#125; */ return sum;&#125; 1234567891011121314151617181920212223//这是完整的操作void change(int p, int x)&#123; //给位置p增加x while(p &lt;= n) &#123; sum[p] += x; p += p &amp; -p; &#125;&#125;int ask(int p)&#123; //求位置p的前缀和 int res = 0; while(p) &#123; res += sum[p]; p -= p &amp; -p; &#125; return res;&#125;int query(int l, int r)&#123; //区间求和 return ask(r) - ask(l - 1);&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架教程]]></title>
    <url>%2F2019%2F03%2F10%2FSpringMVC%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SpringMVC框架教程前言为开发团队选择一款优秀的MVC框架是件难事儿，在众多可行的方案中决择需要很高的经验和水平。你的一个决定会影响团队未来的几年。要考虑方面太多： 1、简单易用，以提高开发效率。使小部分的精力在框架上，大部分的精力放在业务上。 2、性能优秀，这是一个最能吸引眼球的话题。 3、尽量使用大众的框架（避免使用小众的、私有的框架），新招聘来的开发人员有一些这方面技术积累，减低人员流动再适应的影响。 简介​ pring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架或集成其他MVC开发框架，如Struts]1(现在一般不用)，Struts 2(一般老项目使用)等。 SpringMVC框架优势1.清晰的角色划分：控制器(controller)、验证器(validator)、命令对象(command obect)、表单对象(form object)、模型对象(model object)、Servlet分发器(DispatcherServlet)、处理器映射(handler mapping)、试图解析器(view resoler)等等。每一个角色都可以由一个专门的对象来实现。 2.强大而直接的配置方式：将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在web控制器中对业务对象和验证器validator)的引用。 3.可适配、非侵入：可以根据不同的应用场景，选择何事的控制器子类(simple型、command型、from型、wizard型、multi-action型或者自定义)，而不是一个单一控制器(比如Action/ActionForm)继承。 4.可重用的业务代码：可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类。 5.可定制的绑定(binding)和验证(validation)：比如将类型不匹配作为应用级的验证错误，这可以保证错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象，需要手动解析它并转换到业务对象。 6.可定制的handler mapping和view resolution：Spring提供从最简单的URL映射，到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活。 7.灵活的model转换：在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成。 8.可定制的本地化和主题(theme)解析：支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity(不需要额外的中间层)等等。 9.简单而强大的JSP标签库(Spring Tag Library)：支持包括诸如数据绑定和主题(theme)之类的许多功能。他提供在标记方面的最大灵活性。 10.JSP表单标签库：在Spring2.0中引入的表单标签库，使用在JSP编写表单更加容易。 11.Spring Bean的生命周期：可以被限制在当前的HTTp Request或者HTTp Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。 SpringMVC与Struts2框架的对比拦截机制1、Struts2 a、Struts2框架是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype（否则会出现线程并发问题），然后通过setter，getter吧request数据注入到属性。b、Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。c、Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了2、SpringMVCa、SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。b、在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。 性能方面 SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。 四、拦截机制Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 配置方面spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。SpringMVC可以认为已经100%零配置。 设计思想Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。 集成方面SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 注解详解RequestMapping介绍你可以使用@RequestMapping来映射URL，比如/test到某个Controller类，或者是某个具体的方法。通常类上的注解@RequestMapping用来标记请求的路径，方法上的@RequestMapping注解的作用将是映射到特定的URL到某个具体的处理方法。 作用被添加注解的方法参数就是发起请求的参数，返回值就是通过跳转的页面名字 参数： value,请求的URL路径，支持URL模板，正则表达式。这也是我们最常用的一种映射方 method(多个)，指定接收请求的方法，有GET,POST,PUT等，RequestMethod枚举类，如果没有按规则会抛405 Method Not Allowed params(多个) 指定请求的参数，例如parame=”user” ，那么请求中必须携带user参数的key，如果是parame=”user=123” ，那么参数就key必须是user,value必须是123,否则不能正常执行而且抛出400 错误的请求 headers(多个) 指定请求的头 consumes,允许的媒体类型Media Types ），如consumes ＝ ”application/ison ”， 对应于请求的HTTP 的Content-Type 。 @RequestParam作用：在SpringMVC中如果方法上被添加了·RequestMappring注解且方法有参数，那么必须传入与方法参数同名的的参数名，当使用了这个就可以实现传入产生非同名范围:参数内示例 123456789@RequestMapping("/list")/***传入的参数必须与user同名，而非必须和username同名*/public String test(@RequestParam("user") String username )&#123; return null;&#125; @RequestBady作用：获取请求体的内容，其格式是key:value的格式，其中get请求不适用（get请求没有请求体，它把的参数在url中）,该注解经常使用在异步的方式中范围：参数内注意:方法的名字不能与请求的任何参数同名，因为在Springmvc框架中，任何同名的都被看成同名封装.示例 12345678@RequestMapping("/list")/***注意，方法的名字不能与请求的任何参数同名，因为在Springmvc框架中，任何同名的都被看成同名封装，*/public String test(@RequestBady String bady)&#123; System.out.println(bady);//打印结果将会是key：value的形式 return null;&#125; @PathVariable(REST编程风格)作用: 带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 主要是根据请求方法进行类的区别 范围：参数内 示例: 123456789/***通过使用PathVariable注解实现占位符上数据的获取*参数发送格式应该是请求的url例如xxx/list/12*/@RequestMapping("/list/&#123;sid&#125;")public String test(@PathVariable(name="sid") String id)&#123; System.out.println(id);//结果因该为12 return null;&#125; @ModelAttribute作用： ​ 来处理传入的参数少的问题 ​ 添加在方法上面时候，该方法会优先执行 ​ 添加在参数上面的时候，需要一个map集合来处理传入的参数少的问题 范围：方法上和参数上 示例： 假设有个user的javaBean对象 ​ 第一种，注解添加在方法上 123456789@RequestMapping("/list/modelAttribute")public String test(User user)&#123; System.out.println(user); return null;&#125;@ModelAttributepublic User modelAttribute(User user)&#123;//返回值必须三user类型才能保证接下来的方法接收到参数,参数时user类本方法才能获取到传入的参数 System.out.println("先执行,同时可以做一些其他操作，比如补全user对象不全的信息");&#125; 第二种,注解添加在参数内 123456789@RequestMapping("/list/modelAttribute")public String test(@ModelAttribute("abc") User user)&#123;//获取abc的对象存入user System.out.println(user); return null;&#125;public void modelAttribute(User user,Map&lt;String,User&gt; map)&#123;//返回值就不是必须的，但是参数必须有个map，,map&lt;String,User&gt; System.out.println("先执行,同时可以做一些其他操作，比如补全user对象不全的信息"); map.put("abc",user);//进行一些操作&#125; SessionAttributes作用:​ 向Session对象存入值，于在多个请求之间传递参数，类似于Session的Attribute，但不完全一样，一般来说@SessionAttributes设置的参数只用于暂时的传递，而不是长期的保存，长期保存的数据还是要放到Session中。（向Requests域存入对象需要使用Model接口的实现类） 范围：类spring 请求参数绑定绑定简述​ 在SpringMVC中，被添加@RequestMapping的方法的参数就是请求的参数 简要介绍首先javabean类对象 1234567891011121314151617181920212223242526272829package com.qs304;import java.util.List;import java.util.Map;public class Beans &#123; private Integer account; private String password; private Person person; private Map&lt;String,String&gt; map; private List&lt;String&gt; list;&#125;class Person&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + '&#125;'; &#125;&#125; 参数绑定接收方法 123456789@Controller@RequestMapping("parme")public class HelloController &#123; @RequestMapping(value = "/hello",method = RequestMethod.POST) public String helloSpringMVC(Beans beans)&#123;//返回值表示要跳转的jsp页面的名字 System.out.println(beans); return "success"; &#125;&#125; jsp页面的提交 12345678&lt;form action="parme/hello" method="post"&gt; account&lt;input type="text" name="account"&gt;&lt;br/&gt; password&lt;input type="text" name="password"&gt;&lt;br/&gt; pseron.name&lt;input type="text" name="person.name"&gt;&lt;br/&gt; mapkey&lt;input type="text" name="map[key]"&gt;&lt;br/&gt; list&lt;input type="text" name="list[0]"&gt;&lt;br/&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; SpringMVC获取Servlet原生API在方法的上面的参数添加requests或者response的全限定类名即可 Spring MVC 自定义类型转换介绍​ 在SpringMVC框架中，视图层传递过来的参数都是String类型，但是在参数绑定的时候Spring框架会自动帮我们进行类型转换，但是当遇到无法转换的类型时，就需要我们自定义类型转换器 步骤：1.定义一个类，实现Converter接口，该接口有两个泛型，key表示接受类型，value表示转换后的类型 12345678public interface Converter&lt;S, T&gt; &#123;//S:表示接受的类型，T：表示目标类型 /** * 实现类型转换的方法 */ @Nullable T convert(S source); &#125; 1234567891011121314151617181920/** * 自定义类型转换器 */ public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; /* 用于把 String 类型转成日期类型 */ public Date convert(String source) &#123; DateFormat format = null; try &#123; if(StringUtils.isEmpty(source)) &#123; throw new NullPointerException("请输入要转换的日期"); &#125; format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(source); return date; &#125; catch (Exception e) &#123; throw new RuntimeException("输入日期有误"); &#125; &#125; &#125; 2.在配置文件中，注册该组件并使他生效 1234567891011&lt;!-- 配置类型转换器工厂 --&gt; &lt;bean id="converterService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;!-- 给工厂注入一个新的类型转换器 --&gt; &lt;property name="converters"&gt; &lt;array&gt; &lt;!-- 配置自定义类型转换器 --&gt; &lt;bean class="com.study.web.converter.StringToDateConverter"&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 123&lt;!-- 引用自定义类型转换器 --&gt; &lt;mvc:annotation-driven conversion-service="converterService"&gt;&lt;/mvc:annotation-driven&gt; SpringMVC五大组件DispatcherServlet:前端控制器​ 用户请求到达前端控制器，是整个流程控制的中心，当使用了静态文件，如js文件css文件，如果请求不到，要注意放弃前端控制器的请求拦截 HandlerMapping:处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 ViewResolver:视图解析器ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 Handler:处理器Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 View:视图SpringMVC框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 SpringMVC 框架快速搭建演示首先使用maven创建web项目 然后导入坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;qs.304&lt;/groupId&gt; &lt;artifactId&gt;SpringMVCDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SpringMVCDemo Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SpringMVCDemo&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 然后在web.xml配置前端控制器并且设置为第一次加载的时候加载spring容器 1234567891011121314151617181920212223&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置spring前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载spring容器--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--设置启动项目就加载spring容器--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 之后创建springmvc.xml文件配置视图解析器，并且指定视图解析器扫描的包和文件后缀 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.qs304"/&gt; &lt;!--配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--配置参数--&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启springmvc注解支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 之后配置控制器controller 12345678910111213package com.qs304.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String helloSpringMVC()&#123;//返回值表示要跳转的jsp页面的名字 System.out.println("哈哈哈"); return "success"; &#125;&#125; 这是目录结构 springmvc框架运行流程 ModelAndVIew简介​ ModelAndView从这个名字我们不难看出，他的作用就是模型与视图之间进行交互。 而model,只能向request域进行存对象，所有就出现了，使用ModelAndView类用来存储处理完后的结果数据，以及显示该数据的视图。 用法 12345678public class testModelAndView&#123; @RequestMapping("/testModelAndView") public void testModelAndView()&#123; ModelAndView mv=new ModelAndView(); mv.addObject("asd","asd");//忘request域存取数据 mv.setViewName("123");//使用前端控制器跳转到123页面 &#125;&#125; 使用关键字进行转发或者重定向在返回值前写forward:路径这样会进行转发功能，使用redirect进行重定向注意，这种方法使用较少，而且使用后不能使用前端控制器]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA动态代理]]></title>
    <url>%2F2019%2F02%2F27%2FJAVA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[JAVA动态代理前言：​ 最近在学习spring框架，但是在学习（切面编程）aop的时候老师讲到了一个动态代理，这个东西听着很晕乎，听说在学习javaweb的时候讲filter过滤器也是这个原理，╮(╯▽╰)╭无奈当时没有注意底层也就没有学会，现在正好有机会就把这个动态代理好好学习一下吧。 1.什么是代理代理模式的定义：​ 代理模式给某一个对象提供一个代理对象，并有代理对象控制原对象的引用（╮(╯▽╰)╭，定义都是这么的晦涩难懂） 例子：​ 假如你现在想购买一个笔记本，于是乎当然只关心价格和性能售后啊，而且购买渠道要方便啊，当然厂家生产笔记本后不可能把货物分发到全球各地因为地球太大了，但是消费者想要购买的方便啊，对于消费者来说他要购买方便也就是买电脑的地方离自己比较近，并不关心厂家怎么把电脑弄过来，而且对于厂家来说他只要把电脑做出来做好售后就行了，为什么费这么大劲在各地建立销售网点呢，好钢当然是用在刀刃上面啦。于是乎电脑城这个奸商聚集地就出来了（带着有色眼镜看待的这个问题，不要喷我），奸商正好把厂家和消费者连接起来。而且消费者想维修之类的必须经过代理商也就是电脑城的奸商才能和厂家联系，于是乎这个代理商就起到了代理的作用。 2. 要想知道动态代理首先要知道代理模式的应用场景### 需求和分析：​ 假设有个需求，需要你不修改原有代码的基础上对一个类（Person）的功能进行增强，这下怎么办呢？ ​ 其实可以这样，首先写一个用来增强那个Person那个类的类并且继承Person类实现的那个接口，就叫他Proxy类吧，然后在Proxy类创建的时候可以吧Person这个类当做参数传进去，然后在Proxy类中调用同名的方法（哒哒哒，这就完成啦），其实这个过程就是静态代理模式。也就是说代理对象 = 增强代码 + 目标对象（原对象） 大概就是这样样子，画图比较丑，而且不会用xmind（╮(╯▽╰)╭） 静态代理模式的缺点：​ 这样有什么缺点呢，假设我们有很多个类需要被增强，那么我们要给每一个类都写一个对应的代理类，那么这样也忒麻烦了，代理类你这么麻烦搞的大家都不想和你玩了。 3.动态代理前言​ 动态代理之前要说其实还有一个class类，这个东西比较复杂，（先埋个坑，以后在填坑），class这个类可以获取任意类的构造方法，属性等等等之类的，也就是说我们可以用来复制一个类，代理类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。也就是说接口拥有代理类对象和目标对象共同的类信息，但是类信息不能创建对象。于是乎jdk提供了java.lang.reflect.InvocationHandler接口和java.lan.reflect.Proxy类。 Proxy类​ Proxy有个静态方法：getProxyClass(ClassLoader,interfaces),只要你给他传入类加载器和一组接口，他就会给你返回代理Class对象。 ​ 通俗点说就是，你给他传入接口的Class中，复制类结构到新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。 所以Proxy.getProxyClass()这个方法的本质就是用Class造Class 动态代理的作用：​ Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大； ​ 可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用； ​ 解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。 ### 代码演示电脑生产厂家类（被代理对象） 12 电脑城坑人类（代理对象） 12 销售接口: 12 Main类 12]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven入门教程]]></title>
    <url>%2F2019%2F02%2F20%2Fmaven%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[maven教程简介​ Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。 Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。（这是我百度复制过来的，╮(╯▽╰)╭，算是毛病吧） 特性跨平台：是指跨OS平台，跨IDE平台 标准化：项目构建标准化，和项目结构标准化 maven目录结构 命令4. 编译源代码： 1mvn compile 5. 编译测试代码： 1mvn test-compile 6. 运行测试: 1mvn test 7. 产生site： 1mvn site 8. 打包： 1mvn package 9. 在本地Repository中安装jar： 12mvn install例：installing D:\xxx\xx.jar to D:\xx\xxxx 10. 清除产生的项目： 1mvn clean 11. 生成eclipse项目： 1mvn eclipse:eclipse 12. 生成idea项目： 1mvn idea:idea 13. 组合使用goal命令，如只打包不测试： 1mvn -Dtest package 14. 编译测试的内容： 1mvn test-compile 15. 只打jar包: 1mvn jar:jar 16. 只测试而不编译，也不测试编译： 12mvn test -skipping compile -skipping test-compile ( -skipping 的灵活运用，当然也可以用于其他组合命令) 17. 清除eclipse的一些系统设置: 1mvn eclipse:clean 18.查看当前项目已被解析的依赖： 1mvn dependency:list 19.上传到私服： 1mvn deploy 20. 强制检查更新，由于快照版本的更新策略(一天更新几次、隔段时间更新一次)存在，如果想强制更新就会用到此命令: 1mvn clean install-U 21. 源码打包： 123mvn source:jar或mvn source:jar-no-fork]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>习惯</tag>
        <tag>maven</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码注意细节]]></title>
    <url>%2F2019%2F02%2F20%2F%E4%BB%A3%E7%A0%81%E6%B3%A8%E6%84%8F%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[代码注意细节1.设计细节springspring配置类中父子关系的配置类更好 mysqlmysql中要严格遵守三大范式才能设计比较好的数据库 mysql中使用外键约束要注意进行级联操作，否则必须先修改依赖表 2.编码细节]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于SSM的学生管理系统第一天]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%9F%BA%E4%BA%8ESSM%E7%9A%84%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[学生管理系统环境 jdk1.8版本 IDEA任意版本 Navicat任意版本 数据库5.7版本 框架 前端框架：easyui框架（目前最流行的前端管理框架） 后台框架: Spring+SpringMVC+Mybatis]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>Spring</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架]]></title>
    <url>%2F2019%2F01%2F15%2FSpring%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Spring框架1.Spring简介: 为从大小与开销两方面而言Spring都是轻量的 通过控制反转（IoC）的技术达到松耦合的目的 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发 包含并管理应用对象的配置和生命周期，所以spring是一种容器 将简单的组件配置、组合成为复杂的应用，这个意义上是框架 2.spring的核心 控制反转（IoC）和面向切面编程（AOP） 1.什么事控制反转呢？​ 控制反转loC主要是用来解决耦合的问题的，一个类直接依赖另一个类，这样耦合性是很高的，但是我们可以通过创建一个工厂模式，对象创建另一个对象的时候通过查找map容器，如果map容器不存在，就在本地配置文件中查找类的类名来获取类。这样就把类与类之间的关系转化为了类与工厂与类的关系，从而解决了耦合性的问题。 控制反转loC演示首先创建两个类 Main类是主方法类用来调用Demo方法类里面的toString方法，通过loC控制反转调用 在resources包下面创建一个xml配置文件 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- id表示调用这个类的时候写的类名，class表示类的包名加类名,其中Java目录下的表示根目录 使用注解@Component 类型首字母要小写 --&gt; &lt;bean id="Demo" class="Demo"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;/beans&gt; 12345//ApplicationContext接口的实现对象ClassPathXmlApplicationContext来获取容器ApplicationContext ac= new ClassPathXmlApplicationContext("bean.xml");//通过反射机制获取Bean对象Demo de=ac.getBean("Demo",Demo.class);de.toString(); ApplicationContext接口的继承关系 ApplicationContext:读取配置文件的时候立即加载对象（单例对象适用，经常使用）BeanFatory:遇见getBean的时候才加载对象（多例对象适用）ApplicationConxt接口常用的实现类ClassPathXmlAppliationContext:加载类路径下的配置文件，要求配置文件必须在类路径下FileSystemXmlApplicationContext:加载磁盘任意路径下的配置文件AnnotationConfigAppliationContext:读取注解创建容器3.spring的核心容器Beans(管理bean)Core(核心)Context(上下文（配置文件）)Expresslon Language(SpEl表达式)3.SpringBeanSpringBean创建的三种方式12345678910&lt;!--第一种创建方式id表示调用这个类的时候写的类名，class表示类的包名加类名,其中Java目录下的表示根目录--&gt;&lt;!--使用默认无参构造方法创建--&gt; &lt;bean id="Demo" class="Demo"&gt;&lt;/bean&gt;&lt;!--第二种，使用普通工厂中的方法创建对象,并存入spring容器--&gt; &lt;!--创建Fatory工厂类--&gt; &lt;bean id="Fatory" class="DeFatorymo"&gt; &lt;/bean&gt; &lt;!--获得Service类通过Fatory工厂里面的getService方法--&gt; &lt;bean id="Service" fatory-bean="Fatory" fatory-method="getService"&gt;&lt;/bean&gt;&lt;!--第三种，使用工厂中静态方法创建对象，并存入spring容器--&gt; &lt;bean id="Service" class="Service" facctory-method="getService"&gt;&lt;/bean&gt; SpringBean的作用范围和生存周期Bean标签的scope属性可以指定对象的作用范围 singleton单例对象（默认）解析xml出生，也就是和容器一样 prototype多例对象 ，使用时出生，当对象长时间不使用，而且没有对象引用 的时候被垃圾回收器销毁 request作用于web应用的请求范围 session作用于web的应用的会话范围 global-session:作用于集群环境的会话范围，全局的会话范围 4.Spring注入概述（经常变化的数据不适合注入）​ 平常的Java开发中，程序员在某个类中需要依赖其它类的方法。 ​ 通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理。 ​ Spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过Spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。 ​ 依赖注入的另一种说法是”控制反转”。通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员。 ​ 而控制反转是指new实例工作不由我们程序员来做而是交给Spring容器来做。 详解如果使用注解的方式首先要在xml约束中添加 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--然后告诉spring创建容器时时要扫描的包--&gt; &lt;context:component-scan base-package="&lt;包名&gt;"&gt;&lt;/context:component-scan&gt; ​ 基本数据类型包装类型和String ​ 其他Bean类型（在配置文件中或者注解配置过的Bean） ​ 其他类型/集合类型 注入的方式使用构造函数​ 首先创建一个类,通过构造方法给成员变量进行赋值 12345678910111213141516171819202122import java.util.Date;public class Bean &#123; private int age; private String name; private Date newDate; @Override public String toString() &#123; return "Bean&#123;" + "age=" + age + ", name='" + name + '\'' + ", newDate=" + newDate + '&#125;'; &#125; private Bean(int age, String name, Date newDate)&#123; this.age=age; this.name=name; this.newDate=newDate; &#125;&#125; XML里面这样配置 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- constructor-arg标签属性详解-------------------------------------------------查找构造方法属性： type通过指定数据类型进行查找 index通过指定下标进行查找，下标从0开始 name通过名字进行查找（最常用的方式）---------------------------------------------------赋值： value给对象进行赋值，非String类型能自动转换，特殊类型需要使用rel rel指定其他Ioc核心容器里面的bean对象进行赋值--------------------------------------------------- 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功 弊端：改变了bean实例化的方式，使我们在创建对象时，如果用不大这些数据，也必须提供 --&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;constructor-arg name="age" value="12"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="name" value="哈哈哈哈"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="newDate" ref="newDate"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="newDate" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用set方法（更常用）首先创建如下Bean对象 给里面的成员属性进行赋值 123456789101112131415161718192021222324252627import java.util.Date;public class Bean &#123; private int age; private String name; private Date newDate; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setNewDate(Date newDate) &#123; this.newDate = newDate; &#125; @Override public String toString() &#123; return "Bean&#123;" + "age=" + age + ", name='" + name + '\'' + ", newDate=" + newDate + '&#125;'; &#125;&#125; 然后XML配置文件写 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;!-- constructor-arg标签属性详解-------------------------------------------------查找构造方法属性： name通过set方法名字进行查找---------------------------------------------------赋值： value给对象进行赋值，非String类型能自动转换，特殊类型需要使用rel rel指定其他Ioc核心容器里面的bean对象进行赋值--------------------------------------------------- 优势：创建对象的时候没有明显的限制，可以直接使用默认的无参构造方法进行构建 弊端：如果某个成员变量必须被赋值，则获取对象是有可能set方法没有被执行 --&gt; &lt;property name="age" value="12"&gt;&lt;/property&gt; &lt;property name="name" value="哈哈哈哈"&gt;&lt;/property&gt; &lt;property name="newDate" ref="newDate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="newDate" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 针对复杂的集合数据类型进行set注入Bean类 12345678910111213141516171819202122232425262728293031import java.util.Arrays;import java.util.Date;import java.util.List;import java.util.Map;public class Bean &#123; private String[] strs; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; @Override public String toString() &#123; return "Bean&#123;" + "strs=" + Arrays.toString(strs) + ", list=" + list + ", map=" + map + '&#125;'; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public void setStrs(String[] strs) &#123; this.strs = strs; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125;&#125; XML配置 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;property name="strs"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="123" value="aaa"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 使用注解代替xml配置的注解@Configuration：说明当前类是一个配置类​ @ComponentScan:指定spring在创建容器时要扫描的包 ​ 属性 value和basePackages作用一样 ​ 等同于在xml中的: 1&lt;context:component-scan base-package="&lt;类路径&gt;"&gt;&lt;/context:component-scan&gt; 当使用了AnnotationConfigApplicationContext();这个类的时候可以不使用这个标签，但是如果有多个配置类，需要在ComponentScan注解中包含另一个配置类，并且另一个配置类必须使用Configuration注解来表示他是一个注解类，或者使用import来避免使用Configuration注解这个问题 演示 1234567891011package com.cofing;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.ComponentScan;//首先要声明当前类是一个注解类@Configurable@ComponentScan("类路径")public class Config &#123;&#125; @import导入其他配置类 （有这个注解的配置类也被称为父配置类，那么被包含的配置类被称为子配置类）如果使用AnnotationConfigApplicationContext();导入了主配置类，那么可以通过在主配置类上面填写@import导入其他配置类，而且此时不能被@ComponentScan注解替代 创建对象的注解@Component 作用把当前类对象存入spring容器中​ 属性：value,用于指定bean的id，当我们不写的时候，默认值是当前类名的首字小写 和上面作用一样Controller:用在表现层 Service:用在业务层 Repository:用在持久层 注入数据的注解@Autowired:​ 作用：自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，或者和他的接口父类类型匹配，就注入成功，如果有多个匹配类型按照名字相同的进行匹配，否则匹配失败。 出现位置:可以是变量上，也可以是方法上细节：在使用注解注入时，set方法就不说必须的了。@Qualifier:在按照类型注入的基础之上再按照名称注入，给类成员注入时不能单独使用，给方法参数注入是可以单独使用​ 属性： value:要注入bean的id @Resource: 可以单独使用​ 属性为：name直接按照id进行注入 上面的三个注入都只能对其他bean类型进行注入，不能对基本类型和String类型进行注入，而且集合类型只能使用xml进行注入。 @value作用，用于注入基本类型和String类型的数据而且可以使用spEL表达式@Bean:作用吧当前方法的返回值作为bean对象存入spring的ioc容器中​ 属性：name用于指定bean的id,当不写时，默认值是当前方法的名称 改变作用范围的注解@Scope :用于指定bean的作用范围 不声明默认是单例的​ 属性:value:指定范围的取值，常用取值:singleton prototype ​ 和生命周期相关的注解@PreDestroy​ 作用:用于指定销毁方法 @PostConstruct​ 作用:用于自定初始化方法 @PropertySource 作用:用来指定properties文件的位置（然后@Value标签就可以用spEL表达式去获取值）​ 属性value：指定文件的名称和路径 ​ 关键字classpath表示类路径下 JAVA的动态代理代理模式 （可以进一步增强代码的复用性）​ 代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。​ 按照代理的创建时期，代理类可以分为两种。 ​ 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。​ 动态代理：在程序运行时，运用反射机制动态创建而成。 (个人觉的类似于javaweb的监听器概念) 接下来代码演示 Main.java 123456789101112131415161718192021222324252627282930import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Main &#123; public static void main(String[] args) &#123; final Factory fatory=new Factory(); //消费者通过动态代理购买商品 //ClassLoader:类加载器，加载代理对象的字节码，和被代理对象相同的类加载器 //Class[] 让代理对象和被代理对象有相同方法，固定写法 //InvoactionHandler 用于代理的方法 IProxy proxy=(IProxy) Proxy.newProxyInstance(fatory.getClass().getClassLoader(), fatory.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的热河接口和方法都会经过该方法 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行方法所需要的参数 * @return 和配代理对象具有相同的返回值 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(method.getName().equals("salfMoney")==true)&#123; System.out.print("代理商坑人了"); &#125; return method.invoke(fatory,args); &#125; &#125;); proxy.salfMoney(5000); &#125;&#125; Factory.java 123456789/** * 生产厂家,被代理类 * 要想使用动态代理模式必须要继承一个接口 */public class Factory implements IProxy&#123; public void salfMoney(float money) &#123; System.out.print("卖了"+money+"元"); &#125;&#125; Iproxy.java 1234567/** * 代理接口 */public interface IProxy &#123; //销售商品接口 public void salfMoney(float money);&#125; AOP编程实例​ 使用spring Aop编程除了要加入Spring的spring-aop jar包，还要加入aspectjrt.jar，aspectjweaver.jar，以及aopalliance_1.0.jar 以下两个是与aspectj相关的包,用来支持切面编程的 aspectjrt包是aspectj的runtime包 aspectjweaver是aspectj的织入包 Cglib包是用来动态代理用的,基于类的代理 1.切入点表达式​ 例如：dao包下public void addAccount(int i);和dao包下的public int reAccount(); ​ 手写访问修饰符可以省略不写 12//匹配public void addAccount(int i)可以写成void addAccount(int) 1.返回值类型可以使用通配符* 表示任意返回值2.包名必须用·进行分割 比如 * . * . *形式3.或者使用* .. 匹配多级目录4.方法名称也可以使用通配符 *5.参数列表可以使用float之类的基本数据类型，如果是复杂数据类型需要些包名加类名如果参数列表使用 * 进行通配符匹配只能匹配有参数的方法，要想匹配所有参数列表的需要使用 ..进行匹配2. 4种通知类型1234&lt;aop:before method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:before&gt;&lt;!--前置通知--&gt;&lt;aop:after-returning method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after-returning&gt;&lt;!--后置通知--&gt;&lt;aop:after-throwing method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after-throwing&gt;&lt;!--异常通知--&gt;&lt;aop:after method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after&gt;&lt;!--最终通知--&gt; 环绕通知是spring框架为我们提供的一种可以做在代码中手动控制增强方法合适执行的一种方式如果觉得配置execution比较麻烦可以使用切入点表达式解决项目目录通过xml的方式实现AOP开发步骤​ 1.把通知bean交给spring来管理（LogMessage类） ​ 2.使用aop:config标签表明开始配置切面 ​ 3.使用aop:aspet标签表明配置切面 ​ id属性，是给切面提供一个唯一标识 ​ ref属性：是指定通知类bean的id ​ 4.在aop:aspet标签的内部使用对应标签来配置通知的类型 ​ aop:before标识前置通知 ​ method属性，用于指定Logger类中那个方法是前置通知 pom.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;AOPDmo&lt;/groupId&gt; &lt;artifactId&gt;AOPDmo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; LogMessage.java 用于增强service类的前置 123456789101112package log;/** * 打印日志类 * 用来增强其他类 */public class LogMessage &#123; public void logMessage()&#123; System.out.print("执行了争抢方法的内容"); &#125;&#125; Iservice接口 123456789package service;/** * service接口 */public interface Iservice &#123; public void addAccout(); public void deletAccount(int i);&#125; Service类 123456789101112package service;public class Service implements Iservice&#123; public void addAccout() &#123; System.out.print("添加了账户"); &#125; public void deletAccount(int i) &#123; System.out.print("删除了账户信息"); &#125;&#125; springconfig.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="logmessage" class="log.LogMessage"&gt;&lt;/bean&gt; &lt;bean id="service" class="service.Service"&gt;&lt;/bean&gt; &lt;!--开始aop配置--&gt; &lt;aop:config&gt; &lt;!--开始配置切面--&gt; &lt;aop:aspect id="aoplog" ref="logmessage"&gt; &lt;!--进行前置切面配置--&gt; &lt;aop:before method="logMessage" pointcut="execution(public void service.Service.addAccout())"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; main.java 12345678910111213import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import service.Iservice;import service.Service;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("springconfig.xml"); //注意--必须是service的接口类型， Iservice ser= (Iservice) ac.getBean("service"); ser.addAccout(); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++语言位运算基本用法和骚操作]]></title>
    <url>%2F2018%2F08%2F27%2FCC%2B%2B%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C/C++语言位运算基本用法和骚操作前言:​ 前几天打了徐州ACM的网络模拟赛，其中有个题觉得很容易做出来，但是死活都是卡时间和卡内存，于是乎就百度了一下题解（╮(╯▽╰)╭手动狗头），结果学到了一个新的算法，叫做区间数组，然后就学了学，结果学的云里雾里的，其中区间数组核心的一个确定区间的函数 123lowbit(int x)&#123; return x&amp;(-x);&#125; 更是云里雾里。然后就结束今天的新的吧。 位运算基本用法 操作符 作用 解释 &amp; 位AND 如果 x 和 y 都为 1，则得到 1；如果 x 或 y 任何一个为 0，或都为0，则得到 0 | 位OR 如果 x 或 y 为 1，或都为 1，则得到 1；如果 x 和 y 都为 0，则得到 0 ^ 位 XOR 如果 x 或 y 的值不同，则得到 1；如果两个值相同，则得到 0 ~ 位 NOT（I的补码） 如果 x 为 0，则得到 1，如果 x 是 1，则得到 0 运算符 意义 示例 结果 &lt;&lt; 向左移位 x&lt;&lt;y x 的每个位向左移动 y 个位 &gt;&gt; 向右移位 x&gt;&gt;y x 的每个位向右移动 y 个位 骚操作判断一个整形最后一位是否是1(用来判断奇偶数)123if(n&amp;1)&#123; printf("是奇数");&#125; ### 演示​ 将输入的一个n（int类型整数）转换成二进制小数（n&gt;=0） 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(void)&#123; int n; while(true) &#123; cin&gt;&gt;n; stack&lt;int&gt; sta; while(n&gt;0)//输出二进制末尾小数打印出并且进行移位 &#123; if(n&amp;1) sta.push(1); else sta.push(0); n&gt;&gt;=1; &#125; while(!sta.empty()) &#123; cout&lt;&lt;sta.top(); sta.pop(); &#125; cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow入门教程]]></title>
    <url>%2F2018%2F05%2F27%2F1.tensorflow%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1.tensorflow基本介绍1.TensorFlow 简介​ TensorFlow是一个基于数据流编程的符号数学系统，被广泛应用于各类机器学习算法的编程实现，其前身是谷歌的神经网络算法库 2.TensorFlow基本术语张量（tensor）：​ 张量就是基于向量和矩阵的推广，通俗点理解就是可以将标量看成零阶张量，向量看成一阶张量，矩阵就是二阶张量。 图（graph）​ 代表着一段内存地址，也可以理解成所有的节点和张量的集合 节点（op）​ 每个运算和张量都是一个节点，每个节点就是一个op 会话(Session)​ 会话的作用就是执行图的计算，众所周知在TensorFlow中会话之前的都是图的定义或者是op的定义，只能表示关系不参与计算，所以需要用会话让图真正的执行起来 2.张量（tensor）的使用以及注意事项1.张量的基本概念​ 张量就是基于向量和矩阵的推广，通俗点理解就是可以将标量看成零阶张量，向量看成一阶张量，矩阵就是二阶张量。 2.张量的数据类型 数据类型 Python类型 描述 DT_FLOAT tf.float32 32位浮点数 DT_DOUBLE tf.float64 64位浮点数（精度和float32精度一致） DT_INT64 tf.int64 64位有符号整数 DT_INT32 tf.int32 32位有符号整数（精度和int32精度一致） DT_INT13 tf.int16 16位有符号整数 DT_INT8 tf.int8 8位有符号整数 DT_STRING tf.string 可变长度的字节数组，每一个张量元素都是一个字节数组。 DT_BOOL tf.bool 布尔型 DT_COMPLEX64 tf.compiex64 由两个32位浮点数组组成的复数：实数和虚数 DT_QINT32 tf.qint32 用于量化Ops的8位有符号整数 DT.QINT8 tf.qint8 用于量化Ops的8位有符号整形 DT_QUINT8 tf.quint8 用于量化Ops的8位无符号整形 3.张量的代码12345678#导入tensorflow包，简写为tfimport tensorflow as tf#定义一个3.0的常量的张量tensor=tf.constant(3.0)#显示tensor的结果print(tensor)#结果将会是：Tensor("Const:0", shape=(), dtype=float32) 其中Const表示进行的op操作名字shape表示张量的维度,()表示标量，（1）表示向量，（2，3）表示2行3列的张量dtype表示张量的数据类型4.生成张量创建一个常数张量tf.constant(value,dtype=None,shape=None,name=”Const”) 创建一个dtype类型的维度为shape的常数张量 固定值初始化tf.zeros([n,m],tf.dtype)获取一个n行m列的零元素tf.dtype类型的张量 tf.ones([n,m],tf.dtype)获取一个n行m列的1元素tf.dtype类型的张量 随机值初始化tf.random_normal([n,m],mean=2.0,stddev=4,seed=12)创建一个n行m列的正态分布（高斯分布）平均值为2.0，方差为4,随机种子为12张量 5.占位符1tf.placeholder(dtype,shape,name) dtype张量的数据类型 shape张量的维度 [2,3]生成一个2行3列的占位符,[None,3]表示生成一个不确定行和3列的占位符 6.张量的维度调整区别如果调整的过程中生成了新的张量，这种调整称作动态调整 静态调整语法: 张量名字.set_shape([n,m]) 调整张量为n行m列 注意 静态张量只能调整之前不确定维度的张量，比如shape=[None,3]的张量 动态调整语法: tf.reshape(tensor,shape,name=None)动态张量会生成新的张量而且可以跨维度修改，也就是二阶张量可以向n阶张量改变，但是改变前和改变后其总个数必须一致，如果不知道具体维度，需要填写成-1 7.改变张量的类型1tf.cast(x,dtype,name="None") 将x张量转换为dtype类型的张量 1tf.cast([[1,2,3],[4,5,6],[7,8,9]],tf.float32) 将列表从整形转换成float32类型 8.张量的切片和扩展 1tf.concat(value,axis,name="concat") 可以将连个张量拼接起来 value 可以是个列表 axis 表示按行合并还是按列合并 0表示按行合并，1表示按列合并 1234567891011121314151617181920212223242526import tensorflow as tf#定义两个列表a=[[1,2,3],[4,5,6]]b=[[7,8,9],[10,11,12]]#合并两个列表hangCat=tf.concat([a,b],axis=0)lieCat=tf.concat([a,b],axis=1)#由于上面只是搭建了个图结果并没有实际运行,接下来进行实际运行。with tf.Session() as sess: print("行合并") print(sess.run(hangCat)) print("列合并") print(sess.run(lieCat)) #运行结果为：行合并[[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]]列合并[[ 1 2 3 7 8 9] [ 4 5 6 10 11 12]] 3.会话（Session）​ 会话的作用就是执行图的计算，众所周知在TensorFlow中会话之前的都是图的定义或者是op的定义，只能表示关系不参与计算，所以需要用会话让图真正的运行起来 基本写法12with tf.Session() as sess: sess.run(fetches,feed_dict=None,options=None,run_metadata=None) 1.run方法fetches 运行ops和计算tensorfeed_dict 可选项（字典类型），提取使用占位符之后给图提供数据4.变量（Variable）​ 变量是一种特殊的张量，也是一种op,它能够被存储持久化，他们的值就是张量，默认被训练 1.变量的定义1tf.Variable(initial_balue=None,name=None,trainable=True) initial_value 值 可以用正态分布或者固定生成张量的值 注意：使用变量的时候必须先运行全局初始化初始化 tf.global_variables_initializer() 例子： 12345678910import tensorflow as tf#使用正态分布分配变量的值var=tf.Variable(tf.random_normal([2,3],mean=2.0,stddev=1.0))#开启会话并运行初始化with tf.Session() as sess: #运行初始化(运行全局初始化变量前变量var并未被真正赋值) sess.run(tf.global_variables_initializer()) print(sess.run(var)) 4.TensorBoard 的使用和用法1.TensorBoard的简介​ TensorBoard是Tensorflow的可视化工具，它可以通过Tensorflow程序运行过程中输出的日志文件可视化Tensorflow程序的运行状态。TensorBoard和Tensorflow程序跑在不同的进程中，TensorBoard会自动读取最新的TensorFlow日志文件，并呈现当前TensorFlow程序运行的最新状态。 2.TensorBoard代码写入事务文件需要找到TensorFlow包里面的事务包summary里面的FileWriter方法 1tf.summary.FileWriter(logdir,graph=None) logdir事务文件的绝对路径graph写出事务文件的图1234#收集变量tf.summary.scalar(name="",tensor)#收集损失函数和准确率tf.summary.histogram(name="",tensor)#收集高纬度的变量参数tf.summary.image(name="",tensor)#收集输入的图片张量，能显示图片 name 表示TensorBoard里面显示的名称tensor表示要收集的张量123mergin=tf.summary.merge_all()#收集所有的张量summary=sess.run(mergin)#每次迭代都要运行的合并FileWriter.add_summary(summary,i)#每次迭代都要添加到事务文件 3.TensorBoard的演示​ 首先代码 1234567891011121314151617#通过两个变量的相加演示tensorboard的用法import tensorflow as tf#定义两个正态分布的随机变量var1=tf.Variable(tf.random_normal([2,3],mean=2.0,stddev=1.0))var2=tf.Variable(tf.random_normal([2,3],mean=3.0,stddev=2.0))#定义加法opadd=tf.add(var1,var2)init_variable=tf.global_variables_initializer()#开启会话with tf.Session() as sess: #初始化变量 sess.run(init_variable) #导出事务文件 tf.summary.FileWriter("./board",graph=sess.graph) print(sess.run(add)) ​ 然后启动命令行，打出下列命令 1tensorboard --logdir="D:\code\python\tensortflow\board" ​ 之后显示命令行下面显示如下信息 1TensorBoard 1.5.1 at http://By:6006 (Press CTRL+C to quit) 这就表示TensorBoard正常启动了，在浏览器输入（http://By:6006）就能正常访问tensorboard了 5.损失函数1.均方误差​ 计算方法是求预测值与真实值之间距离的平方和 ​ 公式如图所示： 6.梯度下降算法1.基本思想梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。2.代码1tf.tarin.GradientDescentOptimizer(learning_rate) learning_rate 学习率 通常填写0.0到1.0之间的浮点数6.简单的线性回归案例12345678910111213141516171819202122232425262728293031#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢?import tensorflow as tf#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(0.1).minimize(loss)#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): sess.run(train_op) print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) 7.梯度爆炸12345678910111213141516171819202122232425262728293031#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢?import tensorflow as tf#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(1).minimize(loss)#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): sess.run(train_op) print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) 1.简述​ 上述代码学习率是1，运行后就会发现权重和偏置变成了NAV，这就是梯度爆炸，也就是说学习率过大或者神经网络模型的某些原因就会导致梯度爆炸，但是学习率也不能过小，过小会得不到好的效果。 2.解决方法 重新设计神经网络 调整学习率 使用梯度阶段（在训练过程中检查和限制梯度的大小） 使用激活函数 8.模型的保存和加载1.代码1234saver=tf.train.Saver(var_list=None,max_to_keep=5)#在会话里面saver.restpre(sess,"")#读取模型saver.save(sess,"")#保存模型 var_list:自定要保持和还原的变量。他可以作为一个dict或者一个列表传进去max_to_keep:制定要保留的最近检查点文件的最大数量，创建新的文件的时候会删除比较旧的文件，默认值5“” 这个路径包含路径和文件名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢import tensorflow as tfimport os#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(0.1).minimize(loss)#收集张量tf.summary.scalar("loss",loss)tf.summary.histogram("W",w)#合并所有的收集到的张量margin=tf.summary.merge_all()#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#定义保存saver=tf.train.Saver()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) # 读取模型 if os.path.exists("./model/checkpoint"): saver.restore(sess, "./model/123") #写出事务文件 fileWiter=tf.summary.FileWriter("./board",graph=sess.graph) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): summary = sess.run(margin) sess.run(train_op) fileWiter.add_summary(summary,i) # 运行变量的合并 print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) saver.save(sess,"./model/123") 2.保存的文件格式​ .data-00000-of-00001和.index文件 ​ checkpoint文件：checkpoint_dir目录下还有checkpoint文件，该文件是个文本文件，里面记录了保存的最新的checkpoint文件以及其它checkpoint文件列表。在inference时，可以通过修改这个文件，指定使用哪个model。加载restore时的文件路径名是以checkpoint文件中的“model_checkpoint_path”值决定的。 ​ 保存模型时，只会保存变量的值，placeholder里面的值不会被保存。 9.队列机制1.简述​ TensorFlow提供了专门的队列机制,专门用来处理文件读取的问题 2.代码1queue=tf.FIFOQueue(capatity,dtype)#定义一个队列 capatity 队列的容量dtype队列存储的数据类型1queue.dequeue()#出队列并且移除 12queue.enqueue()#入队列int=queue.enqueue_many(list)#入队一个列表元素 演示:1234567891011121314151617181920#定义一个队列，不断出队列和入队列import tensorflow as tf#定义一个队列queue=tf.FIFOQueue()#添加队列元素int=queue.enqueue_many([[1.0,2.0,3.0],])#定义图结构item=queue.dequeue()data=item+1en=queue.enqueue(data)#开始执行图结构with tf.Session() as sess: #运行添加元素结构 sess.run(int) for i in range(20): sess.run(en) for i in range(queue.size().eval()): print(queue.dequeue().eval()) 10.文件读取1.文件读取的过程1.构造文件队列2.构造阅读器3.对于每个样本进行解码4.批处理文件2.文件读取的API介绍构造文件队列1tf.tarin.string_inpput_producer(string_tensor,shuffle=True) string_tensor 含有文件名的一阶张量（包含路径以及文件名的列表）shuffle 是否乱序 默认乱序num_epochs 过几遍数据，默认无限过数据构造文件阅读器 所有阅读器解码出来形状都是不固定的，注意后边进行形状固定 要根据文件类型选择对应的文件阅读区 每个read方法返回key，和value参数，其中key表示文件名称，value表示每个样本 文本文件和CSV文件: 12class reader=tf.TextLineReader()#构造文件阅读器 reader.read(file_queue)#读取一个样本 文本文件阅读器，默认按行读取，（因为对于csv文件和文本文件来说，一行就是一个样本）return 返回阅读器实例read(file_queue)file_queue 从队列里面读取内容二进制文件阅读器12class reader=tf.FixedLengthRecordReader(record_bytes)#构造文件阅读器 reader.read(file_queue)#读取一个样本文件 读取每个样本是按固定数量的字节读取的二进制文件record_bytes:整形，指定每次读取的字节数return 返回阅读器实例图片文件阅读器12class reader=tf.WholeFileReader()#构造图片文件阅读器 reader.read(file_queue)#读取一个图片样本 每个样本进行解码CSV文件解码1tf.decode_csv(value,record_defaults=None) value表示待解码的内容record_defaults 表示每个样本如何解码，并且缺失的时候的默认值 [[1]]表示一个样本按整形解码，缺失的时候为1，[[“None”],[1.0]] 表示样本有两个第一个按string类型解码，缺失的时候是None,第二个按float类型解码，丢失按1.0处理图片文件解码 123456tf.image.decode_jpeg(contents)#将JPEG编码的图像解码为uint8的张亮#return:uint8张量3-D形状[height,width,hannels]tf.image.decode_png(contents)#将PNG图片的图像解码为uint8或者uint16的张量#return:张量类型，3-D形状[height,width,hannels] 图片文件缩放 123tf.image.resize_images(images,size)images:4-D形状[batch,height,width,channels]或者3-D的形状的张量[height,width,channels]size图片的新尺寸，new_height,new_width 管道批处理文件 12#批处理 batch_size表示每批的数量，num_threads进行的线程数量，capacity批处理管道的容量 ones,twos=tf.train.batch([one,two],batch_size=6,num_threads=1,capacity=9) 3.文件读取的简单演示1234567891011121314151617181920212223242526272829303132333435363738394041424344#1.构造文件队列（路径加文件名）#2.构造文件阅读器#3.按每个样本解码（转化为张量 ）#4.构造批处理###在同目录下有个data文件夹，里面的csv文件里面都有两行且都是string类型import tensorflow as tfimport os#找到对应的文件目录获取文件路径加列表def fileRead(path): fileName=os.listdir(path) filePath=[os.path.join(path,file) for file in fileName] return filePathdef csvRead(fileList): #构造文件队列 fileQueue=tf.train.string_input_producer(fileList) #构造阅读器 reader=tf.TextLineReader() key,value=reader.read(fileQueue) #对文件进行解码 #设定每行的类型以及每行的默认值 cord=[["None"],["None"]] one,two=tf.decode_csv(value,record_defaults=cord) #批处理 batch_size表示每批的数量，num_threads进行的线程数量，capacity批处理管道的容量 ones,twos=tf.train.batch([one,two],batch_size=6,num_threads=1,capacity=9) return ones,twosif __name__ == "__main__": fileList=fileRead("./data") one,two=csvRead(fileList) with tf.Session() as sess: #定义一个线程协调器 coord=tf.train.Coordinator() #开启一个线程 thread=tf.train.start_queue_runners(sess,coord=coord) print(sess.run([one,two])) #回收子线程 coord.request_stop() coord.join(thread) 图片文件的读取简单演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#读取当前文件夹下面的data目录下面所有的jpg格式图片的信息#步骤# 1.获取path文件下面的所有图片的全路径列表# 2.构造文件队列# 3.构造图片阅读器# 4.图片解码# 5.图片缩放# 6.图片调整维度# 7.批处理import tensorflow as tfimport os#读取path目录下所有的图片信息def getPath(path): fileNames=os.listdir(path) filePath=[os.path.join(path,fileName) for fileName in fileNames] return filePath#读取图片并进行批处理def readImg(filePathList): #1.构造文件队列 fileQueue=tf.train.string_input_producer(filePathList) #1.构造图片阅读器 reader=tf.WholeFileReader() key,value=reader.read(fileQueue) print("构造完阅读器",value) #3.图片解码 image=tf.image.decode_jpeg(value) print("解码",image) #4.图片缩放 reImage=tf.image.resize_images(image,[200,200]) print("图片放缩后",reImage) #5.图片定型 静态调整 reImage.set_shape([200,200,3]) print("图片静态调整后",reImage) #文件批处理 jpg=tf.train.batch([reImage],batch_size=5,num_threads=2,capacity=5) return reImageif __name__ == "__main__": filePathList=getPath("./data") jpg=readImg(filePathList) #开启会话 with tf.Session() as sess: #定义一个线程协调器 coord=tf.train.Coordinator() #定义一个线程 thread=tf.train.start_queue_runners(sess,coord=coord) print(sess.run(jpg)) #回收子线程 coord.request_stop() coord.join(thread) 注意打印结果: 构造完阅读器 Tensor(“ReaderReadV2:1”, shape=(), dtype=string)解码 Tensor(“DecodeJpeg:0”, shape=(?, ?, ?), dtype=uint8)图片放缩后 Tensor(“Squeeze:0”, shape=(200, 200, ?), dtype=float32)图片静态调整后 Tensor(“Squeeze:0”, shape=(200, 200, 3), dtype=float32) 11.交叉熵损失计算和softMax计算1.softMax计算​ 假设我们有一个数组，V，Vi表示V中的第i个元素，那么这个元素的Softmax值就是 ​ 可以计算n个结果之间发生的概率 2.交叉熵损失​ 可以和onehost编码与softMax计算损失 123456#SoftMax和交叉熵损失计算tf.nn.softmax_cross_entropy_with_logits(babels=None,logits=None,name)#计算logits和labels之间的交叉熵损失#labels:真实值#logits:预测值#return:返回所有样本的损失值列表 3.演示12345678910111213141516def argmax(input, axis=None, name=None, dimension=None, output_type=dtypes.int64)numpy.argmax(a, axis=None, out=None) 返回沿轴axis最大值的索引。Parameters: input: array_like，数组axis : int, 可选，默认情况下，索引的是平铺的数组，否则沿指定的轴。 out : array, 可选 如果提供，结果以合适的形状和类型被插入到此数组中。 Returns: index_array : ndarray of ints 索引数组。它具有与a.shape相同的形状，其中axis被移除。 12345678910111213141516171819202122232425262728293031323334353637383940#简单的神经网络识别手写数字#1.定义占位符#2.搭建神经网络#3.计算损失#4.反向传播优化损失#5.计算准确率#6.开启会话训练import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets("./MNIST_data", one_hot=True)def imgNn(): #1.定义占位符 xDist=tf.placeholder(tf.float32,[None,784]) yTrue=tf.placeholder(tf.float32,[None,10]) #2.初始化变量搭建神经网络 w=tf.Variable(tf.random_normal([784,10],mean=0.0,stddev=1.0)) b=tf.Variable(tf.random_normal([10],mean=0.0,stddev=1.0)) y=tf.matmul(xDist,w)+b #3.计算平均交叉熵损失率 loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=yTrue,logits=y)) #4.反向传播最小优化学习率0.1 trainOp=tf.train.GradientDescentOptimizer(0.1).minimize(loss) #5.计算准确率 arg_max会反正正确结果的下标 1表示按同行比较 0表示同列 equal_list=tf.equal(tf.arg_max(yTrue,1),tf.arg_max(y,1)) acuracy=tf.reduce_mean(tf.cast(equal_list,tf.float32)) initOp=tf.global_variables_initializer() #6.开启会话开始训练 with tf.Session() as sess: sess.run(initOp) for i in range(3000): #取出特征值和目标值 minstX,minstY=mnist.train.next_batch(50) sess.run(trainOp,feed_dict=&#123;xDist:minstX,yTrue:minstY&#125;) print("%d步准确率%f" % (i,sess.run(acuracy,feed_dict=&#123;xDist:minstX,yTrue:minstY&#125;)))if __name__ =="__main__": imgNn() 12.卷积神经网络1.概述​ 卷积神经网络（Convolutional Neural Networks / CNNs / ConvNets）与普通神经网络非常相似，它们都由具有可学习的权重和偏置常量(biases)的神经元组成。每个神经元都接收一些输入，并做一些点积计算，输出是每个分类的分数，普通神经网络里的一些计算技巧到这里依旧适用。 具有三维体积的神经元(3D volumes of neurons) ​ 卷积神经网络利用输入是图片的特点，把神经元设计成三个维度 ： width, height, depth(注意这个depth不是神经网络的深度，而是用来描述神经元的) 。比如输入的图片大小是 32 × 32 × 3 (rgb)，那么输入神经元就也具有 32×32×3 的维度。 2.卷积神经网络分层卷积层—&gt;激活层—&gt;池化层—&gt;全连接层##### 卷积层：​ 卷积神经网路中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过反向传播算法优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网络能从低级特征中迭代提取更复杂的特征。 激活层：​ 通过Relu激活函数可以增加网络的非线性分割能力 池化层：​ 用来减少数据量 3.填充算法SAME：​ 当filter过滤到边缘的时候自动填充0 - 越过边缘取样，取样的面积和输入的图像像素长度和宽度相同VALID： 当filter过滤到边缘的时候跳过，所有会丢失部分特征，取样的面积和输入的图像像素长度和宽度会略小 计算公式为：输入体积大小h1 * w1 * d1 ，filter数量为k,filter大小为f,步长为s,填充大小为p 那么 h2=(h1-f+2p)/s+1 w2=(w1-f+2p)/s+1 d2=k 4.API介绍12#卷积层tf.nn.conv2d(input,filter,strides=,padding=,name=None) input: 输入的4-D张量，具有[batch,height,width,channel],类型为float32，或者float64([每批数,图片长度，图片宽度，图片通道数])filter:指定过滤器4-D随机初始化的张量：,类型为float32或者float64([过滤器长度，过滤器宽度，输入的通道数，输出的通道数])，——- 注意需要传入4-D张量，而不是简单的填入维度strides:strides=[1,stride,stride,1],步长（[1，长上步长，宽上步长，1]）padding=:”SAME”，“VALID”，使用的填充算法类型.12#relu激活函数tf.nn.relu(feacutes,name=None) features:卷积后加上偏置的结果return :结果12#池化tf.nn.max_pool(value,ksize=,strides=,padding=,name=None) value:4-D tensor形状[batch,height,width,channels]，也就是激活函数处理后的结果ksize池化窗口大小，[1,ksize,ksize,1]步长大小,[1,strides,strides,1]padding :”SAME”,”VALID”填充算法5.演示两层卷积神经网络识别手写数字​ 1.输入数据形状[None,784] ##### 第一层卷积神经网络卷积层​ 2.因为卷积API的input即输入为4-D张量，所以动态改变形状改为[None,28,28,1],使用32个filter的5*5大小，步长为1，SAME填充算法的过滤器且卷积后输出的形状为[None,28,28,32]，有多少个filter就有多少个偏置所以为32，权重就是每个filter的值. ###### 激活层​ 3.不改变数据大小，所以输出还是[None,28,28,32] ###### 池化​ 4.大小为2 *2，步长为2，填充算法为“SAME”(这里SAME后的大小比原来小)将[None,28,28,32]的图像池化为[None,14,14,32] 第一层卷积神经网络卷积层​ 2.因为卷积API的input即输入为4-D张量，输入为[None,14,14,32],使用64个filter的5*5大小，步长为1，SAME填充算法的过滤器且卷积后输出的形状为[None,14,14,64]，有多少个filter就有多少个偏置所以为64,权重就是每个filter的值. 激活层​ 3.不改变数据大小，所以输出还是[None,14,14,64] 池化​ 4.大小为2*2，步长为2，填充算法为“SAME”(这里SAME后的大小比原来小)将[None,14,14,64]的图像池化为[None,7,7,64] 全连接层​ 因为池化后数据为[None,7,7,64],而且矩阵乘法只能处理二维数据，所以动态调整形状为[None,7 * 7 *64],又因为输出是10种结果，所以全连接层为[7 * 7 *64,10],所以权重[7 * 7 *64,10]偏置有10个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475##### 两层卷积神经网络识别手写数字import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datadef getVarRandom_normal(shape): return tf.Variable(tf.random_normal(shape=shape,mean=0.0,stddev=1.0))#搭建神经网络def conV(): #1.定义占位符 xDist=tf.placeholder(tf.float32,[None,784]) yTrue=tf.placeholder(tf.float32,[None,10]) #2.搭建第一层卷积网络 filter 有32个 大小为5*5，步长为1， with tf.name_scope("con1"): xshape=tf.reshape(xDist,[-1,28,28,1]) filterW=getVarRandom_normal([5,5,1,32]) b=getVarRandom_normal([32]) #卷积层 con1=tf.nn.conv2d(xshape,filterW,strides=[1,1,1,1],padding="SAME")+b #激活层 relu=tf.nn.relu(con1) #池化层 大小为2*2 步长为2 [None,28,28,32]----&gt;[None,14,14,32] pool=tf.nn.max_pool(relu,ksize=[1,2,2,1],strides=[1,2,2,1],padding="SAME") #3.搭建第二层卷积网络 filter有64个，大小为5*5，步长为1 with tf.name_scope("con2"): filterW2=getVarRandom_normal([5,5,32,64]) b1=getVarRandom_normal([64]) #卷积层 con2=tf.nn.conv2d(pool,filterW2,strides=[1,1,1,1],padding="SAME")+b1 #激活层 relu2=tf.nn.relu(con2) #池化层 pool2=tf.nn.max_pool(relu2,ksize=[1,2,2,1],strides=[1,2,2,1],padding="SAME") #全连接层 w3=getVarRandom_normal([7*7*64,10]) b3=getVarRandom_normal([10]) shape = tf.reshape(pool2, [-1, 7*7*64]) grop=tf.matmul(shape,w3)+b3 return xDist,yTrue,gropif __name__ == "__main__": xDist,yTrue,opInt=conV() mnist = input_data.read_data_sets("./MNIST_data", one_hot=True) #计算平均交叉熵损失 loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=yTrue,logits=opInt)) #反向传播 trainOp=tf.train.GradientDescentOptimizer(0.00001).minimize(loss) #计算准确率 equal_list = tf.equal(tf.argmax(yTrue, 1), tf.argmax(opInt, 1)) acuracy = tf.reduce_mean(tf.cast(equal_list, tf.float32)) initOp = tf.global_variables_initializer() # 6.开启会话开始训练 with tf.Session() as sess: sess.run(initOp) for i in range(3000000): # 取出特征值和目标值 minstX, minstY = mnist.train.next_batch(50) sess.run(trainOp, feed_dict=&#123;xDist: minstX, yTrue: minstY&#125;) print("%d步准确率%f" % (i, sess.run(acuracy, feed_dict=&#123;xDist: minstX, yTrue: minstY&#125;)))]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>语言</tag>
        <tag>Python</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用入门]]></title>
    <url>%2F2018%2F05%2F27%2FGit%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Git使用入门前言​ 之前在网上接私活的时候使用了一下github,当时一下都惊艳到我了，（见识短╮(╯▽╰)╭），当时因为用的c#语言开发，使用的vs2017，他继承的那个git是中文的，特别好用，但是也导致了我啥也没学会，正好今天有空，就填补一下这个大坑吧 简介​ 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。（百度粘贴过来的，╮(╯▽╰)╭） 概念介绍​ git可以将工作区（Working Directory）的代码放到暂存区，最后统一把暂存区的代码合并到我们的git仓库中（这个仓库其实还是本地的仓库）。（╮(╯▽╰)╭我觉得解释的很不清楚） 12345st=&gt;start: git仓库e=&gt;end: 工作空间item=&gt;subroutine: 暂存区e-&gt;item-&gt;st 使用git工具要先进行初始化1234git config --global user.name "yang295513"//这个name一定要填写github上面的名称git config --global user.email "15993343299@163.com"//对应的邮箱//这个不是必须的但是新建git仓库就要进去进行这个命令，然后git工具会生成一个隐藏文件.gitgit init 就这样，之后就可以愉快的玩耍了 指令介绍 指令名 作用 注释 git status 显示当前文件的状态 用来确定文件在三个区的位置 git add 文件名.文件类型 将文件添加到暂存区 把工作空间的文件添加到暂存区 git commit -m “提交描述” 把暂存区所有的文件提交到仓库 提交描述用来标识文件的改动，也就是说本次提交的注释 git push 将本地代码提交到git远程 仓库中 将本地代码提交到git远程仓库中 git clone 仓库地址 将远程git的代码下载下来 案例演示首先这里新建了一个演示项目 然后我们通过git clone命令把这个项目下载下来，其中项目的链接在这里： 然后我们使用git工具克隆下来 这是本地生成的文件 其中那个.git的隐藏文件就隐藏着配置信息 githubTest就是咱们的测试信息 githubTest文件里面的信息可以看到和我们的远端github仓库中的一模一样 接下来我们在本地创建一个Test.java的类，来模拟我们的项目 然后使用git add命令和git commit -m和git push命令依次提交到git远端仓库中 然后去github来查看是否已经被提交了 完美,收场，学习新东西去不不不，还有一些使用细节得介绍一下 你提交了那些文件那些文件才会被替换，也就是说你同时修改了A和B文件，那三连 都是针对B文件的，那么你提交到远端git仓库在只会修改你提交的B文件，没有B文件进行创建,有B文件更新 如果提交到远端失败的话，要注意是否是name和Email书写错误，或者说该仓库是priavte（私有的）如果是私有的去对应配置文件下修改账号密码即可]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
      </tags>
  </entry>
</search>
