<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ThreadLocal详解]]></title>
    <url>%2F2020%2F04%2F18%2Fthreadlocal-xiang-jie%2F</url>
    <content type="text"><![CDATA[ThreadLocal简介 多线程访问同一个共享变量的时候容易产生并发问题，为了保证线程安全除了使用锁的方式，使用ThreadLocal达到线程隔离的效果，也是一种不错的方案 功能 传递数据，因为同一个线程在任何情况下获取到的都是同一个对象 线程隔离，不同线程拿到的对象都是该线程放进去的对象 演示public class ThreadLocalTest { public static void main(String[] args) { Threadmsg threadmsg = new Threadmsg(); for (int i = 0; i &lt;100 ; i++) { new Thread(()->{ threadmsg.setName(Thread.currentThread().getName()); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+"取出--->"+threadmsg.getName()); }).start(); } } } class Threadmsg{ private ThreadLocal&lt;String> threadLocal=new ThreadLocal&lt;>(); private String name; public String getName() { return threadLocal.get(); } public void setName(String name) { threadLocal.set(name); } } 最后实现了线程隔离 使用synchronized实现线程隔离public class ThreadLocalTest { public static void main(String[] args) { Threadmsg threadmsg = new Threadmsg(); for (int i = 0; i &lt;100 ; i++) { new Thread(()->{ synchronized(ThreadLocalTest.class){ threadmsg.setName(Thread.currentThread().getName()); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName()+"取出--->"+threadmsg.getName()); } }).start(); } } } class Threadmsg{ private String name; public String getName() { return name; } public void setName(String name) { this.name=name; } } ThreadLocal与Synchronized的区别相同：ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。不同：Synchronized同步机制采用了“以时间换空间”的方式，仅提供一份变量，让不同的线程排队访问；而ThreadLocal采用了“以空间换时间”的方式，每一个线程都提供了一份变量，因此可以同时访问而互不影响。 以时间换空间-&gt;即枷锁方式，某个区域代码或变量只有一份节省了内存，但是会形成很多线程等待现象，因此浪费了时间而节省了空间。以空间换时间-&gt;为每一个线程提供一份变量，多开销一些内存，但是呢线程不用等待，可以一起执行而相互之间没有影响。 小结：ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。 常用方法 方法 作用 public ThreadLocal&lt; T &gt;() 构造方法 public T get() 获取当前线程绑定的数据 public void set(T value) 把value绑定给当前线程 public void remove() 移除当前线程绑定的数据 ThreadLocal原理Thread类中有两个变量threadLocals和inheritableThreadLocals，二者都是ThreadLocal内部类ThreadLocalMap类型的变量，我们通过查看内部内ThreadLocalMap可以发现实际上它类似于一个HashMap。 在默认情况下，每个线程中的这两个变量都为null ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; 当线程第一次调用ThreadLocal的set或者get方法的时候才会创建他们。除此之外，和我所想的不同的是，每个线程的本地变量不是存放在ThreadLocal实例中，而是放在调用线程的ThreadLocals变量里面。也就是说，ThreadLocal类型的本地变量是存放在具体的线程空间上，其本身相当于一个装载本地变量的工具壳，通过set方法将value添加到调用线程的threadLocals中，当调用线程调用get方法时候能够从它的threadLocals中取出变量。如果调用线程一直不终止，那么这个本地变量将会一直存放在他的threadLocals中，所以不使用本地变量的时候需要调用remove方法将threadLocals中删除不用的本地变量。 ThreadLocal set()方法 public void set(T value) { //获取当前线程实例 Thread t = Thread.currentThread(); //获取当前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); //map存在直接设置 if (map != null) //存入的key是ThreadLocal的实例对象 map.set(this, value); else//map不存在则创建map。将value设置到map createMap(t, value); } 源码解析： 获取当前线程的成员变量Map Map不为空：重新将ThreadLocal对象作为key和Value副本放入Map中 Map为空：对线程成员变量ThreadLocalMap进行初始化创建，并将ThreadLocal对象和Value副本放入Map中 ThreadLocal get()方法 public T get() { //获取当前线程实例 Thread t = Thread.currentThread(); //拿到当前线程实例的ThreadLocalMap ThreadLocalMap map = getMap(t); //如果map不为空就查找map中本地变量的值 if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings("unchecked") T result = (T)e.value; return result; } } //如果map为空，或者Entry为null，则初始化当前线程的threadLocals变量 return setInitialValue(); } private T setInitialValue() { T value = initialValue();//获取null Thread t = Thread.currentThread();//拿到当前线程 ThreadLocalMap map = getMap(t); //判断map是否存在 if (map != null)//存在设置value为null map.set(this, value); else//不存在创建map,并设置value为null createMap(t, value); return value; } 源码解析： 获取当前线程的ThreadLocalMap对象threadLocals（实际储存副本值的Map） Map不为空的话，从Map中获取线程储存的K-V Entry结点，然后从Entry结点中获取Value副本值返回 Map为空的话，返回初始值null，之后还需向Map中添加value为null的键值对，避免空指针异常 remove()方法 public void remove() { //获取当前线程绑定的threadLocals ThreadLocalMap m = getMap(Thread.currentThread()); //如果map不为null，就移除当前线程中指定ThreadLocal实例的本地变量 if (m != null) m.remove(this); } ThreadLocalMap详解 ThreadLocalMap提供了一种为ThreadLocal定制的高效实现，并且自带一种基于弱引用的垃圾清理机制。 存储结构（Entry节点）ThreadLocalMap这个map并没有实现java提供的map，而是作者直接开发了一套map。 static class Entry extends WeakReference&lt;java.lang.ThreadLocal&lt;?>> { // 往ThreadLocal里实际塞入的值 Object value; Entry(java.lang.ThreadLocal&lt;?> k, Object v) {//传入的类型只能是ThreadLocal类型 super(k); value = v; } } Entry便是ThreadLocalMap里定义的节点，它继承了WeakReference类，定义了一个类型为Object的value，用于存放塞到ThreadLocal里的值。说明这是一个弱引用 为什么要用弱引用呢？因为如果这里使用普通的key-value形式来定义存储结构，实质上就会造成节点的生命周期与线程强绑定，只要线程没有销毁，那么节点在GC分析中一直处于可达状态，没办法被回收，而程序本身也无法判断是否可以清理节点。弱引用是Java中四档引用的第三档，比软引用更加弱一些，如果一个对象没有强引用链可达，那么一般活不过下一次GC。当某个ThreadLocal已经没有强引用可达，则随着它被垃圾回收，在ThreadLocalMap里对应的Entry的键值会失效，这为ThreadLocalMap本身的垃圾清理提供了便利。 成员变量/** * 初始容量，必须为2的幂 */ private static final int INITIAL_CAPACITY = 16; /** * Entry表，大小必须为2的幂 */ private Entry[] table; /** * 表里entry的个数 */ private int size = 0; /** * 重新分配表大小的阈值，默认为0 */ private int threshold; 可以看到，ThreadLocalMap维护了一个Entry表或者说Entry数组，并且要求表的大小必须为2的幂，同时记录表里面entry的个数以及下一次需要扩容的阈值。显然这里会产生一个问题，为什么必须是2的幂？ /** * 设置resize阈值以维持最坏2/3的装载因子 */ private void setThreshold(int len) { threshold = len * 2 / 3; } /** * 环形意义的下一个索引 */ private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0); } /** * 环形意义的上一个索引 */ private static int prevIndex(int i, int len) { return ((i - 1 >= 0) ? i - 1 : len - 1); } ThreadLocal需要维持一个最坏2/3的负载因子，对于负载因子相信应该不会陌生，在HashMap中就有这个概念。ThreadLocal有两个方法用于得到上一个/下一个索引，注意这里实际上是环形意义下的上一个与下一个,由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。 ThreadLocalMap维护了Entry环形数组，数组中元素Entry的逻辑上的key为某个ThreadLocal对象（实际上是指向该ThreadLocal对象的弱引用），value为代码中该线程往该ThreadLoacl变量实际塞入的值。 构造方法/** * 构造一个包含firstKey和firstValue的map。 * ThreadLocalMap是惰性构造的，所以只有当至少要往里面放一个元素的时候才会构建它。 */ ThreadLocalMap(java.lang.ThreadLocal&lt;?> firstKey, Object firstValue) { // 初始化table数组 table = new Entry[INITIAL_CAPACITY]; // 用firstKey的threadLocalHashCode与初始大小16取模得到哈希值 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); // 初始化该节点 table[i] = new Entry(firstKey, firstValue); // 设置节点表大小为1 size = 1; // 设定扩容阈值 setThreshold(INITIAL_CAPACITY); } 这个构造函数在set和get的时候都可能会被间接调用以初始化线程的ThreadLocalMap。 哈希函数重点看一下上面构造函数中的int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);这一行代码。 ThreadLocal类中有一个被final修饰的类型为int的threadLocalHashCode，它在该ThreadLocal被构造的时候就会生成，相当于一个ThreadLocal的ID。 /* * 生成hash code间隙为这个魔数，可以让生成出来的值或者说ThreadLocal的ID较为均匀地分布在2的幂大小的数组中。 */ private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } getEntry方法private Entry getEntry(ThreadLocal&lt;?> key) { // 根据key这个ThreadLocal的ID来获取索引，也即哈希值 int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; // 对应的entry存在且未失效且弱引用指向的ThreadLocal就是key，则命中返回 if (e != null &amp;&amp; e.get() == key) { return e; } else { // 因为用的是线性探测，所以往后找还是有可能能够找到目标Entry的。 return getEntryAfterMiss(key, i, e); } } /* * 调用getEntry未直接命中的时候调用此方法 */ private Entry getEntryAfterMiss(ThreadLocal&lt;?> key, int i, Entry e) { Entry[] tab = table; int len = tab.length; // 基于线性探测法不断向后探测直到遇到空entry。 while (e != null) { ThreadLocal&lt;?> k = e.get(); // 找到目标 if (k == key) { return e; } if (k == null) { // 该entry对应的ThreadLocal已经被回收，调用expungeStaleEntry来清理无效的entry expungeStaleEntry(i); } else { // 环形意义下往后面走 i = nextIndex(i, len); } e = tab[i]; } return null; } /** * 这个函数是ThreadLocal中核心清理函数，它做的事情很简单： * 就是从staleSlot开始遍历，将无效（弱引用指向对象被回收）清理，即对应entry中的value置为null，将指向这个entry的table[i]置为null，直到扫到空entry。 * 另外，在过程中还会对非空的entry作rehash。 * 可以说这个函数的作用就是从staleSlot开始清理连续段中的slot（断开强引用，rehash slot等） */ private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; // 因为entry对应的ThreadLocal已经被回收，value设为null，显式断开强引用 tab[staleSlot].value = null; // 显式设置该entry为null，以便垃圾回收 tab[staleSlot] = null; size--; Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?> k = e.get(); // 清理对应ThreadLocal已经被回收的entry if (k == null) { e.value = null; tab[i] = null; size--; } else { /* * 对于还没有被回收的情况，需要做一次rehash。 * * 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i， * 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。 */ int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) { tab[i] = null; /* * 在原代码的这里有句注释值得一提，原注释如下： * * Unlike Knuth 6.4 Algorithm R, we must scan until * null because multiple entries could have been stale. * * 这段话提及了Knuth高德纳的著作TAOCP（《计算机程序设计艺术》）的6.4章节（散列） * 中的R算法。R算法描述了如何从使用线性探测的散列表中删除一个元素。 * R算法维护了一个上次删除元素的index，当在非空连续段中扫到某个entry的哈希值取模后的索引 * 还没有遍历到时，会将该entry挪到index那个位置，并更新当前位置为新的index， * 继续向后扫描直到遇到空的entry。 * * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即 * 有效（value未回收），无效（value已回收），空（entry==null）。 * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。 * * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot， * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。 */ while (tab[h] != null) { h = nextIndex(h, len); } tab[h] = e; } } } // 返回staleSlot之后第一个空的slot索引 return i; } 我们来回顾一下从ThreadLocal读一个值可能遇到的情况：根据入参threadLocal的threadLocalHashCode对表容量取模得到index 如果index对应的slot就是要读的threadLocal，则直接返回结果 调用getEntryAfterMiss线性探测，过程中每碰到无效slot，调用expungeStaleEntry进行段清理；如果找到了key，则返回结果entry 没有找到key，返回null set方法private void set(ThreadLocal&lt;?> key, Object value) { Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len - 1); // 线性探测 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal&lt;?> k = e.get(); // 找到对应的entry if (k == key) { e.value = value; return; } // 替换失效的entry if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz >= threshold) { rehash(); } } private void replaceStaleEntry(ThreadLocal&lt;?> key, Object value, int staleSlot) { Entry[] tab = table; int len = tab.length; Entry e; // 向前扫描，查找最前的一个无效slot int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) { if (e.get() == null) { slotToExpunge = i; } } // 向后遍历table for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?> k = e.get(); // 找到了key，将其与无效的slot交换 if (k == key) { // 更新对应slot的value值 e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; /* * 如果在整个扫描过程中（包括函数一开始的向前扫描与i之前的向后扫描） * 找到了之前的无效slot则以那个位置作为清理的起点， * 否则则以当前的i作为清理起点 */ if (slotToExpunge == staleSlot) { slotToExpunge = i; } // 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; } // 如果当前的slot已经无效，并且向前扫描过程中没有无效slot，则更新slotToExpunge为当前位置 if (k == null &amp;&amp; slotToExpunge == staleSlot) { slotToExpunge = i; } } // 如果key在table中不存在，则在原地放一个即可 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理） if (slotToExpunge != staleSlot) { cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); } } /** * 启发式地清理slot, * i对应entry是非无效（指向的ThreadLocal没被回收，或者entry本身为空） * n是用于控制控制扫描次数的 * 正常情况下如果log n次扫描没有发现无效slot，函数就结束了 * 但是如果发现了无效的slot，将n置为table的长度len，做一次连续段的清理 * 再从下一个空的slot开始继续扫描 * * 这个函数有两处地方会被调用，一处是插入的时候可能会被调用，另外个是在替换无效slot的时候可能会被调用， * 区别是前者传入的n为元素个数，后者为table的容量 */ private boolean cleanSomeSlots(int i, int n) { boolean removed = false; Entry[] tab = table; int len = tab.length; do { // i在任何情况下自己都不会是一个无效slot，所以从下一个开始判断 i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) { // 扩大扫描控制因子 n = len; removed = true; // 清理一个连续段 i = expungeStaleEntry(i); } } while ((n >>>= 1) != 0); return removed; } private void rehash() { // 做一次全量清理 expungeStaleEntries(); /* * 因为做了一次清理，所以size很可能会变小。 * ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容， * threshold默认为len*2/3，所以这里的threshold - threshold / 4相当于len/2 */ if (size >= threshold - threshold / 4) { resize(); } } /* * 做一次全量清理 */ private void expungeStaleEntries() { Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) { Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) { /* * 个人觉得这里可以取返回值，如果大于j的话取了用，这样也是可行的。 * 因为expungeStaleEntry执行过程中是把连续段内所有无效slot都清理了一遍了。 */ expungeStaleEntry(j); } } } /** * 扩容，因为需要保证table的容量len为2的幂，所以扩容即扩大2倍 */ private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) { Entry e = oldTab[j]; if (e != null) { ThreadLocal&lt;?> k = e.get(); if (k == null) { e.value = null; } else { // 线性探测来存放Entry int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) { h = nextIndex(h, newLen); } newTab[h] = e; count++; } } } setThreshold(newLen); size = count; table = newTab; } 我们来回顾一下ThreadLocal的set方法可能会有的情况 探测过程中slot都不无效，并且顺利找到key所在的slot，直接替换即可 探测过程中发现有无效slot，调用replaceStaleEntry，效果是最终一定会把key和value放在这个slot，并且会尽可能清理无效slot 在replaceStaleEntry过程中，如果找到了key，则做一个swap把它放到那个无效slot中，value置为新值 在replaceStaleEntry过程中，没有找到key，直接在无效slot原地放entry 探测没有发现key，则在连续段末尾的后一个空位置放上entry，这也是线性探测法的一部分。放完后，做一次启发式清理，如果没清理出去key，并且当前table大小已经超过阈值了，则做一次rehash，rehash函数会调用一次全量清理slot方法也即expungeStaleEntries，如果完了之后table大小超过了threshold - threshold / 4，则进行扩容2倍 ThreadLocal与内存泄露关于ThreadLocal是否会引起内存泄漏也是一个比较有争议性的问题，其实就是要看对内存泄漏的准确定义是什么。认为ThreadLocal会引起内存泄漏的说法是因为如果一个ThreadLocal对象被回收了，我们往里面放的value对于【当前线程-&gt;当前线程的threadLocals(ThreadLocal.ThreadLocalMap对象）-&gt;Entry数组-&gt;某个entry.value】这样一条强引用链是可达的，因此value不会被回收。认为ThreadLocal不会引起内存泄漏的说法是因为ThreadLocal.ThreadLocalMap源码实现中自带一套自我清理的机制。 之所以有关于内存泄露的讨论是因为在有线程复用如线程池的场景中，一个线程的寿命很长，大对象长期不被回收影响系统运行效率与安全。如果线程不会复用，用完即销毁了也不会有ThreadLocal引发内存泄露的问题。《Effective Java》一书中的第6条对这种内存泄露称为unintentional object retention(无意识的对象保留）。 当我们仔细读过ThreadLocalMap的源码，我们可以推断，如果在使用的ThreadLocal的过程中，显式地进行remove是个很好的编码习惯，这样是不会引起内存泄漏。那么如果没有显式地进行remove呢？只能说如果对应线程之后调用ThreadLocal的get和set方法都有很高的概率会顺便清理掉无效对象，断开value强引用，从而大对象被收集器回收。 但无论如何，我们应该考虑到何时调用ThreadLocal的remove方法。一个比较熟悉的场景就是对于一个请求一个线程的server如tomcat，在代码中对web api作一个切面，存放一些如用户名等用户信息，在连接点方法结束后，再显式调用remove。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS详解]]></title>
    <url>%2F2020%2F04%2F16%2Faqs-xiang-jie%2F</url>
    <content type="text"><![CDATA[Lock接口锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。 class X{ //定义锁对象，其中构造方法如果传入true就是公平锁，否则是非公平锁 private final ReentrantLock lock=new ReentrantLock(); //定义需要保证线程安全的方法 public void m(){ //加锁 lock.lock(); try{ //...method body } //使用finally块来保证释放锁 finally{ lock.unlock(); } } } 使用Reentrantlock可以进行尝试锁定tryLock()，这样无法锁定，或者在指定时间内无法锁定，返回false； 使用ReentrantLock还可以调用lockInterruptibly()方法，可以对线程interrupt()方法做出响应，在一个线程等待锁的过程中，可以被打断，打断后会抛异常。 手动实现一个自旋锁方案一package thread; import java.util.concurrent.atomic.AtomicInteger; /** * @author yang * @date 2020/4/16 下午 4:44 * 实现一个自旋锁 */ public class SpinLock { static AtomicInteger atomicInteger=new AtomicInteger(0); static Integer count=0;//测试数据,来测试线程是否安全 //加锁,如果获取不到锁就进行忙等待获取自旋锁 public static void lock(){ //自旋获取锁 while (!atomicInteger.compareAndSet(0,1)){//如果设置不成功则一直处于忙等状态 System.out.println(Thread.currentThread().getName()+"自旋获取锁失败!正在重新尝试"); } System.out.println(Thread.currentThread().getName()+"获取到锁"); } //解锁 public static void unlock(){ if(!atomicInteger.compareAndSet(1, 0)){ System.out.println("没有加锁无法解锁"); }else { System.out.println(Thread.currentThread().getName()+"解锁成功"); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(() -> {//假设线程一获取到了锁但是过了很久才释放锁. for (int i = 0; i &lt;10 ; i++) { lock(); count++; try { Thread.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } unlock(); } }); Thread thread1 = new Thread(() -> { for (int i = 0; i &lt;10 ; i++) { lock(); count++; unlock(); } }); thread.start(); thread1.start(); thread.join(); thread1.join(); System.out.println(count);//打印最终结果 } } 打印输出一部分 Thread-0获取到锁 Thread-1自旋获取锁失败!正在重新尝试 Thread-1自旋获取锁失败!正在重新尝试 Thread-1自旋获取锁失败!正在重新尝试 Thread-1自旋获取锁失败!正在重新尝试 Thread-1自旋获取锁失败!正在重新尝试 Thread-1自旋获取锁失败!正在重新尝试 Thread-1自旋获取锁失败!正在重新尝试 Thread-1自旋获取锁失败!正在重新尝试 Thread-1自旋获取锁失败!正在重新尝试 ...我们可以看到由于Thread-0拿到了锁并没有释放，结果导致Thread-1大量进行自旋操作，这种操作无疑是非常浪费性能的，所以 缺点：耗费CPU资源，没有竞争到锁的线程会一直占用CPU资源进行CAS操作。 方案二Java提供了一个较为底层的并发工具类：LockSupport，可以让线程停止下来(阻塞)，还可以唤醒线程。 // 阻塞线程 LockSupport.park(Object blocker) // 唤醒线程 LockSupport.unpark(Thread thread) 这两个方法均来自java最牛逼的类Unsafe package thread.demoone; import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.atomic.AtomicInteger; import java.util.concurrent.locks.LockSupport; /** * @author yang * @date 2020/4/16 下午 5:14 */ public class SpinLock01 { static AtomicInteger atomicInteger=new AtomicInteger(0); //阻塞队列 static ArrayBlockingQueue &lt;Thread> parkQueue = new ArrayBlockingQueue&lt;Thread>(10); static Integer count=0;//测试数据,来测试线程是否安全 //加锁,如果获取不到锁就进行忙等待获取自旋锁 public static void lock() throws InterruptedException { //自旋获取锁 while (!atomicInteger.compareAndSet(0,1)){//如果设置不成功则一直处于忙等状态 System.out.println(Thread.currentThread().getName()+"自旋获取锁失败!进入阻塞队列"); park(); } System.out.println(Thread.currentThread().getName()+"获取到锁"); } public static void unlock(){ if(!atomicInteger.compareAndSet(1, 0)){ System.out.println("没有加锁无法解锁"); }else { unpark();//唤醒一个阻塞队列中的线程 System.out.println(Thread.currentThread().getName()+"解锁成功,唤醒下一个线程"); } } //解锁这个操作要保证是原子操作,因为想不到什么方法能保证是原子性操作无奈只能使用synchronized了. public static void park() throws InterruptedException { parkQueue.put(Thread.currentThread()); LockSupport.park(Thread.currentThread());//阻塞线程 } public static synchronized void unpark(){ //阻塞队列中有线程则唤醒 if (!parkQueue.isEmpty()){ Thread poll = parkQueue.poll();//唤醒线程 LockSupport.unpark(poll); } } public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(() -> {//假设线程一获取到了锁但是并没有及时释放锁. for (int i = 0; i &lt;10 ; i++) { try { lock(); count++; // Thread.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } unlock(); } }); Thread thread1 = new Thread(() -> { for (int i = 0; i &lt;10 ; i++) { try { lock(); count++; Thread.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } unlock(); } }); thread.start(); thread1.start(); Thread.sleep(100); System.out.println(count); thread.join(); thread1.join(); System.out.println(count);//打印最终结果 } } 上面的代码有点问题，有概率会导致死锁，或者出现线程安全问题，目前还没有啥好办法，大家全当伪代码描述看吧。 死锁的原因就是因为线程park的时候不会释放锁。 队列同步器AQS队列同步器AbstractQueuedSynchronizer（AQS）是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。 AQS的实现FIFO队列同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。 AQS中的节点Node： static final class Node { // 等待状态，若值为-1，表示后继节点处于等待状态 volatile int waitStatus; // 前一个节点 volatile Node prev; // 下一个节点 volatile Node next; // 节点绑定线程 volatile Thread thread; } AQS属性 public abstract class AbstractQueuedSynchronizer { // 等待队列头结点 private transient volatile Node head; // 等待队列尾结点 private transient volatile Node tail; // 状态 private volatile int state; } 调用aquire(1)方法 public final void acquire(int arg) { // 尝试获取同步器tryAcquire false--> 入队addWaiter --> park阻塞该线程acquireQueued if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); } 公平锁的tryAcquire（子类重写）： protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { // 如果没有后继节点，把stata CAS置1，把exclusiveOwnerThread置为当前线程 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 可重入锁 else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); // 重入时 state + 1 setState(nextc); return true; } return false; } 判断是否有后续节点： public final boolean hasQueuedPredecessors() { Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread()); } 实例化一个Node： private Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // 维护一个链表，prev和next节点 Node pred = tail; if (pred != null) { // 把Node加入尾部 node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } enq(node); return node; } // 把Node加入队列，必要时初始化 private Node enq(final Node node) { // 自旋CAS // 当有大量的线程在同时入队的时候，同一时刻，只有一个线程能完整地完成这三步，而其他线程只能完成第一步，于是就出现了尾分叉. // 所有节点都会通过自旋不断的尝试入队，直到成功为止。 for (;;) { Node t = tail; if (t == null) { // Must initialize // 实例化一个Thread为null的Node，并赋值给AQS的头 if (compareAndSetHead(new Node())) tail = head; } else { // 把当前线程Node入队 node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 注：head指向的Node中的Thread永远为空，持有锁的线程不再在队列中。 acquireQueued 该方法是AQS的核心，addWaiter()将当前线程加入队列后，先自旋2次，使用acquireQueued()进行阻塞，中间可能被唤醒，但直到获取到资源后才返回，否则继续被park阻塞。 final boolean acquireQueued(final Node node, int arg) { boolean failed = true; try { boolean interrupted = false; for (;;) { final Node p = node.predecessor(); // 判断是否为第一个元素(队列中第二个Node) // 如果是第一个元素，自旋去获取锁，把当前节点置为head，把原head分离队列，方便GC if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return interrupted; } //阻塞当前线程park，获取不到的话自旋2次 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; } } finally { if (failed) cancelAcquire(node); } } // 把当前节点置为head，Thread置为null private void setHead(Node node) { head = node; node.thread = null; node.prev = null; } 判断是否需要阻塞： private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) { int ws = pred.waitStatus; if (ws == Node.SIGNAL) // 前一个线程节点的waitState=-1，可以阻塞了 return true; if (ws > 0) { /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do { node.prev = pred = pred.prev; } while (pred.waitStatus > 0); pred.next = node; } else { // 将前一个节点waitState设置为-1，目的是多一次自旋 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); } return false; } 阻塞当前线程： private final boolean parkAndCheckInterrupt() { LockSupport.park(this); return Thread.interrupted(); } 释放锁release(1)： public void unlock() { sync.release(1); } public final boolean release(int arg) { if (tryRelease(arg)) { Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) //唤醒第一个排队Node unparkSuccessor(h); return true; } return false; } protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; // state = 0时把OwnerThread设为null if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } 唤醒下一个节点： private void unparkSuccessor(Node node) { int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus > 0) { s = null; // 从后向前找 // 因为一个节点要能入队，则它的prev属性一定是有值的，但是它的next属性可能暂时还没有值。 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; } if (s != null) LockSupport.unpark(s.thread); } AQS的使用方法同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法getState()、setState(int newState)和compareAndSetState(int expect,int update))来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。 例如在ReentrantLock中，Sync为继承于AQS的静态内部类： abstract static class Sync extends AbstractQueuedSynchronizer{} AQS的接口同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。 同步器有三种核心方法，同步器中使用int变量表示同步状态，重写同步器的指定方法，需要调用这三种核心方法来访问或更新同步状态： int getState():获取同步状态的当前值void setState(int newState):设置同步状态的值boolean compareAndSetState(int expect, int update):使用CAS原子性地设置同步状态的值，当同步状态的当前值为expect时，将其设置为给定值（update）。AQS同步器可重写的方法包括独占式的获取或释放同步状态、共享式的获取或释放同步状态、同步器是否在独占模式下被线程占用，重写这几个方法是实现一个锁的核心。 boolean tryAcquire(int arg):独占式的获取同步状态，实现该方法需要先获取并判断同步状态是否符合预期，再通过CAS设置同步状态。（即使用compareAndSetState(expect, update)方法）。可用于实现Lock接口中的tryLock()方法。 boolean tryRelease(int arg):独占式的释放同步状态，等待获取同步状态的线程将有机会获取同步状态; int tryAcquireShared(int arg):共享式的获取同步状态，返回大于等于0表示获取成功，否则获取失败; boolean tryReleaseShared(int arg)： 共享式的释放同步状态; boolean isHeldExclusively()： 用于获取同步器是否在独占模式下被线程占用，一般用来表示是否被当前线程所独占。 AQS提供的模板方法供锁来调用： 共享式同步状态获取与释放以自定义同步组件——TwinsLock展示如何实现共享式锁： public class TwinsLock implements Lock { private final Sync sync = new Sync(2); private static final class Sync extends AbstractQueuedSynchronizer { Sync(int count) { if (count &lt;= 0) { throw new IllegalArgumentException(“count must large than zero.”); } setState(count); } public int tryAcquireShared(int reduceCount) { for (;;) { int current = getState(); int newCount = current - reduceCount; if (newCount &lt; 0 || compareAndSetState(current,newCount)) { return newCount; } } } public boolean tryReleaseShared(int returnCount) { for (;;) { int current = getState(); int newCount = current + returnCount; if (compareAndSetState(current, newCount)) { return true; } } } } public void lock() { sync.acquireShared(1); } public void unlock() { sync.releaseShared(1); } // 其他接口方法略 核心：调用AQS中的模板方法acquireShared()与releaseShared()，重写了tryAcquireShared与tryReleaseShared方法。 独占式超时获取同步状态通过调用同步器的doAcquireNanos(int arg, long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。 private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException { if (nanosTimeout &lt;= 0L) return false; final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return true; } // 计算还能等待多长时间 nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout > spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout);//最多让当前线程park这么久 if (Thread.interrupted()) throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程： 被unpark()； 被interrupt() 可打断的获取锁如果本线程是处于获取锁状态：调用线程的wait(),wait(long)或wait(long, int)会让它进入等待(阻塞)状态，或者调用线程的join(), join(long), join(long, int), sleep(long), sleep(long, int)也会让它进入阻塞状态。若线程在阻塞状态时，调用了它的interrupt()方法，那么它的中断状态会被清除并且会收到一个InterruptedException异常。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。 注意：synchronized和lock()在等待锁的时候无法被打断，而lockInterruptibly()可以被打断，抛出异常。 lockInterruptibly()的实现方法为： public void lockInterruptibly() throws InterruptedException { sync.acquireInterruptibly(1); } public final void acquireInterruptibly(int arg) throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg); } private void doAcquireInterruptibly(int arg) throws InterruptedException { final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try { for (;;) { final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) { setHead(node); p.next = null; // help GC failed = false; return; } if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 当park的时候被interrupt时，抛出异常 throw new InterruptedException(); } } finally { if (failed) cancelAcquire(node); } } 可以与tryAcquire()对比。 重入锁ReentrantLock可重入锁（也叫作递归锁），指的时同一线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。可重入锁最大的作用是避免死锁。 protected final boolean tryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { // 如果没有后继节点，把stata CAS置1，把exclusiveOwnerThread置为当前线程 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } // 可重入锁 else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); // 重入时 state + 1 setState(nextc); return true; } return false; } 可重入锁主要解决了两个问题： 线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。 锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。 公平与非公平锁ReentrantLock还可以实现非公平锁，其区别在于非公平锁在加锁时先进行了一次CAS获取锁的尝试，如果获取到锁，直接执行，不需要排队阻塞。 非公平锁： final void lock() { if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); } 公平锁： final void lock() { acquire(1); } 刚释放锁的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。 公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。 读写锁写锁是独占的，当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行。 读锁是共享的，多个线程可以共同读取数据。 一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。Java并发包提供读写锁的实现是ReentrantReadWriteLock。 读写锁使用案例： public class Cache { static Map&lt;String, Object> map = new HashMap&lt;String, Object>(); static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); static Lock r = rwl.readLock(); static Lock w = rwl.writeLock(); // 获取一个key对应的value public static final Object get(String key) { r.lock(); try { return map.get(key); } finally { r.unlock(); } } // 设置key对应的value，并返回旧的value public static final Object put(String key, Object value) { w.lock(); try { return map.put(key, value); } finally { w.unlock(); } } // 清空所有的内容 public static final void clear() { w.lock(); try { map.clear(); } finally { w.unlock(); } } } 读写锁的实现原理： 读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态。 如果在一个整型变量上维护多种状态，就一定需要按位切割使用这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写，划分方式如图（当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁）： 写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。 protected final boolean tryAcquire(int acquires) { /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ Thread current = Thread.currentThread(); int c = getState(); // 获取写锁状态值 int w = exclusiveCount(c); if (c != 0) { // (Note: if c != 0 and w == 0 then shared count != 0) if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) > MAX_COUNT) throw new Error("Maximum lock count exceeded"); // Reentrant acquire setState(c + acquires); return true; } if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true; } 读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。 protected final int tryAcquireShared(int unused) { /* * Walkthrough: * 1. If write lock held by another thread, fail. * 2. Otherwise, this thread is eligible for * lock wrt state, so ask if it should block * because of queue policy. If not, try * to grant by CASing state and updating count. * Note that step does not check for reentrant * acquires, which is postponed to full version * to avoid having to check hold count in * the more typical non-reentrant case. * 3. If step 2 fails either because thread * apparently not eligible or CAS fails or count * saturated, chain to version with full retry loop. */ Thread current = Thread.currentThread(); int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; int r = sharedCount(c); if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) { if (r == 0) { firstReader = current; firstReaderHoldCount = 1; } else if (firstReader == current) { firstReaderHoldCount++; } else { HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; } return 1; } return fullTryAcquireShared(current); } Condition接口任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。 使用方法： Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); public void conditionWait() throws InterruptedException { lock.lock(); try { condition.await(); } finally { lock.unlock(); } } public void conditionSignal() throws InterruptedException { lock.lock(); try { condition.signal(); // condition.signalAll(); } finally { lock.unlock(); } } 实现原理： ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。 等待队列： 等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。 在Object的监视器上，一个对象拥有一个同步队列和等待队列，而同步器拥有一个同步队列和多个等待队列。 等待await： 当前线程调用await()方法时，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。 ConditionObject的await()方法： public final void await() throws InterruptedException { if (Thread.interrupted()) throw new InterruptedException(); // 当前线程加入等待队列 Node node = addConditionWaiter(); // 释放同步状态，也就是释放锁 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) { LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } 调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。 通知signal()： 调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。 public final void signal() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); } 通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。成功获取同步状态之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。 Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
        <tag>自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程总结]]></title>
    <url>%2F2020%2F04%2F15%2Fbing-fa-bian-cheng-zong-jie%2F</url>
    <content type="text"><![CDATA[这篇文章只会梳理一下知识，并不会详细讲解每个知识点 上下文切换什么是上下文切换 CPU通过实践片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务的从保存到再加载的过程就是一次上下文切换。 如何减少上下文切换 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以我们可以避免使用锁，例如使用hash算法隔离不同线程的数据。 使用CAS算法，例如java的Atomic包的CAS算法来更新数据，就不需要加锁 使用最少线程。避免创建不需要的线程。 合理使用volatile变量实现多线程，volatile变量比synchronized的使用成本和执行成本更低，而且也不会引起线程的上下文切换和调度。 协程，在单线程里实现多任务的调度，并在单线程里面维持多个任务间的切换。 为什么单线程不一定比多线程慢在多线程的情况下，由于线程间的争抢，难免引入锁的机制，所以相比较单线程由于存在上下文切换，所以以至于单线程不一定比多线程慢。 在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段代码串行改成并发执行，由于受限于资源仍在串行执行，这个时候多线程不仅不会变快，反而会变慢 并发中关注的两个问题线程之间如何通信和线程之间如何同步 线程之间的通信机制有两种共享内存和消息传递 锁如何避免死锁 避免一个线程同时获取多个锁 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源 尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁机制 对于数据库锁，必须保证加锁和解锁必须在一个数据库连接里面，否则会出现解锁失败的情况 volatile volatile是轻量级的synchronizd，它可以保证共享变量的可见性，但不能保证该变量的原子性，并且volatile不会引起线程的上下文切换 》 volatile 官方定义java语言规范第3版对于volatile的定义如下： java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排它锁单独获取这个变量。 为什么能保证可见性呢凡是被volatile修饰的变量，要求每个线程在取的时候都必须到主内存中去取，写也要强制写入到主内存中。 JAVA内存模型为什么要进行指令重排序？ 在执行程序时，为了提高性能，编译期和处理器常常会对指令做重排序。 例如(只是大概演示重排序的作用，实际上可能并不是如此)x=0; y=0; x1=y; y1=x; 有如上代码如果没有指令重排序的话需要花费4条指令的时间 如果进行了重排序可以同时让两个处理器执行 CPU1 CPU2 x=0 y=0 x1=y y1=x 那么就可以不影响结果的情况下花费两个指令的时间。 指令重排序的种类 编译期优化的重排序 指令集并行的重排序，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应及其指令的执行顺序 内存系统的重排序 源代码—&gt;编译期优化重排序—&gt;指令级并行重排序—-&gt;内存系统重排序—&gt;最终执行的指令 happens-before简介 在JSR-133中使用happens-before的概念来阐述操作之间的内存可见性，如果一个操作执行的结构需要对另一个操作可见，那么这两个操作必须满足happens-before关系，这两个操作可以是同一个线程也可以是不同线程。 happens-before规则 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对于一个锁的解锁，happens-before于随后对于这个锁的加锁 volatile变量规则：对于一个volatile域的写，happens-before于任意后续这个volatile域的读 传递性：如果a happens-before b，且b happens-before c，那么a happens-before c。 注意 两个操作之间具有happens-before关系，并不意味着前一个操作一定在后一个操作之前！。而是前一个操作的结果对于后一个操作可见。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper环境搭建]]></title>
    <url>%2F2020%2F04%2F14%2Fzookeeper-huan-jing-da-jian%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[zookeeper入门]]></title>
    <url>%2F2020%2F04%2F14%2Fzookeeper-ru-men%2F</url>
    <content type="text"><![CDATA[简介 ZooKeeper是一个分布式的，开放源码的分布式应用程序分布式应用程序/9854429)协调服务，是Google的Chubby一个开源开源/246339)的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 通俗来讲 顾名思义 zookeeper 就是动物园管理员，他是用来管 hadoop（大象）、Hive(蜜蜂)、pig(小 猪)的管理员， Apache Hbase 和 Apache Solr 的分布式集群都用到了 zookeeper；Zookeeper: 是一个分布式的、开源的程序协调服务，是 hadoop 项目下的一个子项目。他提供的主要功 能包括：配置管理、名字服务、分布式锁、集群管理。 什么是强一致性和最终一致性 强一致性：在任何时刻所有的用户或者进程查询到的都是最近一次成功更新的数据。强一致性是程度最高一致性要求，也是最难实现的。关系型数据库更新操作就是这个案例。 最终一致性：和强一致性相对，在某一时刻用户或者进程查询到的数据可能都不同，但是最终成功更新的数据都会被所有用户或者进程查询到。当前主流的nosql数据库都是采用这种一致性策略。 CAP原则CAP原则又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。 CAP原则是NOSQL数据库的基石。 分布式系统的CAP理论：理论首先把分布式系统中的三个特性进行了如下归纳： 一致性（C）：一致性是指强一致性 可用性（A）：系统提供的服务一直处于可用状态，用户的操作请求在指定的响应时间内响应请求，超出时间范围，认为系统不可用 分区容忍性（P）：分布式系统在遇到任何忘了分区故障的时候，仍需要能保证对外提供一致性和可用性服务，除非是整个网络都发生故障。 总结 其中一致性指的是强一致性，并且在实现中只能同时满足cap中的两个特性，比如CA,和CP 一致性协议事务需要跨多个分布式节点时，为了保证事务的ACID特性，需要选举出一个协调者来协调分布式各个节点的调度，基于这个思想衍生了很多一致性协议： zookeeper的数据结构]]></content>
      <categories>
        <category>java</category>
        <category>分布式</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>框架</tag>
        <tag>分布式</tag>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql锁详解]]></title>
    <url>%2F2020%2F04%2F13%2Fmysql-suo-xiang-jie%2F</url>
    <content type="text"><![CDATA[什么是锁 锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是Mysql在服务器层和存储引擎层的的并发控制。 加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否是否已解除、释放锁等。 锁的分类按照锁的机制分类 共享锁（读锁）：其他事物可以读，但是不能写 排他锁（写锁）：其他事物不能读取，也不能写。 按照锁的粒度分类表锁（偏读）MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking） 行锁（偏写）InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。 页锁BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁 MyISAM 表锁读锁演示表结构-- 表，注意表的存储引擎 CREATE TABLE myLock( id INT NOT NULL primary key auto_increment, `name` VARCHAR(30) )engine myisam; -- 向表中插入数据 INSERT INTO myLock(name) VALUES('a'); INSERT INTO myLock(name) VALUES('b'); INSERT INTO myLock(name) VALUES('c'); INSERT INTO myLock(name) VALUES('d'); INSERT INTO myLock(name) VALUES('e'); INSERT INTO myLock(name) VALUES('f'); INSERT INTO myLock(name) VALUES('g'); 常用sql语法-- 查看所有表的锁状态 SHOW OPEN TABLES; -- 加锁 lock table &lt;表名> read(write),&lt;表名> read(write); -- 解除所有的锁 UNLOCK tables; 首先我们开启两个会话 首先我们在黑窗口上给myLock加一把读锁（共享锁） 读然后我们在黑窗口中查找myLock表中的数据 SELECT * FROM myLock; 我们可以看到能读取出数据 接下来我们开一个新的窗口，直接读myLock这个表 我们可以看到确实是可以读本表的，也就是确实是一个共享锁 读其他表我这个数据库中还有一个其他表，这个表其实是随意了，因为不影响结果 黑窗口读取其他表 SELECT * FROM user; 我们可以看到，上锁的那个会话在没有释放锁之前是不能读取其他表的，那么其他会话可以么？ 很显然，其他会话可以读取。 那如果我们还可以使用关联查询么？虽然不能读取其他表，我们投机取巧使用关联查询呢？ 很显然也是不可用的。 如果加了表锁那么就没有办法使用关联查询了么？ 我们给user表也加一个锁，在试试关联查询 很显然，如果想使用关联查询，那么所有被查询的表都要被加上锁 这里有个坑，加锁的时候要一步到位。 -- 第一种情况 lock table myLock read; lock table user read; -- 第二种情况 lock table myLock read,user read; -- 情况是不等价的，第一种情况在第二次给user添加锁的时候会释放myLock的锁 那么其他会话可以使用关联查询么？ 从上面可以看出可以使用关联查询。 写 我们可以看到，黑窗口在没有释放锁的时候，其他表在写操作会进入阻塞状态 当我们释放锁的时候，阻塞状态会立刻消失，从上面可以看出一共阻塞了45秒 MyISAM 表读锁总结 当我们使用了表读锁的时候，所有的线程都可以读，但是都不能写。 不是加锁的线程在写的时候会进入阻塞状态，来等待锁的释放 加锁的线程在不释放锁的时候是不能对没加锁的表进行查找的 如果当前线程使用了表读锁，而且还想进行关联查询，那么要对所有的表进行加锁 MyISAM 表读锁总结 一个线程开启了一个写锁，那么这个锁就是该线程独占的，其他线程对该表的操作都会处于阻塞状态 写一个线程开启了一个表写锁，那么这个线程不能操作其他没有加锁的表 InnoDB加锁方法： 意向锁是 InnoDB 自动加的， 不需用户干预。 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)； 对于普通 SELECT 语句，InnoDB 不会加任何锁； 事务可以通过以下语句显式给记录集加共享锁或排他锁： 共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。 排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁 隐式锁定： InnoDB在事务执行过程中，使用两阶段锁协议： 随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁； 锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。 显式锁定 ： select ... lock in share mode //共享锁 select ... for update //排他锁 select for update： 在执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X 锁），也就是说这个语句对应的锁就相当于update带来的效果。 select *** for update 的使用场景：为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到 for update 子句。 select lock in share mode ：in share mode 子句的作用就是将查找到的数据加上一个 share 锁，这个就是表示其他的事务只能对这些数据进行简单的select 操作，并不能够进行 DML 操作。select *** lock in share mode 使用场景：为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是最新的数据，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据 使用了 in share mode 的方式上了 S 锁。 性能影响：select for update 语句，相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。select lock in share mode 语句是一个给查找的数据上一个共享锁（S 锁）的功能，它允许其他的事务也对该数据上S锁，但是不能够允许对该数据进行修改。如果不及时的commit 或者rollback 也可能会造成大量的事务等待。 for update 和 lock in share mode 的区别： 前一个上的是排他锁（X 锁），一旦一个事务获取了这个锁，其他的事务是没法在这些数据上执行 for update ；后一个是共享锁，多个事务可以同时的对相同数据执行 lock in share mode。 InnoDB锁模式：InnoDB 实现了以下两种类型的行锁： 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁： 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。 InnoDB行锁首先行锁是innodb默认的锁，但是在筛选条件里面没有索引字段时就会把整个表锁住. 行锁读锁：允许其他线程上读锁，但是不允许上写锁。 演示黑窗口开启一个事务修改id为1， 另一个窗口同样修改id为2的,结构可以修改成功，如果这两个窗口修改的是同一条数据，那么后修改的会进入阻塞状态，说明是一个行锁。 InnoDB 行锁实现方式： InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！ 不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。 只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时， 别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。 由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。 锁退化到表锁请注意这个表结构只有id有索引，并且吧这个表的引擎改为InnoDB InnoDB默认的行锁可以使得操作不同行时不会产生相互影响、不会阻塞，从而很好的解决了多事务和并发的问题。但是，那得基于一个前提，即 Where 条件中使用上了索引；反之，如果没有使用上索引，则是全表扫描、全部阻塞。 首先黑窗口一开启一个事务，并且where条件使用一个非索引字段来修改 此时另一个窗口也修改其中的任意一条非同行数据 发现另一个窗口处于阻塞状态。 还有一个隐藏问题如果我们的name字段也有索引那么 update myLock set id=111 where name="b"//使用到了索引 update myLock set id=111 where name=b//没有使用到索引，还是会行锁变表锁 因为涉及到了自动类型转换导致没有使用到索引 总结 没有索引或者索引失效时，InnoDB 的行锁变表锁 原因：Mysql 的行锁是通过索引实现的！ 间隙锁间隙锁（Gap Lock）是Innodb在可重复读提交下为了解决幻读问题时引入的锁机制， 幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的 加锁规则 加锁的基本单位是（next-key lock)他是前开后闭原则 插叙过程中访问的对象会增加锁 索引上的等值查询–给唯一索引加锁的时候，next-key lock升级为行锁 索引上的等值查询–向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁 唯一索引上的范围查询会访问到不满足条件的第一个值为止 间隙的范围根据检索条件向下寻找最靠近检索条件的记录值A作为左区间，向上寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为（A，B)。 number 1 2 3 4 5 6 6 6 11id 1 3 5 7 9 10 11 12 23 number 1 2 3 4 5 6 6 6 11 id 1 3 5 7 9 10 11 12 23 select * from t where number=6;那么间隙锁锁定的间隙为：（5，11），所以你再想插入5到11之间的数就会被阻塞。 更需要你注意的是，当你再执行update t set number = 6 where id = 1也会被阻塞。这是为什么？你想想看，要保证每次查询number=6的数据行数不变，如果你将另外一条数据修改成了6，岂不会多了一条？所以此时不会允许任何一条数据被修改成6。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>锁</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止线程的方式]]></title>
    <url>%2F2020%2F04%2F12%2Fting-zhi-xian-cheng-de-fang-shi%2F</url>
    <content type="text"><![CDATA[方式一使用stop暴力停止 注意该方式以经被弃用，因为它有很大弊端 public class Thread04 { public static void main(String[] args) { MyThread04 myThread = new MyThread04(); myThread.start(); myThread.stop(); } } class MyThread04 extends Thread{ @Override public void run(){ while (true){ } } } 弊端 强行停止线程则有可能使一些清理性的工作得不到完成 对锁定的对象进行“解锁“，可能导致数据得不到同步处理，出现数据不一致问题 强行停止导致数据不一样问题public class Thread04 { public static void main(String[] args) throws InterruptedException { MyThread004 myThread = new MyThread004(); myThread.start(); Thread.sleep(500); myThread.stop(); System.out.println(myThread.toString()); } } class MyThread004 extends Thread{ String accound="123456"; String password="123456"; @Override public synchronized void run(){ while (true){ accound="abc"; try { Thread.sleep(50000); } catch (InterruptedException e) { e.printStackTrace(); } password="abc"; } } @Override public synchronized String toString() { return "MyThread004{" + "accound='" + accound + '\'' + ", password='" + password + '\'' + '}'; } } MyThread004{accound='abc', password='123456'} 由于accound和password在没有完全完成被赋值操作的时候就被强行停止了，所以引发了不一致问题。 方式二使用returnpublic class Thread04 { public static void main(String[] args) throws InterruptedException { MyThread04 myThread = new MyThread04(); myThread.start(); Thread.sleep(500); System.out.println(myThread.toString()); myThread.interrupt(); } } class MyThread04 extends Thread{ @Override public void run(){ while (true){ if(this.isInterrupted()){ System.out.println("线程已经停止"); return; } } } } 方式三沉睡中暂停public class Thread07 { public static void main(String[] args) throws InterruptedException { MyThread07 myThread = new MyThread07(); myThread.start(); Thread.sleep(200); myThread.interrupt(); } } class MyThread07 extends Thread{ @Override public void run(){ try { System.out.println(Thread.currentThread().getName()+"开始执行"); Thread.sleep(200000); System.out.println(Thread.currentThread().getName()+"执行完毕"); } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName()+"停止执行"); e.printStackTrace(); } } } 方式四异常停止public class Thread07 { public static void main(String[] args) throws InterruptedException { MyThread07 myThread = new MyThread07(); myThread.start(); Thread.sleep(200); myThread.interrupt(); } } class MyThread07 extends Thread{ @Override public void run(){ try { System.out.println(Thread.currentThread().getName()+"开始执行"); // Thread.sleep(200000); throw new RuntimeException("hh"); } catch (Exception e) { System.out.println(Thread.currentThread().getName()+"停止执行"); e.printStackTrace(); } } } 总结 推荐使用return的方式来停止线程，个人觉得这种方式更可控 不行还可以使用异常的方式来停止线程，因为我们使用这种方式可以在finally块中解决stop强行停止线程带来的弊端 强烈不推荐使用stop强行停止，因为代价太大。]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>线程停止</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread中interrupted()方法和isInterrupted()方法区别]]></title>
    <url>%2F2020%2F04%2F12%2Fthread-zhong-interrupted-fang-fa-he-isinterrupted-fang-fa-qu-bie%2F</url>
    <content type="text"><![CDATA[源代码对比 public boolean isInterrupted() { return isInterrupted(false); } public static boolean interrupted() { return currentThread().isInterrupted(true); } isInterrupted是非静态的 interrupted是静态的，而且本质上是调用了当前线程中的isInterrupted 方法，不过传入了一个参数true 区别 当我们调用线程停止方法interrupt()方法停止当前线程的时候他并没有停止，而是在做了一个标记，也就说这个标记说明当前线程已经停止了，但是实际上线程还没有停止。 interrupted()是静态方法：内部实现是调用的当前线程的isInterrupted()，并且会重置当前线程的中断状态 isInterrupted()是实例方法，是调用该方法的对象所表示的那个线程的isInterrupted()，不会重置当前线程的中断状态 演示public class Thread03 { public static void main(String[] args) throws InterruptedException { Thread.sleep(200); Thread.currentThread().interrupt();//更改了中断为为true System.out.println(Thread.currentThread().isInterrupted());//直接返回true System.out.println(Thread.currentThread().isInterrupted());//直接返回true System.out.println(Thread.interrupted());//更改标志位状态为false,但是返回true System.out.println(Thread.interrupted());//返回false System.out.println(Thread.currentThread().isInterrupted());//直接返回true } } 总结 isInterrupted不会更改中断标志位 interrupted如果发现标志位和实际状态不一致就会更改其状态，并且返回原有状态 interrupted返回的是当前执行该方法的状态，isInterrupted返回的是该线程的状态。]]></content>
      <tags>
        <tag>thread</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[震惊！！！final修饰的变量可以被修改]]></title>
    <url>%2F2020%2F04%2F11%2Fzhen-liang-final-xiu-shi-de-bian-liang-ke-yi-bei-xiu-gai%2F</url>
    <content type="text"><![CDATA[震惊！！！final修饰的变量可以被修改首先先看一段代码 public class Final { public static void main(String[] args) throws IllegalAccessException { Hh hh=new Hh(); Field[] declaredFields = hh.getClass().getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField.getInt(hh)); System.out.println("反射修改前-----------"); declaredField.setAccessible(true); declaredField.set(hh, 456); System.out.println("反射修改后-----------"); System.out.println(declaredField.getInt(hh)); } } } class Hh{ final int age=18; public int getAge(){ return age; } } 运行结构 18 反射修改前----------- 反射修改后----------- 456 怎么样是不是震撼到你了 先别慌，在看一段代码 public class Final { public static void main(String[] args) throws IllegalAccessException { Hh hh=new Hh(); Field[] declaredFields = hh.getClass().getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(hh.getAge());//这里由反射获取改成了调用get方法获取 System.out.println("反射修改前-----------"); declaredField.setAccessible(true); declaredField.set(hh, 456); System.out.println("反射修改后-----------"); System.out.println(hh.getAge());//同理 } } } class Hh{ final int age=18; public int getAge(){ return age; } } 18 反射修改前----------- 反射修改后----------- 18 咦，不是说好了反射改final的值么，怎么又不能修改了，你这不是骗人么？ 其实上述的代码确实是通过反射该了final修饰的值，至于为啥结果还是18原因是java编译的时候做了优化，我们反编译一下第二段代码就明白了 class Hh { final int age = 18; Hh() { } public int getAge() { return 18;//这里编译的时候被编译期进行常量替换了 } } 如何才能保证不被替换呢？当我们使用引用类型的时候就可以保证不被编译期进行常量替换 比如：public class Final { public static void main(String[] args) throws IllegalAccessException { Hh hh=new Hh(); Field[] declaredFields = hh.getClass().getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(hh.getAge()); System.out.println("反射修改前-----------"); declaredField.setAccessible(true); declaredField.set(hh, 456); System.out.println("反射修改后-----------"); System.out.println(hh.getAge()); } } } class Hh{ final Integer age=18; public int getAge(){ return age; } } 18 反射修改前----------- 反射修改后----------- 456 反编译一下刚才的代码 class Hh { final Integer age = 18; Hh() { } public int getAge() { return this.age; } } 总结 final修饰的变量确实能够被反射修改 被修饰的变量不能被static final修饰，否则就算反射他爸爸也无力回天（当然反射没有爸爸） 原因我也不知道，先占个坑，回头懂了在说。]]></content>
      <tags>
        <tag>java</tag>
        <tag>final</tag>
        <tag>未完成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap详解]]></title>
    <url>%2F2020%2F04%2F09%2Fhashmap-xiang-jie%2F</url>
    <content type="text"><![CDATA[前言JDK 1.8 对 HashMap 进行了比较大的优化，底层实现由之前的 “数组+链表” 改为 “数组+链表+红黑树”， JDK 1.8 的 HashMap 的数据结构采用红黑树+数组+链表实现，当链表节点较少时仍然是以链表存在，当链表节点较多时（大于8）会进行扩容，当扩容后的数组大于等于64的时候会转为红黑树。 流程详解继承体系 Map 所有的双列集合实现的抽象类，注意，他是一个抽象类不是接口，详情参考JDK1.8文档。 AbstractMap 提供了Map要实现的最小接口 Cloneable 标记接口，实现了这个接口才能被克隆 Serializable 标记接口，实现了这个接口才能被序列化 成员变量 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // table默认容量大小 16 /** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//table最大容量 1073741824 /** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f;//负载因子 /** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8;//链表转换红黑树的阈值 /** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6;//红黑树退化成链表的阈值 /** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64;//转换红黑树最小table长度 transient Node&lt;K,V>[] table;//实际存储个个红黑树根节点或链表头部的数组。 /** * Holds cached entrySet(). Note that AbstractMap fields are used * for keySet() and values(). */ transient Set&lt;Map.Entry&lt;K,V>> entrySet; /** * The number of key-value mappings contained in this map. */ transient int size;//元素的个数，包含所有的节点 /** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the HashMap fail-fast. (See ConcurrentModificationException). */ transient int modCount;//并发修改标记 /** * The next size value at which to resize (capacity * load factor). * * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; /** * The load factor for the hash table. * * @serial */ final float loadFactor; 构造方法 public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // 使用默认0.75的装填因子 } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR);//使用指定大小的table容量和默认0.75装填因子 } public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0)//检查设定table容量是否合法 throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity > MAXIMUM_CAPACITY)//设定table容量是否超过最大容量 initialCapacity = MAXIMUM_CAPACITY;//超过就使最大容量为1&lt;&lt;30 1073741824 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))//判断装填因子是否合法 throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);//根据设定的大小创建大于等于给定容量2的n次幂的数组容量大小 } 总结 当我们创建一个HashMap对象时，并没有确定容器的大小。 当我们第一次添加元素的时候才会实际的分配容器大小 默认容量是16 当我们使用HashMap的时候最好使用有参构造方法提前分配容量来避免频繁的扩容带来的性能问题 HashMap中节点数少于8个的时候是一个链表，但是当节点数大于8的时候会检查当前table的容量是否小于64，否则扩容2倍，否则将链表结构转换为红黑树结构 当一颗红黑树节点数少于6个的时候红黑树会退化成链表。（原因就是树节点TreeNode的空间消耗比Node节点空间消耗更大，后面会详细解释） 前置方法计算哈希值// 代码1 static final int hash(Object key) { // 计算key的hash值 int h; // 1.先拿到key的hashCode值; //2.将hashCode的高16和低16位异或 return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); } int n = tab.length;//获取当前table元素的长度 // 将(tab.length - 1) 与 hash值进行&amp;运算 int index = (n - 1) &amp; hash;//相当于hash值对长度取余数 index=hash%n; 在HashMap中是允许key为null的，当key为null的时候根据低6行的三元运算符可以得知是0 hash值无符号右移并且和自身异或就是为了高16位和低16位都能参与运算，进而减少hash碰撞，（因为当hash值特别小的时候在JDK之前只有低16位参与运算，容易导致hash碰撞） int index = (n - 1) &amp; hash;其实就是相当于index=hash%n;(这里采用这种方式是因为位运算效率更高，mod运算是非常消耗计算机性能的) 扩容final Node&lt;K,V>[] resize() { Node&lt;K,V>[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 老表的容量不为0，即老表不为空 if (oldCap > 0) { // 判断老表的容量是否超过最大容量值：如果超过则将阈值设置为Integer.MAX_VALUE，并直接返回老表, // 此时oldCap * 2比Integer.MAX_VALUE大，因此无法进行重新分布，只是单纯的将阈值扩容到最大 if (oldCap >= MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return oldTab; } //将newCap赋值为oldCap的2倍，如果newCap&lt;最大容量并且oldCap>=16, 则将新阈值设置为原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap >= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold } // 如果老表的容量为0, 老表的阈值大于0, 是因为初始容量被放入阈值，则将新表的容量设置为老表的阈值 else if (oldThr > 0) newCap = oldThr; else { // 老表的容量为0, 老表的阈值为0，这种情况是没有传初始容量的new方法创建的空表，将阈值和容量设置为默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 如果新表的阈值为空, 则通过新的容量*负载因子获得阈值 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } // 将当前阈值设置为刚计算出来的新的阈值，定义新表，容量为刚计算出来的新容量，将table设置为新定义的表。 threshold = newThr; @SuppressWarnings({"rawtypes","unchecked"}) Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap]; table = newTab; // 如果老表不为空，则需遍历所有节点，将节点赋值给新表 if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V> e; if ((e = oldTab[j]) != null) { // 将索引值为j的老表头节点赋值给e oldTab[j] = null; // 将老表的节点设置为空, 以便垃圾收集器回收空间 // 如果e.next为空, 则代表老表的该位置只有1个节点，计算新表的索引位置, 直接将该节点放在该位置 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; // 如果是红黑树节点，则进行红黑树的重hash分布(跟链表的hash分布基本相同) else if (e instanceof TreeNode) ((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap); else { // preserve order // 如果是普通的链表节点，则进行普通的重hash分布 Node&lt;K,V> loHead = null, loTail = null; // 存储索引位置为:“原索引位置”的节点 Node&lt;K,V> hiHead = null, hiTail = null; // 存储索引位置为:“原索引位置+oldCap”的节点 Node&lt;K,V> next; do { next = e.next; // 如果e的hash值与老表的容量进行与运算为0,则扩容后的索引位置跟老表的索引位置一样 if ((e.hash &amp; oldCap) == 0) { if (loTail == null) // 如果loTail为空, 代表该节点为第一个节点 loHead = e; // 则将loHead赋值为第一个节点 else loTail.next = e; // 否则将节点添加在loTail后面 loTail = e; // 并将loTail赋值为新增的节点 } //如果e的hash值与老表的容量进行与运算为1,则扩容后的索引位置为:老表的索引位置＋oldCap else { if (hiTail == null) // 如果hiTail为空, 代表该节点为第一个节点 hiHead = e; // 则将hiHead赋值为第一个节点 else hiTail.next = e; // 否则将节点添加在hiTail后面 hiTail = e; // 并将hiTail赋值为新增的节点 } } while ((e = next) != null); //如果loTail不为空（说明老表的数据有分布到新表上“原索引位置”的节点），则将最后一个节点 // 的next设为空，并将新表上索引位置为“原索引位置”的节点设置为对应的头节点 if (loTail != null) { loTail.next = null; newTab[j] = loHead; } // 如果hiTail不为空（说明老表的数据有分布到新表上“原索引+oldCap位置”的节点），则将最后 // 一个节点的next设为空，并将新表上索引位置为“原索引+oldCap”的节点设置为对应的头节点 if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; } 如果当前table的长度已经最大，那么就无法扩容，直接调整扩容阈值到最大 如果可以扩容，那么就扩容两倍 扩容后需要调整节点的重新计算每个元素的hash,但是在jdk1.8中使用了很巧妙的方式（索引=原来索引+旧数组容量||原来索引） 值得注意的是，单纯的扩容也可以减少hash冲突，因为扩容后需要对节点进行重新（hash 值与老表的容量进行位与运算为 1则索引等于原来索引+旧数组容量）hash可能会导致某些节点调整桶的位置 put添加方法public V put(K key, V value) {//put方法实际调用的是putVal方法 //传入key的hash值，这个时候还未做取模运算 return putVal(hash(key), key, value, false, true); } //onlyIfAbsent true的时候不更改现有的值 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V>[] tab; Node&lt;K,V> p; int n, i; //如果是第一次添加元素 if ((tab = table) == null || (n = tab.length) == 0) //扩容，并且获取第一次扩容的后大小 n = (tab = resize()).length; //判断插入的桶位置是否是空 if ((p = tab[i = (n - 1) &amp; hash]) == null) //说明当前节点是该桶内的第一个节点 tab[i] = newNode(hash, key, value, null); else { //说明该桶内有其他元素 Node&lt;K,V> e; K k; //判断p节点的key和hash值是否跟传入的相等，如果相等（比较内容是否相等）, 则p节点即为要查找的目标节点，将p节点赋值给e节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断p节点是否是红黑树类型的节点，如果是就调用红黑树方法查找 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value); else { //作为链表结构查找，如果找到了相同节点就覆盖，没有找到就在末尾追加一个节点 for (int binCount = 0; ; ++binCount) { //没有找到 if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount >= TREEIFY_THRESHOLD - 1) //统计节点是否超过了7个也就是》=8，treeifyBin方法中检查table的大小，如果table大小小于64则进行二倍扩容，否则调整为红黑树结构 treeifyBin(tab, hash); break; } p.next = newNode(hash, key, value, null); //如果e节点存在hash值和key值都与传入的相同，则e节点即为目标节点，跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } //如果找到的节点的value值不相等,就覆盖 if (e != null) { V oldValue = e.value;//暂存旧的value值 if (!onlyIfAbsent || oldValue == null)//value值不相等 e.value = value;//覆盖 afterNodeAccess(e); return oldValue; } } ++modCount; if (++size > threshold) resize(); afterNodeInsertion(evict); return null; } 如果是第一次添加，就扩容到默认容量16 如果计算的索引的位置是null,那么就把当前节点作为第一个节点 如果计算的索引的位置不是null，且key相等，那么就覆盖该节点的value 如果计算的索引的位置不是null，且key不相等，那么就在相应链表或者红黑树上插入该节点 获取元素 public V get(Object key) { Node&lt;K,V> e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V> getNode(int hash, Object key) { Node&lt;K,V>[] tab; Node&lt;K,V> first, e; int n; K k; // 1.对table进行校验：table不为空 &amp;&amp; table长度大于0 &amp;&amp; // table索引位置(使用table.length - 1和hash值进行位与运算)的节点不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) > 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { // 2.检查first节点的hash值和key是否和入参的一样，如果一样则first即为目标节点，直接返回first节点 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 3.如果first不是目标节点，并且first的next节点不为空则继续遍历 if ((e = first.next) != null) { if (first instanceof TreeNode) // 4.如果是红黑树节点，则调用红黑树的查找目标节点方法getTreeNode return ((TreeNode&lt;K,V>)first).getTreeNode(hash, key); do { // 5.执行链表节点的查找，向下遍历链表, 直至找到节点的key和入参的key相等时,返回该节点 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } // 6.找不到符合的返回空 return null; } 找到了就返回 没有找到就返回null HashMap 和 Hashtable 的区别 HashMap 和 Hashtable 的区别 HashMap 允许 key 和 value 为 null，Hashtable 不允许。 HashMap 的默认初始容量为 16，Hashtable 为 11。 HashMap 的扩容为原来的 2 倍，Hashtable 的扩容为原来的 2 倍加 1。 HashMap 是非线程安全的，Hashtable是线程安全的。 HashMap 的 hash 值重新计算过，Hashtable 直接使用 hashCode。 HashMap 去掉了 Hashtable 中的 contains 方法。 HashMap 继承自 AbstractMap 类，Hashtable 继承自 Dictionary 类。 总结 HashMap 的底层是个 Node 数组（Node&lt;K,V&gt;[] table），在数组的具体索引位置，如果存在多个节点，则可能是以链表或红黑树的形式存在。 增加、删除、查找键值对时，定位到哈希桶数组的位置是很关键的一步，源码中是通过下面3个操作来完成这一步：1）拿到 key 的 hashCode 值；2）将 hashCode 的高位参与运算，重新计算 hash 值；3）将计算出来的 hash 值与 “table.length - 1” 进行 &amp; 运算。 HashMap 的默认初始容量（capacity）是 16，capacity 必须为 2 的幂次方；默认负载因子（load factor）是 0.75；实际能存放的节点个数（threshold，即触发扩容的阈值）= capacity * load factor。 HashMap 在触发扩容后，阈值会变为原来的 2 倍，并且会对所有节点进行重 hash 分布，重 hash 分布后节点的新分布位置只可能有两个：“原索引位置” 或 “原索引+oldCap位置”。例如 capacity 为16，索引位置 5 的节点扩容后，只可能分布在新表 “索引位置5” 和 “索引位置21（5+16）”。 导致 HashMap 扩容后，同一个索引位置的节点重 hash 最多分布在两个位置的根本原因是：1）table的长度始终为 2 的 n 次方；2）索引位置的计算方法为 “(table.length - 1) &amp; hash”。HashMap 扩容是一个比较耗时的操作，定义 HashMap 时尽量给个接近的初始容量值。 HashMap 有 threshold 属性和 loadFactor 属性，但是没有 capacity 属性。初始化时，如果传了初始化容量值，该值是存在 threshold 变量，并且 Node 数组是在第一次 put 时才会进行初始化，初始化时会将此时的 threshold 值作为新表的 capacity 值，然后用 capacity 和 loadFactor 计算新表的真正 threshold 值。 当同一个索引位置的节点在增加后达到 9 个时，并且此时数组的长度大于等于 64，则会触发链表节点（Node）转红黑树节点（TreeNode），转成红黑树节点后，其实链表的结构还存在，通过 next 属性维持。链表节点转红黑树节点的具体方法为源码中的 treeifyBin 方法。而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容。 当同一个索引位置的节点在移除后达到 6 个时，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点。红黑树节点转链表节点的具体方法为源码中的 untreeify 方法。 HashMap 在 JDK 1.8 之后不再有死循环的问题，JDK 1.8 之前存在死循环的根本原因是在扩容后同一索引位置的节点顺序会反掉。 HashMap 是非线程安全的，在并发场景下使用 ConcurrentHashMap 来代替。]]></content>
      <tags>
        <tag>容器</tag>
        <tag>源码</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引优化]]></title>
    <url>%2F2020%2F04%2F05%2Fmysql-suo-yin-you-hua%2F</url>
    <content type="text"><![CDATA[索引mysql中一张表最多能有多少个索引？16个索引，在innodb引擎中每个索引最大长度255个字节 复合索引在mysql中，复合索引是一个节点，这个节点按照创建复合索引的顺序组合成一个索引. 比如： CREATE INDEX inx_a_b_c ON &lt;表名>(a,b,c); 就创建了复合索引，每个B-数的节点是由a+b+c拼接而成。 其实这相当于建立了三个索引，分别是：1、单列索引（列a） 2、复合索引（列a, 列b） 3、复合索引（列a，列b，列c）。 最左匹配原则对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。下面用几个例子对比查询条件的不同对性能影响. 比如create table test( a int, b int, c int, KEY a(a,b,c) ); WHERE后面的SQL语句 解释 WHERE a=1 AND b=1 AND c=1 使用了复合主键，abc都进行了匹配 WHERE a=1 AND c=1 使用了复合主键，a进行了匹配 WHERE b=1 AND c=1 没有使用主键 WHERE a=1 AND b&gt;1 AND c=1 使用了复合主键，ab进行了匹配 例子表结构 create TABLE `emp`( `id` INT(11) NOT NULL AUTO_INCREMENT, empno INT NOT NULL, `name` VARCHAR(30) DEFAULT NULL, age INT(3) DEFAULT NULL, deptld INT(11) DEFAULT NULL, PRIMARY KEY(id) )ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4; 其中SQL_NO_CACHE是取消缓存，利于观察结果的正确性 -- 查询 EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=32; -- 创建age索引优化 CREATE INDEX idx_age ON emp(age); DROP INdex idx_age on emp; -- 模糊查询优化,在不创建索引的情况下两行执行速度相当，如果创建了name索引那么1比2快，给SQL使用函数会导致SQL失效，LIKE前面有百分号索引也会失效 EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.`name` LIKE "abc%"; EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE LEFT(emp.name,3)='abc'; CREATE INDEX idx_name ON emp(name); DROP INDEX idx_name on emp; -- 范围查询右侧字段索引失效 EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=32 AND emp.deptld>20 AND emp.name="abc"; -- 创建索引 CREATE INDEX idx_age_deptid_name ON emp(age,deptld,name); DROP INdex idx_age_deptid_name on emp; -- 优化索引还要调整查询顺序 CREATE INDEX idx_age_name_deptid ON emp(age,name,deptld); EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.age=32 AND emp.name="abc" AND emp.deptld>20; DROP INdex idx_age_name_deptid on emp; -- 不等于的情况会导致索引失效 EXPLAIN SELECT SQL_NO_CACHE * FROM emp WHERE emp.name&lt;>"abc"; -- 错误优化 CREATE INDEX idx_name ON emp(name); DROP INDEX idx_name; -- IS NULL 和IS NOT NULL IS 不会使用索引 -- 数据类型错误也不会使用索引，比如name=123因为name不是INT类型，所以索引失效，所以avabean对象和mysql数据库类型必须完全相同。 索引失效的情况 如果查询条件用or，必须or条件中的每个列都加上索引，否则无效。（尽量使用union代替） 复合索引未用左列字段; like以%开头; 需要类型转换; where中索引列有运算; where中索引列使用了函数; 如果mysql觉得全表扫描更快时（数据少） 关联查询优化 保证被驱动表的join字段有索引 left join时，选择小表为驱动表，大表为被驱动表，因为驱动表一定要做全表扫描。 inner join时，mysql会自己帮你把小结果集的表选为驱动表 子查询尽量不要放在被驱动表。因为子查询会生成虚拟表导致有可能使用不到索引 能够直接关联查询，尽量不用子查询。 ORDER BY优化在使用ORDER BY时，需要添加限定条件，否则ORDER BY会出现using filesort 在排序的时候所有的条件要么是升序，要么是降序，否则不使用索引 drop table if exists test; create table test( id int primary key auto_increment, c1 varchar(10), c2 varchar(10), c3 varchar(10), c4 varchar(10), c5 varchar(10) ) ENGINE=INNODB default CHARSET=utf8; insert into test(c1,c2,c3,c4,c5) values('a1','a2','a3','a4','a5'); insert into test(c1,c2,c3,c4,c5) values('b1','b2','b3','b4','b5'); insert into test(c1,c2,c3,c4,c5) values('c1','c2','c3','c4','c5'); insert into test(c1,c2,c3,c4,c5) values('d1','d2','d3','d4','d5'); insert into test(c1,c2,c3,c4,c5) values('e1','e2','e3','e4','e5'); 创建索引 CREATE INDEX idx_c1234 on test(c1,c2,c3,c4); EXPLAIN SELECT * FROM test WHEREc1&gt;’a1’ ORDER BY C1; ①在c1,c2,c3,c4上创建了索引，直接在c1上使用范围，导致了索引失效，全表扫描：type=ALL，ref=Null。因为此时c1主要用于排序，并不是查询。 ②使用c1进行排序，出现了Using filesort。 ③解决方法：使用覆盖索引。 EXPLAIN SELECT c2 FROM test WHERE c1&gt;’a1’ ORDER BY C1; 分析 因为需要的结果是c2，所以只需要在非聚簇索引查询就可以知道结果. EXPLAIN SELECT c1 FROM test WHERE c1&gt;’a1’ ORDER BY c1,c2; 分析 排序时按照索引的顺序，所以不会出现Using filesort。 EXPLAIN SELECT c1 FROM test WHERE c1&gt;’a1’ ORDER BY c2; 出现了Using filesort。原因：排序用的c2，与索引的创建顺序不一致，对比Case1.1可知，排序时少了c1（带头大哥），因此出现Using filesort。 EXPLAIN SELECT c1 FROM test WHERE c1&gt;’a1’ ORDER BY c2,c1; 分析： 出现了Using filesort。因为排序索引列与索引创建的顺序相反，从而产生了重排，也就出现了Using filesort。 EXPLAIN SELECT c1 FROM test WHERE c2&gt;’a1’ ORDER BY c1;分析： 排序使用了索引顺序（带头大哥在），因此不会出现Using filesort。 EXPLAIN SELECT c1 FROM test WHERE c1&gt;’a1’ ORDER BY c1 DESC,c2 ASC;]]></content>
      <tags>
        <tag>优化</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysqlExplain查询语句执行计划]]></title>
    <url>%2F2020%2F04%2F05%2Fmysqlexplain-cha-xun-yu-ju-zhi-xing-ji-hua%2F</url>
    <content type="text"><![CDATA[是什么在日常工作中，我们会有时会开慢查询去记录一些执行时间比较久的SQL语句，找出这些SQL语句并不意味着完事了，些时我们常常用到explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有做全表扫描，这都可以通过explain命令来查看。所以我们深入了解MySQL的基于开销的优化器，还可以获得很多可能被优化器考虑到的访问策略的细节，以及当运行SQL语句时哪种策略预计会被优化器采用。 有什么用 表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 怎么用explain + sql语句 字段分析 ID(重要)select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。 id相同，执行顺序由上至下 id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 id相同不同，同时存在 id相同的可以认为是一组，同一组中从上往下执行，所有组中id大的优先执行 总结总而言之，相同顺序执行，不同大号先执行。 select_type表示示查询中每个select子句的类型 SIMPLE(简单SELECT，不使用UNION或子查询等) PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY) DERIVED(派生表的SELECT, FROM子句的子查询) SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询) DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询) UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行) UNION(UNION中的第二个或后面的SELECT语句) DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询) UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select) table(重要)显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称 partitions 代表分区表中的命中情况，非分区表，该项为null type(重要)对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。 常用的类型有： ALL、index、range、 ref、eq_ref、const、system、NULL（从左到右，性能从差到好） ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行 index: Full Index Scan，index与ALL区别为index类型只遍历索引树 range:只检索给定范围的行，使用一个索引来选择行 ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 eq_ref: 类似ref，区别就在 使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件 const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system NULL: MySQL在优化过程中分解语句 ，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。 possible_keys指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null） Key（重要）key列显示MySQL实际决定使用的键（索引），必然包含在possible_keys中 key_len单位是字节 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的） 不损失精确性的情况下，长度越短越好 ，如果查询使用的是复合索引，那么越长越好。 ref列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 rows（重要）表示MySQL估计未来找到所需要的行而要读取的行数 Extra(重要)这一列包含的是不适合在其他列显示的额为信息 Using index 表示此值Mysql将使用覆盖索引，以避免访问表。 Using where:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤 Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。 Impossible where：这个值强调了where语句会导致没有符合条件的行（通过收集统计信息不可能存在结果）。 Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务详解]]></title>
    <url>%2F2020%2F04%2F04%2Fmysql-shi-wu-xiang-jie%2F</url>
    <content type="text"><![CDATA[为什么需要事务转账是生活中常见的操作,比如从A账户转账100元到B账号。站在用户角度而言,这是一个逻辑上的单一操作,然而在数据库系统中,至少会分成两个步骤来完成: 1.将A账户的金额减少100元 2.将B账户的金额增加100元 在这个过程中可能会出现以下问题: 1.转账操作的第一步执行成功,A账户上的钱减少了100元,但是第二步执行失败或者未执行便发生系统崩溃,导致B账户并没有相应增加100元。 2.转账操作刚完成就发生系统崩溃,系统重启恢复时丢失了崩溃前的转账记录。 3.同时又另一个用户转账给B账户,由于同时对B账户进行操作,导致B账户金额出现异常。 所以为了解决上述问题，需要引入数据库事务相关概念。 事务的特性原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。 事务的四大特性理解“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作： 1、从A账号中把余额读出来（500）。2、对A账号做减法操作（500-100）。3、把结果写回A账号中（400）。4、从B账号中把余额读出来（500）。5、对B账号做加法操作（500+100）。6、把结果写回B账号中（600）。 原子性：保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。 一致性在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。 隔离性在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。 持久性一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！ 事务隔离级别读未提交：read uncommitted 事物A和事物B，事物A未提交的数据，事物B可以读取到 这里读取到的数据叫做“脏数据” 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别 读已提交：read committed 事物A和事物B，事物A提交的数据，事物B才能读取到 这种隔离级别高于读未提交 换句话说，对方事物提交之后的数据，我当前事物才能读取到 这种级别可以避免“脏数据” 这种隔离级别会导致“不可重复读取” Oracle默认隔离级别 可重复读：repeatable read 事务A和事务B，事务A提交之后的数据，事务B读取不到 事务B是可重复读取数据 这种隔离级别高于读已提交 换句话说，对方提交之后的数据，我还是读取不到 这种隔离级别可以避免“不可重复读取”，达到可重复读取 比如1点和2点读到数据是同一个 MySQL默认级别 虽然可以达到可重复读取，但是会导致“幻像读” 串行化：serializable 事务A和事务B，事务A在操作数据库时，事务B只能排队等待 这种隔离级别很少使用，吞吐量太低，用户体验差 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发 事务并发带来的问题脏读：一个事务读取了另一个事务未提交的数据。事务A：张三妻子给张三转账 100元。事务B：张三查询余额。事务A转账后（还未提交），事务B查询多了100元。事务A由于某种问题，比如超时，进行回滚。事务B查询到的数据是假 数据。脏读本质上是读写操作的冲突，解决办法是写完之后再读。 不可重复读：一个事务两次读取同一个数据，两次读取的数据不一致。事务 A：张 三妻子给张三转账100元。事务B：张三两次查询余额。事务B第一次查询余额，事务A还没有转账，第二次查询余额，事务A已经转账了，导致一个事务中，两 次读取同一个数据，读取的数据不一致。不可重复读本质上是读写操作的冲突，解决办法是读完再写。 幻读：一个事务两次读取一个范围的 记录，两次读取的记录数不一致。事务A： 张三妻子两次查询张三有几张银行卡。事务B：张三新办一张银行卡。事务A第一次查询银行卡数的时候，张三还没有新办银行卡，第二次查询银行卡数的时候，张 三已经新办了一张银行卡，导致两次读取的银行卡数不一样。幻象读本质上是读写操作的冲突，解决办法是读完再写。 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITED 允许 允许 允许 READ COMMITTED 不允许 允许 允许 REPEATABLE READ 不允许 不允许 允许 SERIALIZABLE 不允许 不允许 不允许 mysql事务带来的问题演示//查看当前事物级别： SELECT @@tx_isolation; //设置mysql的隔离级别： set session transaction isolation level 设置事务隔离级别 //设置read uncommitted级别： set session transaction isolation level read uncommitted; //设置read committed级别： set session transaction isolation level read committed; //设置repeatable read级别： set session transaction isolation level repeatable read; //设置serializable级别： set session transaction isolation level serializable; 每次更改事务的隔离级别只针对当前会话有效。 假设有张表 CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `money` double(255,0) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4; 脏读首先要把两个窗口的事务隔离级别都更改为读为提交（read uncommitted）级别，这样才能发生脏读问题 窗口A 窗口B 然后窗口A开启一个事务，并且更改表中的某个字段，但是不要提交该事务， 窗口B开启了一个事务，并且把id为3的小红的钱变成了999，但是没有提交事务。 此时窗口A查询到的结果就是窗口A还没有提交的事务的结果。 之后窗口B回滚事务，这个时候小红的钱又回到了之前的状态，这就发生了脏读，因为A读到了假数据，所以就称为脏读； 不可重复读首先要把两个窗口的事务隔离级别都更改为读为提交（read uncommitted）级别，这样才能发生脏读问题 A开启一个事务查询余额，但是不提交事务，然后B直接修改余额，之后A再次查询余额 开启了一个事务并且第一次查询余额。 B修改了一条数据 A在同一个事务中读取到的前后顺序不一样，这就是因为发送了不可重复读的现象。 可以发现，两次查询的结果不一致，这种操作是没错的，但是，如果银行统计报表时，这种情况是不符合需求的，演示完成，将b账户中的事务提交 我们，不希望在一个事务中，看到的查询结果不一致，这就是不可重复读 幻读A窗口开启一个事务，统计数据库中记录的条数 然后B窗口插入一条数据 之后A窗口再次查询 这就出现了幻读现象，好像出现了幻觉一样 一个事务两次读取一个范围的 记录，两次读取的记录数不一致。]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引详解]]></title>
    <url>%2F2020%2F04%2F01%2Fmysql-suo-yin-xiang-jie%2F</url>
    <content type="text"><![CDATA[索引 索引就是一种排好序的快速查找数据结构 索引的分类单值索引即一个索引只包含单个列，一个表可以有多个单列索引（建议一张表索引不要超过5个优先考虑复合索引） 唯一索引索引列的值必须唯一，但允许有空值 复合索引即一个索引包含多个列 索引的基本语法创建CREATE [UNIQUE] INDEX indexName ON mytable(columnname(length)); 删除ALTER mytable ADD [UNIQUE] INDEX [indexName] ON(columnname(length)); 查看DROP INDEX [indexName] ON mytable; 查看一个表的索引信息show index from [tableName]; 索引的优缺点优点 提高数据检索效率，降低数据库IO成本 通过索引列对数据排序，降低数据排序成本，降低CPU的消耗 缺点 实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录,所以索引列也是要占用空间的 虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。 因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句 索引的使用场景什么时候需要使用索引 主键自动建立唯一索引 频繁作为查询的条件的字段应该创建索引 查询中与其他表关联的字段，外键关系建立索引 频繁更新的字段不适合创建索引(因为每次更新不单单是更新了记录还会更新索引，加重IO负担) Where条件里用不到的字段不创建索引 单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引） 查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度 查询中统计或者分组字段 什么时候不需要使用索引 表记录太少(因为数据量太少，索引并不能起到很好效果) 经常增删改的表(因为每次更新不单单是更新了记录还会更新索引，加重IO负担) 数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。 注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。(应该尽可能的让非重复字段的数量/总数量的结果接近1) 什么是聚簇索引和回表聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因 总结 聚簇索引叶节点存储着行数据 非聚簇索引即普通索引只是存储着聚簇索引的key. 聚簇索引具有唯一性由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引 聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。 演示假如有一张表有三个字段，分别是学号（唯一主键），姓名，和性别 然后我们创建姓名为非聚簇索引 当我们使用select * from where id=”1”;时 上面就是一个聚簇索引，当我们查询id=1的时候就通过聚簇索引查询到对应的行数据 当我们使用select * from where name=”a”;时 查询的是我们创建的索引，我们创建的这颗非聚簇索引并不存储行数据，而是存储聚簇索引的主键值 因为我们查询的是 * . 所以我们在查询普通索引的时候发现a对应的主键是1，于是乎我们需要到聚簇索引找到我们想要的信息，需要重新查找，这个操作就称为回表。 然后我们拿到主键是1，查询到对应的行。 索引覆盖当我们使用select namerom where name=”a”;时 因为普通索引就存储着我们想要的信息，所以就无需回表，这就提高了查询效率 优化我们利用这个回表的特性，创建一些联合索引，就可以避免回表的操作，这样就可以实现查询的优化 分析： 虽然排序的字段列与索引顺序一样，且order by默认升序，这里c2 desc变成了降序，导致与索引的排序方式不同，从而产生Using filesort。 总结①MySQL支持两种方式的排序filesort和index，Using index是指MySQL扫描索引本身完成排序。index效率高，filesort效率低。 ②order by满足两种情况会使用Using index。 1.order by语句使用索引最左前列。 2.使用where子句与order by子句条件列组合满足索引最左前列。 ③尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最佳左前缀法则。 ④如果order by的条件不在索引列上，就会产生Using filesort。 1.filesort有两种排序算法：双路排序和单路排序。 双路排序：在MySQL4.1之前使用双路排序，就是两次磁盘扫描，得到最终数据。读取行指针和order by列，对他们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读取对应的数据输出。即从磁盘读取排序字段，在buffer进行排序，再从磁盘取其他字段。 如果使用双路排序，取一批数据要对磁盘进行两次扫描，众所周知，I/O操作是很耗时的，因此在MySQL4.1以后，出现了改进的算法：单路排序。 单路排序：从磁盘中查询所需的列，按照order by列在buffer中对它们进行排序，然后扫描排序后的列表进行输出。它的效率更高一些，避免了第二次读取数据，并且把随机I/O变成了顺序I/O，但是会使用更多的空间，因为它把每一行都保存在内存中了。 2.单路排序出现的问题。 当读取数据超过sort_buffer的容量时，就会导致多次读取数据，并创建临时表，最后多路合并，产生多次I/O，反而增加其I/O运算。 解决方式： a.增加sort_buffer_size参数的设置。 b.增大max_length_for_sort_data参数的设置。 ⑤提升order by速度的方式： 1.在使用order by时，不要用select *，只查询所需的字段。 因为当查询字段过多时，会导致sort_buffer不够，从而使用多路排序或进行多次I/O操作。 2.尝试提高sort_buffer_size。 3.尝试提高max_length_for_sort_data。 GROUP BY优化 如果GROUP BY 的列没有索引,产生临时表. 如果GROUP BY时,SELECT的列不止GROUP BY列一个,并且GROUP BY的列不是主键 ,产生临时表. 如果GROUP BY的列有索引,ORDER BY的列没索引.产生临时表. 如果GROUP BY的列和ORDER BY的列不一样,即使都有索引也会产生临时表. 如果GROUP BY或ORDER BY的列不是来自JOIN语句第一个表.会产生临时表. 如果DISTINCT 和 ORDER BY的列没有索引,产生临时表.]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql数据结构B+树详解]]></title>
    <url>%2F2020%2F03%2F30%2Fmysql-shu-ju-jie-gou-b-shu-xiang-jie%2F</url>
    <content type="text"><![CDATA[为什么要使用B+树数据结构的种类 数组 栈 队列 链表 树 散列表 堆 图 我们都知道这些数据结构，但是对于mysql来说，需要选用一个更合适的数据结构 首先这个数据结构要满足查找增删快特点 显然满足这个条件的只有数和散列表了，那么接下来我们先讨论树，在后来会在讨论mysql和散列表的 二叉树学过数据结构的都知道二叉树的特点 若左子树不空，则左子树上所有节点的值均小于它的根节点的值 若右子树不空，则右子树上所有节点的值均大于它的根节点的值 它的左、右子树也分别为二叉排序数（递归定义） 但是二叉树有个很大的缺陷，就是如果插入的数据是有序的，那么会导致二叉树的层数增多，极端的情况下以至于退化成一个链表（当然你可以理解我类似链表的情况） 也就是查询时间复杂度从O(logn)退化到了O(n) 很显然，mysql不能使用这种数据结构来实现，因为我们平时在使用数据库的时候主键自增是一个很常用的需求，所以就有了二叉树的改进版本平衡二叉树 平衡二叉树它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。 特点平衡树的旋转我们这里就不细说了，我们主要介绍为什么mysql没有使用平衡树 假如我们一张数据库表有数据1000万条数据，那么使用平衡树需要多少层呢（即需要查询多少次）？ 假设很理想的情况下需要log2(1000万+1)向上取整数层即为24层,看起来效率还可以，但是我们不要忘记一点就是，数据库文件肯定是存储到本机磁盘的，也就说说这如果查找到的记录在叶节点，那么我们需要对磁盘读24次，那么这样还是很慢的，接下来我们能不能在缩减磁盘IO的次数呢？这样是不是就能更快的提高查找速度了呢？（接下里就引入了B树这个东东） B树如果我们把二叉树的每个节点存储数量由一个改成多个是不是就能极大的减少二叉树的乘数呢？ 比如之前有6个节点的二叉树（插入顺序都是从大到小） 我们改成每个节点存储5个元素的B树 我们可以看到层数缩减到了2层也就是说如果我们能合理的设置每个节点存储元素的个数,那么我们就可以在不牺牲性能的情况下极大的减少磁盘IO的次数,(因为数据库的索引特别大，所以一般索引也是存储到本地磁盘上的)。 到目前一切显得似乎都那么完美，但是如果mysql如果使用B树的话也有一个很大的缺点，就是mysql除了每次只查询一条数据，但是mysql还要支持条件查询啊，假如我们需要找到所有大于3的节点 是不是首先通过004找到了002之后到了003这个节点，然后回到父节点的父节点004，然后在先序遍历右子树，是不是特别浪费性能呢?，那么我们能不能也解决这个问题呢？（接下来我们就讲解B+树）,mysql的innodb使用的数据结构 B+树如果我们把B树的叶节点串起来不就好了么，这样不就能满足上面的那个查询条件了么，当然我们不能只是连接起来，我们还需要把非叶节点进行调整，也就是说真实数据存放在叶节点，非叶节点可以理解为我们的主键 到目前为止，已经满足了mysql对数据结构的所有需求，可以还有一点不明白如果我们查询小于5的怎么查找呢，你上面图的结构只是前面的叶节点指向后面的叶节点，其实在mysql中实现的这个是个双向连接，这样就满足了向前后向后，（把图中的箭头理解为双向箭头） 哈希表其实哈希表在mysql的 innodb中也有使用的 上面的那个BTREE就是B+数 下面的就是HASH 但是一般都是用B+数 原因看完我这个文章应该懂为啥有哈希并且大多使用的是B+数 原因就是哈希结构查询速度是O(1)（在不考虑哈希碰撞等等一些问题） 也就是说有些业务场景是需要使用到的。 那为什么大多没有使用哈希呢，他那么快（秒男），其实也是因为他内部是无序的，如果遇见了条件查询，那么哈希的速度慢上了天，速度约为O（n）。 完结散花؏؏☝ᖗ乛◡乛ᖘ☝؏؏ 后期可能还会更新哦！]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁和悲观锁以及锁升级详解]]></title>
    <url>%2F2020%2F03%2F28%2Fle-guan-suo-he-bei-guan-suo-yi-ji-suo-sheng-ji-xiang-jie%2F</url>
    <content type="text"><![CDATA[CASCAS概述和作用CAS的全成 Compare And Swap(比较相同再交换)。是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。 CAS的作用CAS可以将比较和交换转换为原子操作，这个原子操作直接由CPU保证。CAS可以保证共享变量赋值时的原子操作。CAS操作依赖3个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中。 CAS和volatile实现无锁并发public class Demo01 { public static void main(String[] args) throws InterruptedException { AtomicInteger atomicInteger = new AtomicInteger(); Runnable mr = () -> { for (int i = 0; i &lt; 1000; i++) { atomicInteger.incrementAndGet(); } }; ArrayList&lt;Thread> ts = new ArrayList&lt;>(); for (int i = 0; i &lt; 5; i++) { Thread t = new Thread(mr); t.start(); ts.add(t); } for (Thread t : ts) { t.join(); } System.out.println("number = " + atomicInteger.get()); } } AtomicInteger部分源码 public final int getAndIncrement() { return U.getAndAddInt(this, VALUE, 1); } @HotSpotIntrinsicCandidate public final int getAndAddInt(Object o, long offset, int delta) {//o对象地址，offset value在对象中的偏移值，delta要增加的结果 int v; do { v = getIntVolatile(o, offset);//根据对象和偏移量获取value的值 } while (!weakCompareAndSetInt(o, offset, v, v + delta));//比较预估值和内存中的结果是否相等，如果相等就更改结果为v+delta否则就循环重试 return v; } 通过刚才AtomicInteger的源码我们可以看到，Unsafe类提供了原子操作。 Unsafe类介绍Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Unsafe对象不能直接调用，只能通过反射获得。 乐观锁和悲观锁悲观锁从悲观的角度出发：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞。因此synchronized我们也将其称之为悲观锁。JDK中的ReentrantLock也是一种悲观锁。性能较差！ 乐观锁从乐观的角度出发:总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，就算改了也没关系，再重试即可。所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去修改这个数据，如何没有人修改则更新，如果有人修改则重试。CAS这种机制我们也可以将其称之为乐观锁。综合性能较好！ CAS获取共享变量时，为了保证该变量的可见性，需要使用volatile修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一。 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 总结CAS的作用Compare And Swap，CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器保证。 CAS的原理CAS需要3个值:内存地址V，旧的预期值A，要修改的新值B，如果内存地址V和旧的预期值A相等就修改内存地址值为B synchronized锁升级过程高效并发是从JDK 5到JDK 6的一个重要改进，HotSpot虛拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，包括偏向锁( Biased Locking )、轻量级锁( Lightweight Locking )和如适应性自旋(Adaptive Spinning)、锁消除( Lock Elimination)、锁粗化( Lock Coarsening )等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。 过程无锁–&gt;偏向锁–&gt;轻量级锁–&gt;重量级锁 对象的内存布局在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下图所示： 对象头当一个线程尝试访问synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？是存在锁对象的对象头中的。HotSpot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类型。instanceOopDesc的定义的在Hotspot源码的 instanceOop.hpp 文件中，另外，arrayOopDesc的定义对应 arrayOop.hpp class instanceOopDesc : public oopDesc { public: // aligned header size. static int header_size() { return sizeof(instanceOopDesc)/HeapWordSize; } // If compressed, the offset of the fields of the instance may not be aligned. static int base_offset_in_bytes() { // offset computation code breaks if UseCompressedClassPointers // only is true return (UseCompressedOops && UseCompressedClassPointers) ? klass_gap_offset_in_bytes() : sizeof(instanceOopDesc); } static bool contains_field_offset(int offset, int nonstatic_field_size) { int base_in_bytes = base_offset_in_bytes(); return (offset >= base_in_bytes && (offset-base_in_bytes) < nonstatic_field_size * heapOopSize); } }; 从 instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot源码中的 oop.hpp 文件中。 class oopDesc { friend class VMStructs; private: volatile markOop _mark; union _metadata { Klass* _klass; narrowKlass _compressed_klass; } _metadata; // Fast access to barrier set. Must be initialized. static BarrierSet* _bs; // 省略其他代码 }; 在普通实例对象中， oopDesc的定义包含两个成员，分别是 _mark 和 _metadata_mark 表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了对象和锁有关的信息_metadata 表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示普通指针、 _compressed_klass 表示压缩类指针。对象头由两部分组成，一部分用于存储自身的运行时数据，称之为 Mark Word，另外一部分是类型指针，及对象指向它的类元数据的指针。 Mark WordMark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。Mark Word对应的类型是 markOop 。源码位于 markOop.hpp 中。 在 64位虚拟机下，Mark Word是64bit大小的，其存储结构如下： 在32位虚拟机下，Mark Word是32bit大小的，其存储结构如下： klass pointer这一部分用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。 如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以使用选项 - XX:+UseCompressedOops 开启指针压缩，其中，oop即ordinaryobject pointer普通对象指针。开启该选项后，下列指针将压缩至32位： 每个Class的属性指针（即静态变量） 每个对象的属性指针（即对象变量） 普通对象数组的每个元素指针 当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对 象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等。 对象头 = Mark Word + 类型指针（未开启指针压缩的情况下） 在32位系统中，Mark Word = 4 bytes，类型指针 = 4bytes，对象头 = 8 bytes = 64 bits； 在 64位系统中，Mark Word = 8 bytes，类型指针 = 8bytes，对象头 = 16 bytes = 128bits； 实例数据就是类中定义的成员变量。 对齐填充对齐填充并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 查看Java对象布局&lt;dependency> &lt;groupId>org.openjdk.jol&lt;/groupId> &lt;artifactId>jol-core&lt;/artifactId> &lt;version>0.9&lt;/version> &lt;/dependency> 总结Java对象由3部分组成，对象头，实例数据，对齐数据对象头分成两部分：Mark World + Klass pointer 偏向锁什么是偏向锁偏向锁是JDK 6中的重要引进，因为HotSpot作者经过研究实践发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引进了偏向锁。偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，会在对象头存储锁偏向的线程ID，以后该线程进入和退出同步块时只需要检查是否为偏向锁、锁标志位以及ThreadID即可。 不过一旦出现多个线程竞争时必须撤销偏向锁，所以撤销偏向锁消耗的性能必须小于之前节省下来的CAS原子操作的性能消耗，不然就得不偿失了。 偏向锁原理当线程第一次访问同步块并获取锁时，偏向锁处理流程如下： 虚拟机将会把对象头中的标志位设为“01”，即偏向模式。 同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。 持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高。 偏向锁的撤销 偏向锁的撤销动作必须等待全局安全点 暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态 撤销偏向锁，恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态 偏向锁在 Java 6之后是默认启用的，但在应用程序启动几秒钟之后才激活，可以使用 -XX:BiasedLockingStartupDelay=0 参数关闭延迟，如果确定应用程序中所有锁通常情况下处于竞争状态，可以通过 XX: -UseBiasedLocking=false 参数关闭偏向锁。 偏向锁好处 偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向 锁可以提高带有同步但无竞争的程序性能。 它同样是一个带有效益权衡性质的优化，也就是说，它并不一定总是对程序运行有利，如果程序中大多 数的锁总是被多个不同的线程访问比如线程池，那偏向模式就是多余的。 在JDK5中偏向锁默认是关闭的，而到了JDK6中偏向锁已经默认开启。但在应用程序启动几秒钟之后才 激活，可以使用 - XX:BiasedLockingStartupDelay=0 参数关闭延迟，如果确定应用程序中所有锁通常 情况下处于竞争状态，可以通过 XX: -UseBiasedLocking=false 参数关闭偏向锁。 总结偏向锁的原理 当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中 ，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作，偏向锁的效率高 偏向锁的好处 偏向锁是在只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以提高带有同步但无竞争的程序性能。 轻量级锁什么是轻量级锁轻量级锁是JDK 6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用monitor的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的。引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁引起的性能消耗，但是如果多个线程在同一时刻进入临界区，会导致轻量级锁膨胀升级重量级锁，所以轻量级锁的出现并非是要替代重量级锁。 轻量级锁原理当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下： 获取锁 判断当前对象是否处于无锁状态（hashcode、0、01），如果是，则JVM首先将在当前线程的栈帧 中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方 把这份拷贝加了一个Displaced前缀，即Displaced Mark Word），将对象的Mark Word复制到栈 帧中的Lock Record中，将Lock Reocrd中的owner指向当前对象。 JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功表示竞争到 锁，则将锁标志位变成00，执行同步操作。 如果失败则判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持 有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻 量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态。 轻量级锁的释放轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下： 取出在获取轻量级锁保存在Displaced Mark Word中的数据。 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功。 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要将轻量级锁需要膨胀升级为重量级 锁。 对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如 果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁 比重量级锁更慢。 #### 轻量级锁好处 在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。总结轻量级锁的原理是什么将对象的Mark Word复制到栈帧中的Lock Recod中。Mark Word更新为指向Lock Record的指针。 轻量级锁好处是什么在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。 自旋锁原理synchronized (Demo01.class) { ... System.out.println("aaa"); } 前面我们讨论 monitor实现锁的时候，知道monitor会阻塞和唤醒线程，线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间阻塞和唤醒线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环(自旋) , 这项技术就是所谓的自旋锁。 自旋锁在JDK 1.4.2中就已经引入 ，只不过默认是关闭的，可以使用-XX:+UseSpinning参数来开启，在JDK 6中 就已经改为默认开启了。自旋等待不能代替阻塞，且先不说对处理器数量的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长。那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性 能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX : PreBlockSpin来更改。 适应性自旋锁在JDK 6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了 锁消除锁消除是指虚拟机即时编译器（JIT）在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。**锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，**堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是程序员自己应该是很清楚的，怎么会在明知道不存在数据争用的情况下要求同步呢?实际上有许多同步措施并不是程序员自己加入的，同步的代码在Java程序中的普遍程度也许超过了大部分读者的想象。下面这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。 public class Demo01 { public static void main(String[] args) { contactString("aa", "bb", "cc"); } public static String contactString(String s1, String s2, String s3) { return new StringBuffer().append(s1).append(s2).append(s3).toString(); } } StringBuffer的append ( ) 是一个同步方法，锁就是this也就是(new StringBuilder())。虚拟机发现它的动态作用域被限制在concatString( )方法内部。也就是说, new StringBuilder()对象的引用永远不会“逃逸”到concatString ( )方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了 锁粗化原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗 例子public class Demo01 { static StringBuffer sb = new StringBuffer(); public static void main(String[] args) { for (int i = 0; i &lt; 100; i++) { sb.append("aa"); } System.out.println(sb.toString()); } } 对于上述代码因为append有synchronized，所以会执行100次锁的获取和释放 JIT在遇见这种代码的时候会吧锁放到循环外部，这样就不需要频繁的获取锁了 总结每一个synchronized块都对应一个monitorenter和两个monitorexit，其实JIT编译器在执行动态编译时会对上面代码进行优化：若发现前后相邻的synchronized块使用的是同一个锁对象，那么它就会把这几个synchronized块给合并为一个较大的同步块，这样做的好处在于线程在执行这些代码时，就无需频繁申请与释放锁了，从而达到申请与释放锁一次，就可以执行完全部的同步代码块，从而提升了性能。 平时写代码如何对 synchronized优化减少synchronized的范围同步代码块中尽量短，减少同步代码块中代码的执行时间，减少锁的竞争。 synchronized (Demo01.class) { System.out.println("aaa"); } 降低 synchronized锁的粒度将一个锁拆分为多个锁提高并发度 Hashtable hs = new Hashtable(); hs.put("aa", "bb"); hs.put("xx", "yy"); 读写分离读取时不加锁，写入和删除时加锁ConcurrentHashMap，CopyOnWriteArrayList和ConyOnWriteSet]]></content>
      <tags>
        <tag>java</tag>
        <tag>锁</tag>
        <tag>CAS</tag>
        <tag>乐观锁</tag>
        <tag>悲观锁</tag>
        <tag>偏向锁</tag>
        <tag>轻量级锁</tag>
        <tag>自旋锁</tag>
        <tag>锁消除</tag>
        <tag>锁粗化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[monitor详解]]></title>
    <url>%2F2020%2F03%2F28%2Fmonitor-xiang-jie%2F</url>
    <content type="text"><![CDATA[准备JVM源码下载http://openjdk.java.net/ –&gt; Mercurial –&gt; jdk8 –&gt; hotspot –&gt; zip monitor监视器锁从上一篇synchronized详解文章可以看出,无论是synchronized代码块还是synchronized方法，其线程安全的语义实现最终依赖一个叫monitor的东西，那么这个神秘的东西是什么呢？ 在HotSpot虚拟机中，monitor是由ObjectMonitor实现的。其源码是用c++来实现的，位于HotSpot虚拟机源码ObjectMonitor.hpp文件中(src/share/vm/runtime/objectMonitor.hpp)。ObjectMonitor主要数据结构如下： ObjectMonitor() { _header = NULL; _count = 0; _waiters = 0, _recursions = 0;//线程的重入次数，也就是前面几篇文章我们所说的那个计数器 _object = NULL;//存储该monitor对象 _owner = NULL;//标识那个线程拥有这个monitor _WaitSet = NULL;//处于wait状态的线程，会被加入到这个_WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ;//多线程竞争锁时的单项列表 FreeNext = NULL ; _EntryList = NULL ;//处于等待block状态的线程，会被加入到该列表 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; _previous_owner_tid = 0; } _owner：初始时为NULL。当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程 释放monitor时，owner又恢复为NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线 程安全的。 cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。cxq是一个临界资 源，JVM通过CAS原子指令来修改_cxq队列。修改前_cxq的旧值填入了node的next字段，_cxq指 向新值（新线程）。因此_cxq是一个后进先出的stack（栈）。 EntryList：cxq队列中有资格成为候选资源的线程会被移动到该队列中。 WaitSet：因为调用wait方法而被阻塞的线程会被放在该队列中。 每一个Java对象都可以与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执 行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象 对应的monitor。 我们的Java代码里不会显示地去创造这么一个monitor对象，我们也无需创建，事实上可以这么理解： monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉JVM需要为我们的某个对 象创建关联的monitor对象。每个线程都存在两个ObjectMonitor对象列表，分别为free和used列表。 同时JVM中也维护着global locklist。当线程需要ObjectMonitor对象时，首先从线程自身的free表中申 请，若存在则使用，若不存在则从global list中申请 monitor竞争执行monitorenter时，会调用InterpreterRuntime.cpp(位于：src/share/vm/interpreter/interpreterRuntime.cpp) 的 InterpreterRuntime::monitorenter函数。具体代码可参见HotSpot源码。 IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem)) #ifdef ASSERT thread->last_frame().interpreter_frame_verify_monitor(elem); #endif if (PrintBiasedLockingStatistics) { Atomic::inc(BiasedLocking::slow_path_entry_count_addr()); } Handle h_obj(thread, elem->obj()); assert(Universe::heap()->is_in_reserved_or_null(h_obj()), "must be NULL or an object"); if (UseBiasedLocking) { // Retry fast entry if bias is revoked to avoid unnecessary inflation ObjectSynchronizer::fast_enter(h_obj, elem->lock(), true, CHECK); } else { ObjectSynchronizer::slow_enter(h_obj, elem->lock(), CHECK); } assert(Universe::heap()->is_in_reserved_or_null(elem->obj()), "must be NULL or an object"); #ifdef ASSERT thread->last_frame().interpreter_frame_verify_monitor(elem); #endif IRT_END 对于重量级锁，monitorenter函数中会调用 ObjectSynchronizer::slow_enter 最终调用 ObjectMonitor::enter（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下： void ATTR ObjectMonitor::enter(TRAPS) { // The following code is ordered to check the most common cases first // and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors. Thread * const Self = THREAD ; void * cur ; // 通过CAS操作尝试把monitor的_owner字段设置为当前线程 cur = Atomic::cmpxchg_ptr (Self， &_owner， NULL) ; if (cur == NULL) { // Either ASSERT _recursions == 0 or explicitly set _recursions = 0. assert (_recursions == 0 ， "invariant") ; assert (_owner == Self， "invariant") ; // CONSIDER: set or assert OwnerIsThread == 1 return ; } // 线程重入，recursions++ if (cur == Self) { // TODO-FIXME: check for integer overflow! BUGID 6557169. _recursions ++ ; return ; } // 如果当前线程是第一次进入该monitor，设置_recursions为1，_owner为当前线程 此处省略锁的自旋优化等操作，统一放在后面 synchronzied优化中说。 以上代码的具体流程概括如下： 1. 通过CAS尝试把monitor的owner字段设置为当前线程。 2. 如果设置之前的owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行 recursions ++ ，记录重入的次数。 3. 如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获 得锁并返回。 4. 如果获取锁失败，则等待锁的释放。 monitor等待 竞争失败等待调用的是ObjectMonitor对象的EnterI方法（位于： src/share/vm/runtime/objectMonitor.cpp），源码如下所示： if (Self->is_lock_owned ((address)cur)) { assert (_recursions == 0， "internal state error"); _recursions = 1 ; // Commute owner from a thread-specific on-stack BasicLockObject address to // a full-fledged "Thread *". _owner = Self ; OwnerIsThread = 1 ; return ; } // 省略一些代码 for (;;) { jt->set_suspend_equivalent(); // cleared by handle_special_suspend_equivalent_condition() // or java_suspend_self() // 如果获取锁失败，则等待锁的释放； EnterI (THREAD) ; if (!ExitSuspendEquivalent(jt)) break ; // // We have acquired the contended monitor， but while we were // waiting another thread suspended us. We don't want to enter // the monitor while suspended because that would surprise the // thread that suspended us. // _recursions = 0 ; _succ = NULL ; exit (false， Self) ; jt->java_suspend_self(); } Self->set_current_pending_monitor(NULL); } 此处省略锁的自旋优化等操作，统一放在后面 synchronzied优化中说。以上代码的具体流程概括如下： 通过CAS尝试把monitor的owner字段设置为当前线程。 如果设置之前的owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行recursions ++ ，记录重入的次数。 如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获得锁并返回。 如果获取锁失败，则等待锁的释放。 monitor等待竞争失败等待调用的是ObjectMonitor对象的EnterI方法（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所示： void ATTR ObjectMonitor::EnterI (TRAPS) { Thread * Self = THREAD ; // Try the lock - TATAS if (TryLock (Self) > 0) { assert (_succ != Self , "invariant") ; assert (_owner == Self , "invariant") ; assert (_Responsible != Self , "invariant") ; return ; } if (TrySpin (Self) > 0) { assert (_owner == Self , "invariant") ; assert (_succ != Self , "invariant") ; assert (_Responsible != Self , "invariant") ; return ; } // 省略部分代码 // 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ； ObjectWaiter node(Self) ; Self->_ParkEvent->reset() ; node._prev = (ObjectWaiter *) 0xBAD ; node.TState = ObjectWaiter::TS_CXQ ; // 通过CAS把node节点push到_cxq列表中 ObjectWaiter * nxt ; for (;;) { node._next = nxt = _cxq ; if (Atomic::cmpxchg_ptr (&node， &_cxq， nxt) == nxt) break ; // Interference - the CAS failed because _cxq changed. Just retry. // As an optional optimization we retry the lock. if (TryLock (Self) > 0) { assert (_succ != Self ， "invariant") ; assert (_owner == Self ， "invariant") ; assert (_Responsible != Self ， "invariant") ; return ; } } // 省略部分代码 for (;;) { // 线程在被挂起前做一下挣扎，看能不能获取到锁 if (TryLock (Self) > 0) break ; assert (_owner != Self， "invariant") ; if ((SyncFlags & 2) && _Responsible == NULL) { Atomic::cmpxchg_ptr (Self， &_Responsible， NULL) ; } // park self if (_Responsible == Self || (SyncFlags & 1)) { TEVENT (Inflated enter - park TIMED) ; Self->_ParkEvent->park ((jlong) RecheckInterval) ; // Increase the RecheckInterval， but clamp the value. RecheckInterval *= 8 ; if (RecheckInterval > 1000) RecheckInterval = 1000 ; } else { TEVENT (Inflated enter - park UNTIMED) ; // 通过park将当前线程挂起，等待被唤醒 Self->_ParkEvent->park() ; } if (TryLock(Self) > 0) break ; // 省略部分代码 } // 省略部分代码 } 当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁，TryLock方法实现如下： int ObjectMonitor::TryLock (Thread * Self) { for (;;) { void * own = _owner ; if (own != NULL) return 0 ; if (Atomic::cmpxchg_ptr (Self， &_owner， NULL) == NULL) { // Either guarantee _recursions == 0 or set _recursions = 0. assert (_recursions == 0， "invariant") ; assert (_owner == Self， "invariant") ; // CONSIDER: set or assert that OwnerIsThread == 1 return 1 ; } // The lock had been free momentarily， but we lost the race to the lock. // Interference -- the CAS failed. // We can either return -1 or retry. // Retry doesn't make as much sense because the lock was just acquired. if (true) return -1 ; } } 以上代码的具体流程概括如下： 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ。 在for循环中，通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node节点push到_cxq列表中。 node节点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当前线程挂起，等待被唤醒。 当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。 monitor释放当某个持有锁的线程执行完同步代码块时，会进行锁的释放，给其它线程机会执行同步代码，在HotSpot中，通过退出monitor的方式实现锁的释放，并通知被阻塞的线程，具体实现位于ObjectMonitor的exit方法中。（位于：src/share/vm/runtime/objectMonitor.cpp），源码如下所示： void ATTR ObjectMonitor::exit(bool not_suspended， TRAPS) { Thread * Self = THREAD ; // 省略部分代码 if (_recursions != 0) { _recursions--; // this is simple recursive enter TEVENT (Inflated exit - recursive) ; return ; } // 省略部分代码 ObjectWaiter * w = NULL ; int QMode = Knob_QMode ; // qmode = 2：直接绕过EntryList队列，从cxq队列中获取线程用于竞争锁 if (QMode == 2 && _cxq != NULL) { w = _cxq ; assert (w != NULL， "invariant") ; assert (w->TState == ObjectWaiter::TS_CXQ， "Invariant") ; ExitEpilog (Self， w) ; return ; } // qmode =3：cxq队列插入EntryList尾部； if (QMode == 3 && _cxq != NULL) { w = _cxq ; for (;;) { assert (w != NULL， "Invariant") ; ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， &_cxq， w) ; if (u == w) break ; w = u ; } assert (w != NULL ， "invariant") ; ObjectWaiter * q = NULL ; ObjectWaiter * p ; for (p = w ; p != NULL ; p = p->_next) { guarantee (p->TState == ObjectWaiter::TS_CXQ， "Invariant") ; p->TState = ObjectWaiter::TS_ENTER ; p->_prev = q ; q = p ; } ObjectWaiter * Tail ; for (Tail = _EntryList ; Tail != NULL && Tail->_next != NULL ; Tail = Tail->_next) ; if (Tail == NULL) { _EntryList = w ; } else { Tail->_next = w ; w->_prev = Tail ; } } // qmode =4：cxq队列插入到_EntryList头部 if (QMode == 4 && _cxq != NULL) { w = _cxq ; for (;;) { assert (w != NULL， "Invariant") ; ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， &_cxq， w) ; if (u == w) break ; w = u ; } assert (w != NULL ， "invariant") ; ObjectWaiter * q = NULL ; ObjectWaiter * p ; for (p = w ; p != NULL ; p = p->_next) { guarantee (p->TState == ObjectWaiter::TS_CXQ， "Invariant") ; p->TState = ObjectWaiter::TS_ENTER ; p->_prev = q ; q = p ; } if (_EntryList != NULL) { q->_next = _EntryList ; _EntryList->_prev = q ; } _EntryList = w ; } w = _EntryList ; if (w != NULL) { assert (w->TState == ObjectWaiter::TS_ENTER， "invariant") ; ExitEpilog (Self， w) ; return ; } w = _cxq ; if (w == NULL) continue ; for (;;) { assert (w != NULL， "Invariant") ; ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (NULL， &_cxq， w) ; if (u == w) break ; w = u ; } TEVENT (Inflated exit - drain cxq into EntryList) ; assert (w != NULL ， "invariant") ; assert (_EntryList == NULL ， "invariant") ; if (QMode == 1) { // QMode == 1 : drain cxq to EntryList， reversing order // We also reverse the order of the list. ObjectWaiter * s = NULL ; ObjectWaiter * t = w ; ObjectWaiter * u = NULL ; while (t != NULL) { guarantee (t->TState == ObjectWaiter::TS_CXQ， "invariant") ; t->TState = ObjectWaiter::TS_ENTER ; u = t->_next ; t->_prev = u ; t->_next = s ; s = t; t = u ; } _EntryList = s ; assert (s != NULL， "invariant") ; } else { // QMode == 0 or QMode == 2 _EntryList = w ; ObjectWaiter * q = NULL ; ObjectWaiter * p ; for (p = w ; p != NULL ; p = p->_next) { guarantee (p->TState == ObjectWaiter::TS_CXQ， "Invariant") ; p->TState = ObjectWaiter::TS_ENTER ; p->_prev = q ; q = p ; } } if (_succ != NULL) continue; w = _EntryList ; if (w != NULL) { guarantee (w->TState == ObjectWaiter::TS_ENTER， "invariant") ; ExitEpilog (Self， w) ; return ; } } } 退出同步代码块时会让_recursions减1，当_recursions的值减为0时，说明线程释放了锁。 根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过 ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由unpark完成，实现 如下： void ObjectMonitor::ExitEpilog (Thread * Self， ObjectWaiter * Wakee) { assert (_owner == Self， "invariant") ; _succ = Knob_SuccEnabled ? Wakee->_thread : NULL ; ParkEvent * Trigger = Wakee->_event ; Wakee = NULL ; // Drop the lock OrderAccess::release_store_ptr (&_owner， NULL) ; OrderAccess::fence() ; // ST _owner vs LD in unpark() if (SafepointSynchronize::do_call_back()) { TEVENT (unpark before SAFEPOINT) ; } DTRACE_MONITOR_PROBE(contended__exit， this， object()， Self); Trigger->unpark() ; // 唤醒之前被pack()挂起的线程. // Maintain stats and report events to JVMTI if (ObjectMonitor::_sync_Parks != NULL) { ObjectMonitor::_sync_Parks->inc() ; } } 被唤醒的线程，会回到 void ATTR ObjectMonitor::EnterI (TRAPS) 的第600行，继续执行monitor的竞争 // park self if (_Responsible == Self || (SyncFlags & 1)) { TEVENT (Inflated enter - park TIMED) ; Self->_ParkEvent->park ((jlong) RecheckInterval) ; // Increase the RecheckInterval， but clamp the value. RecheckInterval *= 8 ; if (RecheckInterval > 1000) RecheckInterval = 1000 ; } else { TEVENT (Inflated enter - park UNTIMED) ; Self->_ParkEvent->park() ; } if (TryLock(Self) > 0) break ; monitor是重量级锁可以看到ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数，执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个时候就会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized是Java语言中是一个重量级(Heavyweight)的操作。]]></content>
      <tags>
        <tag>synchronized</tag>
        <tag>monitor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized详解]]></title>
    <url>%2F2020%2F03%2F26%2Fsynchronized-xiang-jie%2F</url>
    <content type="text"><![CDATA[线程安全线程安全产生的原因 存在共享数据（也称临界资源） 操作共享数据的线程代码有多条 因此，引入了互斥锁的概念，即一个共享数据只能被一个线程访问，其他线程需要等待（阻塞），直至当前线程处理完毕释放该锁。 所以，synchronized方法就保证了同一时刻只有一个线程对方法或者代码块有共享数据的操作。而且，synchronized保证了一个线程对共享变量操作的变化被其他线程看到（可以替代volatile功能）。 Synchronized就是内置锁，是java语言特性提供的内置锁，其获得锁和释放锁是隐式的（进入代码块就是获得锁，走出代码就是释放锁）。java.util.concurrent.locks 包中的锁是显示锁，需要进行lock和unlock。 首先，synchronized可以修饰类、方法（实例方法和静态方法）和代码块（修饰代码块实现同步），区别就是作用范围的不同：修饰类的时候和修饰静态方法是一样的，都是给所有的对象加了同一把锁；修饰实例方法时作用范围就是整个函数，给当前实例加锁；修饰代码块时作用范围就是大括号内的内容，对给定的对象加锁。 其次，synchronized不能被继承，不能使用Synchronized关键字修饰接口方法；构造方法也不能用Synchronized。 synchronized的使用当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。 需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。 synchronized的可重入性可重入特性指同一个线程在获得这个锁后，可以再次获得该锁 /** * @author yang * @date 2020/3/26 下午 6:40 */ public class Synchronized2 { public static void main(String[] args) { Runnable runnable=()->{ synchronized(Synchronized2.class){ System.out.println(Thread.currentThread().getName()+"进入同步代码块一"); synchronized(Synchronized2.class){ System.out.println(Thread.currentThread().getName()+"进入同步代码块二"); } } }; new Thread(runnable,"线程一").start(); new Thread(runnable,"线程二").start(); } } 当线程一进入到第一个同步代码块的时候，synchronized的锁对象有一个计数器(recurslons变量),会记录线程获得几次锁，此时如果线程二发现该锁对象的计数器不为0，那么线程二就在外部等待。 可重入的好处 可以避免死锁 原因，如果同一个线程没有重入性，那么线程就会卡在第二次获得相同锁，那么就会死锁 可以让我们更好的封装代码。 总结synchronized是可重入锁，内部锁对象中会有一个计数器记录线程获取几次锁，在执行完同步代码块时，计数器的数量会-1，当计数器为0的时候，就意味着该线程释放了这个锁。 Synchronized不可中断特性lock是可中断锁，而synchronized 不是可中断锁 ​ 线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定， ​ 如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断 ​ 如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情 ​ ReentrantLock获取锁定与三种方式： lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁 tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false； tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false； lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断 什么是不可中断一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如歌一个线程不释放锁，第二个线程会一直阻塞或者等待，不可中断 Synchronized不可中断演示public class Synchronized2 { public static void main(String[] args) throws InterruptedException { Runnable runnable=()->{ synchronized(Synchronized2.class){ System.out.println(Thread.currentThread().getName()+"进入了同步代码块"); try { Thread.sleep(99999999); } catch (InterruptedException e) { e.printStackTrace(); } } }; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(1000); Thread thread1 = new Thread(runnable); thread1.start(); Thread.sleep(1000); thread1.interrupt();//中断线程2 System.out.println(thread1.getName()+"状态为"+thread1.getState()); } } // 结果为 //Thread-0进入了同步代码块 //Thread-1状态为BLOCKED Loke 不可中断演示public class Synchronized2 { private static Lock loke=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Runnable runnable=()->{ loke.lock(); System.out.println(Thread.currentThread().getName()+"进入了同步代码块"); try { Thread.sleep(99999999); } catch (InterruptedException e) { e.printStackTrace(); } loke.unlock(); }; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(1000); Thread thread1 = new Thread(runnable); thread1.start(); Thread.sleep(1000); thread1.interrupt();//中断线程2 System.out.println(thread1.getName()+"状态为"+thread1.getState()); } } //Thread-0进入了同步代码块 //Thread-1状态为WAITING Loke 可中断演示public class Synchronized2 { private static Lock loke=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Runnable runnable=()->{ boolean b=false; try { b = loke.tryLock(3, TimeUnit.SECONDS); if(b){ System.out.println(Thread.currentThread().getName()+"进入了同步代码块"); Thread.sleep(99999999); }else{ System.out.println("在指定时间内没有获取到锁,自动释放锁"); } } catch (InterruptedException e) { e.printStackTrace(); }finally { if(b){ loke.unlock(); System.out.println("释放锁"); } } }; Thread thread = new Thread(runnable); thread.start(); Thread.sleep(1000); Thread thread1 = new Thread(runnable); thread1.start(); Thread.sleep(1000); } } //结果 //Thread-0进入了同步代码块 //在指定时间内没有获取到锁,自动释放锁 Synchronized字节码解释有如下代码 public class Synchronized3 { public static void main(String[] args) { synchronized (Synchronized3.class){ System.out.println("1"); } } public static synchronized void method(){ System.out.println("2"); } } main方法其字节码指令 0 ldc #2 &lt;thread/synchronized1/Synchronized3> 2 dup 3 astore_1 4 monitorenter//同步代码块开始的地方 5 getstatic #3 &lt;java/lang/System.out> 8 ldc #4 &lt;1> 10 invokevirtual #5 &lt;java/io/PrintStream.println> 13 aload_1 14 monitorexit//同步代码块结束的地方 15 goto 23 (+8) 18 astore_2 19 aload_1 20 monitorexit 21 aload_2 22 athrow 23 return monitorenter 每个对象都会和一个监视器monitor关联，监视器被占用时会被锁住，其他线程无法来获取该monitor 当JVM执行某个方法内部的monitorenter时，他会尝试去获取当前对象对应的monitor的所有权， monitor的重要成员变量owner：拥有锁的线程 recursions：记录获取锁的次数 执行流程 monitor才是真正的锁，执行monitorenter指令的时候，如果jvm在执行到monitorenter的时候没有关联monitor，虚拟机就会关联一个monitor对象（而且monitor是一个C++对象）， 然后把当前线程存入owner，recusions次数+1，如果这个时候有其他线程执行了这个monitorenter，那么这个线程会检查owner是不是自己，否则就进入阻塞状态 当执行到monitorexit这个指令的时候，会让recusions的次数减一，如果为零了那么就释放了这个锁。 问题分析我们发现这个同步代码块中14行和20行都执行了monitorexit指令，为什么呢？ 我们打开异常表发现，当5行到15行[5,15)这个区间如果发生了异常就会跳转到18行字节码指令，也就是说如果我们这个锁发生了异常，那么就意味着14行中monitorexit字节码不会执行，所以需要有二次释放。 结论Synchronized在遇见异常的时候会自动释放锁 method方法锁 public static synchronized void method(){ System.out.println("2"); } 0 getstatic #3 &lt;java/lang/System.out> 3 ldc #6 &lt;2> 5 invokevirtual #5 &lt;java/io/PrintStream.println> 8 return 我们发现虽然使用了锁但是并没有monitorenter和monitorexit这两条指令，这是为什么呢？ 原因方法信息 上面方法的标记上有synchronized 那么会增加一个ACC_SYNCHRONIZED修饰，会隐式调用monitorenter和monitorexit，在执行前先调用monitorenter在执行后会monitorexit monitor监视器锁下一篇文章会详细解释 synchronized与Lock的区别 synchronized是一个关键字，Lock是一个接口（JDK1.5后） synchronized会自动释放锁，Lock必须手动释放锁 synchronized是不可中断的，Lock可以中断也可以不中断 通过Lock可以知道线程有没有拿到锁，但是synchronized不能 synchronized可以锁住方法和代码块，Lock只能锁住代码块 Lock可以使用读锁提高多线程读效率 synchronized是非公平锁，ReentrantLock是可以控制是否是公平锁]]></content>
      <tags>
        <tag>并发</tag>
        <tag>指令重排</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JMM内存模型]]></title>
    <url>%2F2020%2F03%2F26%2Fjmm-nei-cun-mo-xing%2F</url>
    <content type="text"><![CDATA[Java内存模型——JMM Java的并发采用的是共享内存模型 JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 jMM模型运行过程 在JVM内部，Java内存模型把内存分成了两部分：线程栈区和堆区 JVM中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。 共享变量大多指的是静态变量 运行过程带来的问题假如我们我们有一个共享变量x，假设有两个线程，线程一执行的时候会复制一个变量副本到自己的工作内存，此时线程二也在使用共享变量x,假如说线程一修改了这个变量的值，并且向共享内存中写入了结果，但是由于线程二使用的是自己工作内存中的变量，那么无论如何线程二都看不到这个共享变量x的变化。 解决方案使用volatile可以保证有序性和共享性]]></content>
  </entry>
  <entry>
    <title><![CDATA[并发编程中的三个问题]]></title>
    <url>%2F2020%2F03%2F26%2Fbing-fa-bian-cheng-zhong-de-san-ge-wen-ti%2F</url>
    <content type="text"><![CDATA[可见性对于一个共享变量，一个线程的修改，对于另一个线程来说他不能立刻知道这个值已经被修改. 演示/** * @author yang * @date 2020/3/26 下午 3:30 */ public class LookThread { public static boolean flag=true; public static void main(String[] args) throws InterruptedException { new Thread(() -> { while (flag){ //注意这里不要打印输出 } }).start(); Thread.sleep(1000);//为了效果更明显 flag=false; System.out.println("main函数修改了flag,但是对于另一个线程来说,他并看不见flag的改变"); } } 执行上面的程序你会发现程序不会停止运行，原因就是可见性问题。 运行过程带来的问题假如我们我们有一个共享变量x，假设有两个线程，线程一执行的时候会复制一个变量副本到自己的工作内存，此时线程二也在使用共享变量x,假如说线程一修改了这个变量的值，并且向共享内存中写入了结果，但是由于线程二使用的是自己工作内存中的变量，那么无论如何线程二都看不到这个共享变量x的变化。 解决方案方案一使用volatile可以保证有序性和共享性 /** * @author yang * @date 2020/3/26 下午 3:30 */ public class LookThread { public static volatile boolean flag=true; public static void main(String[] args) throws InterruptedException { new Thread(() -> { while (flag){ //注意这里不要打印输出 } }).start(); Thread.sleep(1000);//为了效果更明显 flag=false; System.out.println("main函数修改了flag,但是对于另一个线程来说,他并看不见flag的改变"); } } 方案二使用synchronized /** * @author yang * @date 2020/3/26 下午 3:30 */ public class LookThread { public static boolean flag=true; static Object obj=new Object(); public static void main(String[] args) throws InterruptedException { new Thread(() -> { while (flag){ synchronized (obj){ } } }).start(); Thread.sleep(1000);//为了效果更明显 flag=false; System.out.println("main函数修改了flag,但是对于另一个线程来说,他并看不见flag的改变"); } } 解决分析volatile和synchronized都能起到刷新了共享内存的作用 原子性原子性（Atomiclty）：在一次或者多次操作中，要么所有的操作都执行，并且都执行不会受到其他因素的干扰而中断，要么所有的操作都不执行 触发原子性问题的条件 数据数据 多个线程争抢相同资源 违反原子性问题演示我们新建10个线程，每个线程都对同一个共享变量进行自增操作，其中每个线程执行10000，那么理想结果应该是10000 package thread.synchronized1; import java.util.ArrayList; /** * @author yang * @date 2020/3/26 下午 3:45 */ public class Atom01 { private static int num=0; public static void main(String[] args) throws InterruptedException { Runnable runnable=()->{ for (int i = 0; i &lt; 1000; i++) { num++; } }; ArrayList&lt;Thread> threads = new ArrayList&lt;>(); for (int i = 0; i &lt; 10; i++) { threads.add(new Thread(runnable)); } for (Thread thread : threads) { thread.start(); } //等待所有线程结束 for (Thread thread : threads) { thread.join(); } System.out.println(num); } } 上面打印的结果不一定是10000 原因分析这是lambad表达式的字节码 0 iconst_0 1 istore_0 2 iload_0 3 sipush 1000 6 if_icmpge 23 (+17) 9 getstatic #14 &lt;thread/synchronized1/Atom01.num&gt; 12 iconst_1 13 iadd 14 putstatic #14 &lt;thread/synchronized1/Atom01.num&gt; 17 iinc 0 by 1 20 goto 2 (-18) 23 return其中最涉及num++的指令为（不准确，先做个标记，底下的字节码分析貌似不正确，到后期我在改，但大体分析是正确的） 9 getstatic #14 &lt;thread/synchronized1/Atom01.num&gt; //获取静态字段 12 iconst_1//把局1位置上的操作数栈，1位置的对应的值就是num的值 13 iadd//指正 14 putstatic #14 &lt;thread/synchronized1/Atom01.num&gt;//把操作数栈的结果保存到原来的位置。也就是说执行自增这个代码需要4条字节码指令，而且这4条代码并不符合原子性操作，即线程一可以先执行，但是线程一执行的太慢，结果这期间其他线程已经执行了自增好多次，然后线程一又把它计算的结果又覆盖了，所以导致了这个问题的发生 使用synchronize解决原子性问题package thread.synchronized1; import java.util.ArrayList; /** * @author yang * @date 2020/3/26 下午 3:45 */ public class Atom01 { private static int num=0; private static Object obj=new Object(); public static void main(String[] args) throws InterruptedException { Runnable runnable=()->{ for (int i = 0; i &lt; 1000; i++) { synchronized (obj.getClass()){ num++; } } }; ArrayList&lt;Thread> threads = new ArrayList&lt;>(); for (int i = 0; i &lt; 10; i++) { threads.add(new Thread(runnable)); } for (Thread thread : threads) { thread.start(); } //等待所有线程结束 for (Thread thread : threads) { thread.join(); } System.out.println(num); } } 有序性指令重排在说有序性之前，我们必须先来聊下指令重排，因为如果没有指令重拍的话，也就不存在有序性问题了。 指令重排是指编译器和处理器在不影响代码单线程执行结果的前提下，对源代码的指令进行重新排序执行。这种重排序执行是一种优化手段，目的是为了处理器内部的运算单元能尽量被充分利用，提升程序的整体运行效率。 为什么要重排序为了提高程序的执行效率，编译器和CPU会对程序中代码进行重排序。 as-if-serial语义as-if-serial语义的意思是：不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的。如果有数据有依赖关系，不能重排序。 //可以这样： int a = 1; int b = 2; int c = a + b; //也可以重排序这样： int b = 2; int a = 1; int c = a + b; import org.openjdk.jcstress.annotations.*; import org.openjdk.jcstress.infra.results.I_Result; /** * @author yang * @date 2020/3/26 下午 4:12 */ @JCStressTest @Outcome(id={"1","4"},expect = Expect.ACCEPTABLE,desc = "ok") @Outcome(id="0",expect = Expect.ACCEPTABLE_INTERESTING,desc = "ERROR") @State public class Test { int num=0; boolean ready=false; @Actor public void actor1(I_Result r){ if(ready){ r.r1=num+num; }else { r.r1=1; } } @Actor public void acotr2(I_Result r){ num=2; ready=true; } } mvn clean install//cake结果 情况1：先执行actor1,这时ready=false，所以结果为1. 情况2：执行到actor2，执行了num=2;和ready=true,线程1执行，这回进入if分支，结果为4。 情况3：线程2先执行actor2，只执行num=2;但没来得及执行ready=true，线程1执行，还是进入else分支 情况4：由于jvm指令重拍导致ready=true先执行，然后线程一进入if，结果为0]]></content>
      <tags>
        <tag>不准确</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程池第二天-java内置线程池]]></title>
    <url>%2F2020%2F03%2F26%2Fjava-xian-cheng-chi-di-er-tian-java-nei-zhi-xian-cheng-chi%2F</url>
    <content type="text"><![CDATA[ExecutorServiceExecutorService接口是java内置线程池接口 常用方法 方法 说明 List&lt; Runnable &gt; shutdownNow() 停止所有正在执行的任务，暂停处理正在等待的任务，并放回等待执行的任务列表 &lt; T &gt; Future &lt; T &gt; submit(Callable&lt; T &gt; task) 执行带返回值的任务，返回一个Future对象 Future&lt; ? &gt; submit(Runnable Task) 执行Runnable任务，并返回一个标识该任务的Future &lt; T &gt; Future&lt; T &gt; submit(Runnable task, T Result) 执行Runnable任务，并返回一个标识该任务的Future void shutdown() 启动一次顺序关闭，执行以前提交的任务，但不接受新任务]]></content>
      <tags>
        <tag>java</tag>
        <tag>自定义</tag>
        <tag>线程</tag>
        <tag>线程池</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程池第一天，自定义线程池]]></title>
    <url>%2F2020%2F03%2F26%2Fjava-xian-cheng-chi-di-yi-tian-zi-ding-yi-xian-cheng-chi%2F</url>
    <content type="text"><![CDATA[什么是线程池线程池就是提前创建若干个线程，如果有任务需要处理，线程池里的线程就会处理任务，处理完之后线程并不会被销毁，而是等待下一个任务。由于创建和销毁线程都是消耗系统资源的，所以当你想要频繁的创建和销毁线程的时候就可以考虑使用线程池来提升系统的性能。 为什么使用线程池为了减少创建和销毁线程的次数，让每个线程可以多次使用,可根据系统情况调整执行的线程数量，防止消耗过多内存,所以我们可以使用线程池. 使用线程池的优势 线程池的重用 ​ 线程的创建和销毁的开销是巨大的，而通过线程池的重用大大减少了这些不必要的开销，当然既然少了这么多消费内存的开销，其线程执行速度也是突飞猛进的提升。 控制线程池的并发数 线程池可以对线程进行管理 线程池可以提供定时、定期、单线程、并发数控制等功能。比如通过ScheduledThreadPool线程池来执行S秒后，每隔N秒执行一次的任务。 可以让任务和线程分离 线程池工作流程1、如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务 2、如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列 3、如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务 4、如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException 参数解释 int corePoolSize 该线程池中核心线程数最大值 。线程池新建线程的时候，如果当前线程总数小于corePoolSize，则新建的是核心线程，如果超过corePoolSize，则新建的是非核心线程。核心线程默认情况下会一直存活在线程池中，即使这个核心线程啥也不干(闲置状态)。 int maximumPoolSize 该线程池中线程总数最大值线程总数 = 核心线程数 + 非核心线程数。 long keepAliveTime 该线程池中非核心线程闲置超时时长。一个非核心线程，如果不干活(闲置状态)的时长超过这个参数所设定的时长，就会被销毁掉。 TimeUnit unit keepAliveTime的单位，TimeUnit是一个枚举类型 BlockingQueue workQueue 该线程池中的任务队列。维护着等待执行的Runnable对象当所有的核心线程都在干活时，新添加的任务会被添加到这个队列中等待处理，如果队列满了，则新建非核心线程执行任务。]]></content>
      <tags>
        <tag>java</tag>
        <tag>自定义</tag>
        <tag>线程</tag>
        <tag>线程池</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO详解]]></title>
    <url>%2F2020%2F03%2F25%2Fnio-xiang-jie%2F</url>
    <content type="text"><![CDATA[高并发量引起的问题一个使用传统阻塞I/O的系统,如果还是使用传统的一个请求对应一个线程这种模式,一旦有高并发的大量请求,就会有如下问题： 1、线程不够用, 就算使用了线程池复用线程也无济于事; 2、阻塞I/O模式下,会有大量的线程被阻塞,一直在等待数据,这个时候的线程被挂起,只能干等,CPU利用率很低,换句话说,系统的吞吐量差; 3、如果网络I/O堵塞或者有网络抖动或者网络故障等,线程的阻塞时间可能很长。整个系统也变的不可靠; 什么是NIOjava.nio全称java non-blocking IO（实际上是 new io），是指JDK 1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。 HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。 IO和NIO的区别原有的 IO 是面向流的、阻塞的，NIO 则是面向块的、非阻塞的。 怎么理解IO是面向流的、阻塞的java1.4以前的io模型，一连接对一个线程。 原始的IO是面向流的，不存在缓存的概念。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区 Java IO的各种流是阻塞的，这意味着当一个线程调用read或 write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。 阻塞I/O模型 怎么理解NIO是面向块的、非阻塞的NIO是面向缓冲区的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来,根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个。 NIO的核心实现在标准IO API中，你可以操作字节流和字符流，但在新IO中，你可以操作通道和缓冲，数据总是从通道被读取到缓冲中或者从缓冲写入到通道中。 NIO核心API Channel, Buffer, Selector 通道ChannelNIO的通道类似于流，但有些区别如下： 通道可以同时进行读写，而流只能读或者只能写 通道可以实现异步读写数据 通道可以从缓冲读数据，也可以写数据到缓冲 Channel的实现这些是Java NIO中最重要的通道的实现： FileChannel DatagramChannel SocketChannel ServerSocketChannel FileChannel 从文件中读写数据。 DatagramChannel 能通过UDP读写网络中的数据。 SocketChannel 能通过TCP读写网络中的数据。 ServerSocketChannel可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。 基本的 Channel 示例下面是一个使用FileChannel读取数据到Buffer中的示例： RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw"); FileChannel inChannel = aFile.getChannel(); ByteBuffer buf = ByteBuffer.allocate(48); int bytesRead = inChannel.read(buf); while (bytesRead != -1) { System.out.println("Read " + bytesRead); buf.flip(); while(buf.hasRemaining()){ System.out.print((char) buf.get()); } buf.clear(); bytesRead = inChannel.read(buf); } aFile.close(); 缓存Buffer缓冲区本质上是一个可以写入数据的内存块，然后可以再次读取，该对象提供了一组方法，可以更轻松地使用内存块，使用缓冲区读取和写入数据通常遵循以下四个步骤： 写数据到缓冲区； 调用buffer.flip()方法； 从缓冲区中读取数据； 调用buffer.clear()或buffer.compat()方法； 当向buffer写入数据时，buffer会记录下写了多少数据，一旦要读取数据，需要通过flip()方法将Buffer从写模式切换到读模式，在读模式下可以读取之前写入到buffer的所有数据，一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。 Buffer在与Channel交互时，需要一些标志: buffer的大小/容量 - Capacity 作为一个内存块，Buffer有一个固定的大小值，用参数capacity表示。 当前读/写的位置 - Position 当写数据到缓冲时，position表示当前待写入的位置，position最大可为capacity – 1；当从缓冲读取数据时，position表示从当前位置读取。 信息末尾的位置 - limit 在写模式下，缓冲区的limit表示你最多能往Buffer里写多少数据； 写模式下，limit等于Buffer的capacity，意味着你还能从缓冲区获取多少数据。 缓冲区常用的操作 向缓冲区写数据： 从Channel写到Buffer； 通过Buffer的put方法写到Buffer中； 从缓冲区读取数据： 从Buffer中读取数据到Channel； 通过Buffer的get方法从Buffer中读取数据； flip方法： ​ 将Buffer从写模式切换到读模式，将position值重置为0，limit的值设置为之前position的值； clear方法 vs compact方法： ​ clear方法清空缓冲区；compact方法只会清空已读取的数据，而还未读取的数据继续保存在Buffer中； Buffer使用演示package nio; import java.nio.ByteBuffer; /** * @author yang * @date 2020/3/24 下午 3:31 */ /** *position 当前位置 *limit 最大可读位置(后边的内容不可读) *capacity 总容量 * mark 暂存的posotion位置 * 0 &lt;= position &lt;= limit &lt;= capacity */ public class NioTest { public static void main(String[] args) { ByteBuffer byteBuffer = ByteBuffer.allocate(1024);//分配非直接缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024);//分配直接缓冲区 getCapatity(byteBuffer); System.out.println("存入数据"); String str="abcd"; byteBuffer.put(str.getBytes()); getCapatity(byteBuffer); System.out.println("切换读取模式"); byteBuffer.flip(); getCapatity(byteBuffer); System.out.println("读取数据"); //虽然改变了position的位置但是,里面数据并没有被清空.里面的数据处于"被遗忘状态" byte[] bytes; byteBuffer.get(bytes=new byte[byteBuffer.limit()]); System.out.println("读取到的内容为"+new String(bytes,0,bytes.length)); getCapatity(byteBuffer); System.out.println("切换到写入模式"); byteBuffer.rewind(); getCapatity(byteBuffer); System.out.println("清空缓冲区"); //里面数据并没有被清空.里面的数据处于"被遗忘状态" byteBuffer.clear(); getCapatity(byteBuffer); byteBuffer.mark();//暂存标记 } public static void getCapatity(ByteBuffer byteBuffer){ System.out.println("----------capacity-----------"); System.out.println("position"+byteBuffer.position()); System.out.println("limit"+byteBuffer.limit()); System.out.println("capacity"+byteBuffer.capacity()); } } 注意只有ByteBuffer可以分配直接缓冲区 通道之间传输数据在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel（译者注：channel中文常译作通道）传输到另外一个channel。 transferFrom() FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（译者注：这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子： RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw"); FileChannel fromChannel = fromFile.getChannel(); RandomAccessFile toFile = new RandomAccessFile("toFile.txt", "rw"); FileChannel toChannel = toFile.getChannel(); long position = 0; long count = fromChannel.size(); toChannel.transferFrom(position, count, fromChannel); 方法的输入参数position表示从position处开始向目标文件写入数据，count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节，则所传输的字节数要小于请求的字节数。此外要注意，在SoketChannel的实现中，SocketChannel只会传输此刻准备好的数据（可能不足count字节）。因此，SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。 transferTo() transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子： RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw"); FileChannel fromChannel = fromFile.getChannel(); RandomAccessFile toFile = new RandomAccessFile("toFile.txt", "rw"); FileChannel toChannel = toFile.getChannel(); long position = 0; long count = fromChannel.size(); fromChannel.transferTo(position, count, toChannel); 是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外，其他的都一样。上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。 FileChannelJava NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。 FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。 打开FileChannel在使用FileChannel之前，必须先打开它。但是，我们无法直接打开一个FileChannel，需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例： RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw"); FileChannel inChannel = aFile.getChannel(); 从FileChannel读取数据调用多个read()方法之一从FileChannel中读取数据。如： ByteBuffer buf = ByteBuffer.allocate(48); int bytesRead = inChannel.read(buf); 首先，分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。 然后，调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1，表示到了文件末尾。 向FileChannel写数据使用FileChannel.write()方法向FileChannel写数据，该方法的参数是一个Buffer。如： String newData = "New String to write to file..." + System.currentTimeMillis(); ByteBuffer buf = ByteBuffer.allocate(48); buf.clear(); buf.put(newData.getBytes()); buf.flip(); while(buf.hasRemaining()) { channel.write(buf); } 注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节，因此需要重复调用write()方法，直到Buffer中已经没有尚未写入通道的字节。 关闭FileChannel用完FileChannel后必须将其关闭。如： channel.close(); FileChannel的position方法有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。 也可以通过调用position(long pos)方法设置FileChannel的当前位置。 这里有两个例子: long pos = channel.position(); channel.position(pos +123); 如果将位置设置在文件结束符之后，然后试图从文件通道中读取数据，读方法将返回-1 —— 文件结束标志。 如果将位置设置在文件结束符之后，然后向通道中写数据，文件将撑大到当前位置并写入数据。这可能导致“文件空洞”，磁盘上物理文件中写入的数据间有空隙。 FileChannel的size方法FileChannel实例的size()方法将返回该实例所关联文件的大小。如: long fileSize = channel.size(); FileChannel的truncate方法可以使用FileChannel.truncate()方法截取一个文件。截取文件时，文件将中指定长度后面的部分将被删除。如： channel.truncate(1024); 这个例子截取文件的前1024个字节。 FileChannel的force方法FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点，需要调用force()方法。 force()方法有一个boolean类型的参数，指明是否同时将文件元数据（权限信息等）写到磁盘上。 下面的例子同时将文件数据和元数据强制写到磁盘上： channel.force(true); 通道使用的Demopackage nio; import java.io.IOException; import java.nio.MappedByteBuffer; import java.nio.channels.FileChannel; import java.nio.channels.FileChannel.MapMode; import java.nio.file.Paths; import java.nio.file.StandardOpenOption; /** * @author yang * @date 2020/3/24 下午 4:55 */ public class NioTest1 { public static void main(String[] args) throws IOException { int star= (int) System.currentTimeMillis(); run2("E:/java.zip","E:/1.zip"); int end= (int) System.currentTimeMillis(); System.out.println("一共耗时"+(end-star)+"纳秒"); } /** * 直接缓冲区 */ public static void run2(String fromPath,String toPath) throws IOException { FileChannel fromChanel=null; FileChannel toChanel=null; MappedByteBuffer map=null; MappedByteBuffer map1=null; try { fromChanel = FileChannel.open(Paths.get(fromPath), StandardOpenOption.READ); toChanel = FileChannel.open(Paths.get(toPath), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE); //生成内存映射文件 map = fromChanel.map(MapMode.READ_ONLY, 0, fromChanel.size()); map1 = toChanel.map(MapMode.READ_WRITE, 0, fromChanel.size()); //进行读写操作 byte[] bytes=new byte[map.limit()]; map.get(bytes); map1.put(bytes); }catch (Exception e){ System.out.println(e.getMessage()); }finally { fromChanel.close(); toChanel.close(); } } /** * 直接缓冲区,通道到通道 */ public static void run3(String fromPath,String toPath) throws IOException { FileChannel fromChanel=null; FileChannel toChannel=null; fromChanel= FileChannel.open(Paths.get(fromPath), StandardOpenOption.READ); toChannel = FileChannel.open(Paths.get(toPath), StandardOpenOption.WRITE,StandardOpenOption.READ,StandardOpenOption.CREATE); fromChanel.transferTo(0, fromChanel.size(), toChannel); toChannel.close(); fromChanel.close(); } } SocketChannelJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel： 打开一个SocketChannel并连接到互联网上的某台服务器。 一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。 打开 SocketChannel下面是SocketChannel的打开方式： SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80)); 关闭 SocketChannel当用完SocketChannel之后调用SocketChannel.close()关闭SocketChannel： socketChannel.close(); 从 SocketChannel 读取数据要从SocketChannel中读取数据，调用一个read()的方法之一。以下是例子： ByteBuffer buf = ByteBuffer.allocate(48); int bytesRead = socketChannel.read(buf); 首先，分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。 然后，调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1，表示已经读到了流的末尾（连接关闭了）。 写入 SocketChannel写数据到SocketChannel用的是SocketChannel.write()方法，该方法以一个Buffer作为参数。示例如下： String newData = System.currentTimeMillis(); ByteBuffer buf = ByteBuffer.allocate(48); buf.clear(); buf.put(newData.getBytes()); buf.flip(); while(buf.hasRemaining()) { channel.write(buf); } 注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以，我们重复调用write()直到Buffer没有要写的字节为止。 非阻塞模式可以设置 SocketChannel 为非阻塞模式（non-blocking mode）.设置之后，就可以在异步模式下调用connect(), read() 和write()了。 connect()如果SocketChannel在非阻塞模式下，此时调用connect()，该方法可能在连接建立之前就返回了。为了确定连接是否建立，可以调用finishConnect()的方法。像这样： socketChannel.configureBlocking(false); socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80)); while(! socketChannel.finishConnect() ){ } write()非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了，这里就不赘述了。 read()非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。 非阻塞模式与选择器非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。 ServerSocketChannelJava NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在 java.nio.channels包中。 这里有个例子： ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(9999)); while(true){ SocketChannel socketChannel = serverSocketChannel.accept(); } 打开 ServerSocketChannel通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel.如： ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); 关闭 ServerSocketChannel通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel. 如： serverSocketChannel.close(); 监听新进来的连接通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。 通常不会仅仅只监听一个连接,在while循环中调用 accept()方法. 如下面的例子： while(true){ SocketChannel socketChannel = serverSocketChannel.accept(); } 当然,也可以在while循环中使用除了true以外的其它退出准则。 非阻塞模式ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null. ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); serverSocketChannel.socket().bind(new InetSocketAddress(9999)); serverSocketChannel.configureBlocking(false); while(true){ SocketChannel socketChannel = serverSocketChannel.accept(); if(socketChannel != null){ } }]]></content>
      <tags>
        <tag>java</tag>
        <tag>io</tag>
        <tag>nio</tag>
        <tag>aio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合之ArrayList原理详解]]></title>
    <url>%2F2020%2F03%2F23%2Fjava-ji-he-zhi-arraylist-yuan-li-xiang-jie%2F</url>
    <content type="text"><![CDATA[数据结构ArrayList实现的是动态数组，我们都知道，数组是不能自由扩展的，但是ArrayList是可以动态扩展的，当需要添加新的元素时且空间不足就会重新分配一个原来1.5倍长度的新数组，然后把旧数组中的元素复制到新的数组。 特点ArrayList 特点是查询速度快，增加删除慢,线程不安全。 LinkedList 特点查询慢，增加删除快。 Vector 特点是查询速度快，增加删除慢,线程安全，而且Vector就是ArrayList的换皮，就是方法上多了些synchronized 继承体系 接口 Iterable&lt; T &gt; 实现这个接口允许使用增强for循环 Collection 所有的集合类都要实现这个根接口，他定义了集合的基本常用方法(比如CRUD方法，清空方法，获取集合元素个数方法等). List&lt; E &gt; 有序集合，这个接口可以精确控制列表中每个元素的插入位置，用户可以通过整数索引访问元素，并且这个列表允许重复元素 RandomAccess 标志接口（即该接口起到一个标志作用，没有任何抽象方法），实现这个接口支持快速随机访问 for (int i=0, n=list.size(); i &lt; n; i++) list.get(i); //比这个循环运行得更快： for (Iterator i=list.iterator(); i.hasNext(); ) i.next(); Cloneable 标志接口 表示对于该类的实例进行复制是合法的，在不实现Cloneable的接口调用对象的克隆方法会导致CloneNotSupportedException异常 Serializable 标志接口 表明该类的实例是可以被序列化和反序列化的 类和抽象类 AbstractCollection&lt; E &gt; 提供了Collection的骨架实现，用于减少实现Collection接口所需要的工作量 AbstractList&lt; E &gt; 提提供了List的骨架实现，用于减少实现List接口所需要的工作量 成员变量 private static final long serialVersionUID = 8683452581122892189L; private static final int DEFAULT_CAPACITY = 10;//默认容量大小 private static final Object[] EMPTY_ELEMENTDATA = {};//空容量数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};//默认空容量数组，下面有transient关键字的详细解释 transient Object[] elementData; // 实际存储对象的数组 private int size;//当前数组长度 transient关键字解释该关键字表示，如果该类被序列化，那么忽略transien标记的元素 private transient Object[] elementData; 假如elementData的长度为10，而其中只有5个元素，那么在序列化的时候只需要存储5个元素，而数组中后面5个元素是不需要存储的。于是将elementData定义为transient，避免了Java自带的序列化机制，并定义了两个方法，实现了自己可控制的序列化操作。 private void writeObject(java.io.ObjectOutputStream s) private void readObject(java.io.ObjectInputStream s) 构造方法 public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//空长度数组 } public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA;//空长度数组 } else { throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); } } public ArrayList(Collection&lt;? extends E> c) {//使用了上限泛型 elementData = c.toArray();//调用父类AbstractCollection的方法转换成数组 if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class)//如果长度合法,就复制数组 elementData = Arrays.copyOf(elementData, size, Object[].class); } else {//否则就为空数组 // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 当我们创建ArrayList这个类的对象时候如果不传入参数，那么就会让elementData指向一个容量为0的数组 当我们创建ArrayList这个类的对象的时候可以传入一个默认长度，如果默认长度为0还是一个空数组，如果不为0但是非法，就抛出异常，否则就创建一个initialCapacity大小的数组 如果我们传入一个集合对象，那么他必须是E的子类，然后把传入集合转换为数组，之后复制到elementData元素中 核心扩容算法方法在介绍其他方法前，我们先介绍一下核心的扩容算法方法 private void grow(int minCapacity) {//传入的大小容量为最小容量 int oldCapacity = elementData.length;//当前数组的长度称为旧容量 int newCapacity = oldCapacity + (oldCapacity >> 1);//新的容量=旧容量*1.5 if (newCapacity - minCapacity &lt; 0)//如果发现1.5倍新容量不能满足预期的最小容量 newCapacity = minCapacity;//就把最小容量作为扩容的容量 if (newCapacity - MAX_ARRAY_SIZE > 0)//如果新的容量特别大(Integer.MAX_VALUE - 8) newCapacity = hugeCapacity(minCapacity);//就会选择使用int最大值或者最大值-8的容量 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);//最后新建一个新的数组，长度是计算后的容量大小，然后将老数组复制进去 } 总结 每次扩容大小是之前的1.5倍 如果扩容1.5倍还不足以装下当前所有元素，那么就把扩容到传入的容量大小 如果最终扩容的大小大于Integer.Max-8，那么就会根据需要扩容到Integer的最大值或者最大值-8 添加方法(add)add(E) public boolean add(E e) { ensureCapacityInternal(size + 1);//是否需要扩容，以及进行扩容，扩容的方法是否合法 elementData[size++] = e;//将e元素追加到数组末尾，并且增加size的值 return true; } private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {//检查当前数组是否是空数组 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);//检查使用默认10容量还是最小容量 } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++;//记录操作次数（下面有详细解释） // overflow-conscious code if (minCapacity - elementData.length > 0)//检查是否需要扩容 grow(minCapacity);//进行扩容 } modCount该字段表示list结构上被修改的次数。结构上的修改指的是那些改变了list的长度大小或者使得遍历过程中产生不正确的结果的其它方式。 该字段被Iterator以及ListIterator的实现类所使用，如果该值被意外更改，Iterator或者ListIterator 将抛出ConcurrentModificationException异常， 这是jdk在面对迭代遍历的时候为了避免不确定性而采取的快速失败原则。 add(int index ,E element) public void add(int index, E element) {//把元素插入指定位置 rangeCheckForAdd(index);//检查插入的下标是否合法（index > size || index &lt; 0） ensureCapacityInternal(size + 1); //是否需要扩容，以及进行扩容，扩容的方法是否合法 System.arraycopy(elementData, index, elementData, index + 1, size - index);//把指定下标及其以后的元素全部复制向后移动一位进行复制 elementData[index] = element;//覆盖指定下标的元素 size++; } private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {//检查当前数组是否是空数组 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);//检查使用默认10容量还是最小容量 } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++;//记录操作次数（下面有详细解释） // overflow-conscious code if (minCapacity - elementData.length > 0)//检查是否需要扩容 grow(minCapacity);//进行扩容 } addAll(Collection&lt;? extends E&gt; c) public boolean addAll(Collection&lt;? extends E> c) { Object[] a = c.toArray();//转换成数组 int numNew = a.length;//带添加数组元素的个数 ensureCapacityInternal(size + numNew); //不说了，这个方法解释很多次了，就是检查扩容和扩容的 System.arraycopy(a, 0, elementData, size, numNew);//复制到末尾 size += numNew;//更新长度 return numNew != 0; } addAll(int index, Collection&lt;? extends E&gt; c) public boolean addAll(int index, Collection&lt;? extends E> c) { rangeCheckForAdd(index);//检查下标是否合法 Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); //扩容 int numMoved = size - index;//计算偏移量 if (numMoved > 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew);//两次复制 size += numNew;//更新长度 return numNew != 0; } 总结 添加元素都要检查是否需要扩容，也就是说如果我们需要频繁插入元素，那么推荐构造方法指定容量大小，可以大大减轻扩容的次数，带来性能上的提升。 修改 public E set(int index, E element) { rangeCheck(index);//校验下标是否合法 E oldValue = elementData(index);//取出旧元素 elementData[index] = element;//更新index下标的元素 return oldValue;//返回更新前的元素 } 真是超级简单了，真的没有其他的可以解释 剩下的就都不说了。真是太简单了。 ConcurrentModificationException异常当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常。 modCount就是修改次数，在具体的实现类中的Iterator中才会使用。在List集合中，ArrayList是List接口的实现类， modCount：表示list集合结构上被修改的次数。（在ArrayList所有涉及结构变化的方法中，都增加了modCount的值） list结构上别修改是指：改变了list的长度的大小或者是遍历结果中产生了不正确的结果的方式。add()和remove()方法会是modCount进行+1操作。modCount被修改后会产生ConcurrentModificationException异常， 这是jdk的快速失败原则。 单线程下产生这个异常 public static void main(String[] args) throws InterruptedException { ArrayList&lt;Integer> list = new ArrayList&lt;Integer>(); list.add(2); Iterator&lt;Integer> iterator = list.iterator(); while(iterator.hasNext()){ Integer integer = iterator.next(); if(integer==2) list.remove(integer); } } 从异常信息可以发现，异常出现在checkForComodification()方法中。 我们不忙看checkForComodification()方法的具体实现，我们先根据程序的代码一步一步看ArrayList源码的实现： 首先看ArrayList的iterator()方法的具体实现，查看源码发现在ArrayList的源码中并没有iterator()这个方法，那么很显然这个方法应该是其父类或者实现的接口中的方法，我们在其父类AbstractList中找到了iterator()方法的具体实现，下面是其实现代码： public Iterator&lt;E> iterator() { return new Itr();} 从这段代码可以看出返回的是一个指向Itr类型对象的引用，我们接着看Itr的具体实现，在AbstractList类中找到了Itr类的具体实现，它是AbstractList的一个成员内部类，下面这段代码是Itr类的所有实现： private class Itr implements Iterator&lt;E> { int cursor = 0; int lastRet = -1; int expectedModCount = modCount; public boolean hasNext() { return cursor != size(); } public E next() { checkForComodification(); try { E next = get(cursor); lastRet = cursor++; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } public void remove() { if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try { AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; } catch (IndexOutOfBoundsException e) { throw new ConcurrentModificationException(); } } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 首先我们看一下它的几个成员变量： cursor：表示下一个要访问的元素的索引，从next()方法的具体实现就可看出 lastRet：表示上一个访问的元素的索引 expectedModCount：表示对ArrayList修改次数的期望值，它的初始值为modCount。 modCount是AbstractList类中的一个成员变量 protected transient int modCount = 0; 该值表示对List的修改次数，查看ArrayList的add()和remove()方法就可以发现，每次调用add()方法或者remove()方法就会对modCount进行加1操作。 好了，到这里我们再看看上面的程序： 当调用list.iterator()返回一个Iterator之后，通过Iterator的hashNext()方法判断是否还有元素未被访问，我们看一下hasNext()方法，hashNext()方法的实现很简单： public boolean hasNext() { return cursor != size();} 如果下一个访问的元素下标不等于ArrayList的大小，就表示有元素需要访问，这个很容易理解，如果下一个访问元素的下标等于ArrayList的大小，则肯定到达末尾了。 然后通过Iterator的next()方法获取到下标为0的元素，我们看一下next()方法的具体实现： public E next() { checkForComodification(); try { E next = get(cursor); lastRet = cursor++; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } 这里是非常关键的地方：首先在next()方法中会调用checkForComodification()方法，然后根据cursor的值获取到元素，接着将cursor的值赋给lastRet，并对cursor的值进行加1操作。初始时，cursor为0，lastRet为-1，那么调用一次之后，cursor的值为1，lastRet的值为0。注意此时，modCount为0，expectedModCount也为0。 接着往下看，程序中判断当前元素的值是否为2，若为2，则调用list.remove()方法来删除该元素。 我们看一下在ArrayList中的remove()方法做了什么： public boolean remove(Object o) { if (o == null) { for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index); return true; } } return false; } private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index,numMoved); elementData[--size] = null; // Let gc do its work} 通过remove方法删除元素最终是调用的fastRemove()方法，在fastRemove()方法中，首先对modCount进行加1操作（因为对集合修改了一次），然后接下来就是删除元素的操作，最后将size进行减1操作，并将引用置为null以方便垃圾收集器进行回收工作。 那么注意此时各个变量的值：对于iterator，其expectedModCount为0，cursor的值为1，lastRet的值为0。 对于list，其modCount为1，size为0。 接着看程序代码，执行完删除操作后，继续while循环，调用hasNext方法()判断，由于此时cursor为1，而size为0，那么返回true，所以继续执行while循环，然后继续调用iterator的next()方法： 注意，此时要注意next()方法中的第一句：checkForComodification()。 在checkForComodification方法中进行的操作是： final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 如果modCount不等于expectedModCount，则抛出ConcurrentModificationException异常。 很显然，此时modCount为1，而expectedModCount为0，因此程序就抛出了ConcurrentModificationException异常。 到这里，想必大家应该明白为何上述代码会抛出ConcurrentModificationException异常了。 关键点就在于：调用list.remove()方法导致modCount和expectedModCount的值不一致。 注意，像使用for-each进行迭代实际上也会出现这种问题。 关键点就在于：调用list.remove()方法导致modCount和expectedModCount的值不一致。 注意，像使用for-each进行迭代实际上也会出现这种问题。 如何实现线程同步方法一使用VectorVector中的方法都是同步方法， 所以是线程安全的 方法二使用Collections.synchronizedList();方法这个类就是使用了装饰则模式，进行了同步处理]]></content>
      <tags>
        <tag>集合</tag>
        <tag>原理</tag>
        <tag>list</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA泛型详解]]></title>
    <url>%2F2020%2F03%2F22%2Fjava-fan-xing-xiang-jie%2F</url>
    <content type="text"><![CDATA[JAVA泛型详解泛型只存在于编译期。 泛型的定义以及存在意义泛型，即“参数化类型”。这是JDK1.5引入的新特性,就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。**而且还可以像参数那样限定传入的类型。** 顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 当我们不指定泛型的时候呢public class EnuTest{ private static int a=0; public static void main(String[] args) throws Exception{ Father stringFather = new Father(); System.out.println(stringFather.get(new Object()).getClass());//Object类型 System.out.println(stringFather.getClass());//stringFather的类型并不受T的影响 } } class Father &lt;T>{ public T get(T e){ return e; } } 为什么泛型里面数据类型不能是基本类型呢？ 因为虚拟机在编译时会把带泛型的转换成Object类型，而基本类型不属于Object类型，所以泛型里面数据类型不能是基本类型。 为什么要使用泛型呢？ Java语言引入泛型的好处是安全简单。泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。 例如：GenericClass{} 一些常用的泛型类型变量： E：元素（Element），多用于java集合框架 K：关键字（Key） N：数字（Number） T：类型（Type） V：值（Value） 如果要实现不同类型的加法，每种类型都需要重载一个add方法 public class NeedGeneric { private static int add(int a, int b) { System.out.println(a + "+" + b + "=" + (a + b)); return a + b; } private static float add(float a, float b) { System.out.println(a + "+" + b + "=" + (a + b)); return a + b; } private static double add(double a, double b) { System.out.println(a + "+" + b + "=" + (a + b)); return a + b; } private static &lt;T extends Number> double add(T a, T b) { System.out.println(a + "+" + b + "=" + (a.doubleValue() + b.doubleValue())); return a.doubleValue() + b.doubleValue(); } public static void main(String[] args) { NeedGeneric1.add(1, 2); NeedGeneric1.add(1f, 2f); NeedGeneric1.add(1d, 2d); NeedGeneric1.add(Integer.valueOf(1), Integer.valueOf(2)); NeedGeneric1.add(Float.valueOf(1), Float.valueOf(2)); NeedGeneric1.add(Double.valueOf(1), Double.valueOf(2)); } } 取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易现“java.lang. ClassCast Exception”异常。 import java.util.ArrayList; import java.util.List; public class NeedGeneric2 { static class C{ } public static void main(String[] args) { List list=new ArrayList(); list.add("A"); list.add("B"); list.add(new C()); list.add(100); //1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。 //2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。 for (int i = 0; i &lt; list.size(); i++) { // System.out.println(list.get(i)); String value= (String) list.get(i); System.out.println(value); } } } 所以使用泛型的意义在于1,适用于多种数据类型执行相同的代码（代码复用） 2, 泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型） 泛型类class MyString &lt;T>{//泛型语法&lt;T,T,T> T str; public T getStr() { return str; } public void setStr(T str) { this.str = str; } } 这个就是泛型类的使用，但要注意的是，这个类是泛型类，方法却不是泛型方法，并且这些普通方便不能是静态的 一个类继承泛型类泛型类继承泛型类class Father &lt;T>{ } class Son&lt;E> extends Father&lt;E>{//要是E,子类和父类必须都是E,要是T,必须都是T } 子类泛型必须要有父类泛型的标识符 如果子类泛型想有新的泛型，只需要新增即可 class Father &lt;T>{ } class Son&lt;E,T> extends Father&lt;E>{//虽然新加入了一个T，但是子类和父类的泛型标识要一致 } 为什么必须这样呢其实原因也很容易想到 假如java允许子类使用泛型的时候不声名父类类型，那么如果子类继承了父类的一些具有父类泛型类型的属性,那么父类的那些泛型应该是什么泛型呢？这样是不是就导致了父类泛型没有了意义。 证明class Father &lt;T>{ } class Son&lt;E> extends Father&lt;String>{//这样子类就可以不用事先声明父类的泛型类型了,原因是已经知道了父类泛型类型 } 事实上这样都是为了保证父类泛型可知 普通类继承泛型类class Father &lt;T>{ } class Son extends Father&lt;String>{//必须指定父类泛型的类型 } 子类继承的时候要标识出来父类的类型 为什么会这样呢其实原因和上面一样，就怕子类不说明父类类型，那么父类类型也就没有意义了 泛型接口普通类实现泛型接口interface InterfaceFather &lt;T>{ } class Son implements InterfaceFather&lt;String>{ } 用法和泛型类一模一样 泛型类实现泛型接口interface InterfaceFather &lt;T>{ } class Son&lt;E> implements InterfaceFather&lt;E>{ } 方法泛型只有在方法的返回值和方法的访问权限修饰符中间声明的泛型的参数才算泛型方法. class Father &lt;T>{ public &lt;E,T> E getValue(T para){ E rel=null; return rel; } } 值得注意的是，泛型方法可以声明为静态的，前提是不能使用到类的非静态方法和非静态变量。 class Father &lt;T>{ public static &lt;V> void getValue(){ } } 还有一点如果方法声明的泛型的标识和类泛型的标识一致，那么方法的泛型标识在这个方法的标识作用域中会覆盖类泛型的标识。 换句话说，如果类泛型标识和方法标识相同那么类标识对这个方法来说是失效的 泛型的通配符问题描述java里面类和类之间是有继承关系 的，比如Cat extends Animals,那么Cat就是Animal的子类，但是集合是没有继承这个概念的，比如List&lt;Cat&gt; catList和List&lt;Animals&gt; animalList你不能说 animalList是catList的父类，所以很难看出来这两个类之间的联系，但是我们现在只想让list里面只加入Animals的子类怎么办呢？ 一种是Animals有多少个子类就定义多少个list，这种方法虽然也可以实现但是Animals如果有一百个，一千个，一万个子类呢你这种方法是不是就太耗时了呢。 第二种就是用通配符来实现。比如：List animals 这个时候animals就只能添加Animals的子类了，一个list搞定。 public class Test { public static void main(String []args){ List&lt;Integer> list = new ArrayList&lt;>(); list.add(1); list.add(2); list.add(3); list.add(4); List&lt;String> stringList = new ArrayList&lt;>(); stringList.add("h"); stringList.add("e"); stringList.add("l"); stringList.add("l"); stringList.add("o"); getList(stringList); getList(list); } //无论传入什么List都会被接收 public static List getList(List&lt;?> list){ return list; } 用List声明的List 不能使用add方法，因为你不知道的类型是什么，但是list.add(null)就可以，因为null是所有类型都有的。举个例子 public static List getList(List&lt;?> list){ // list.add(1);//会报参数不匹配的错误,编译期报错 // list.add("hello");//会报参数不匹配的错误,编译期报错 list.add(null);//添加成功 return list; } 用get方法也只能用Object来接收，因为你不知道你的类型是什么。 public static List getList(List&lt;?> list){ int i = list.get(0); //编译期报错 String j = list.get(1); //编译期报错 Object o = list.get(3); //运行正确 return list; } 但是这样又带来了新的问题，因为他可以传递任意类型List集合的泛型，所有有可能他瞎传，既然泛型就是参数化类型，那么能不能像参数那样限定类型呢。（当然这些限定不是非要使用集合才能使用这些限定的） 上边界通配符号(也叫泛型的上限)可以接收E以及E的子类型的泛型，这里面的E不止是类哦，也可以是接口，看个例子。 //这个是继承了类的用法 public class Test { public static void main(String[] args) { List&lt;Integer> list = new ArrayList&lt;>(); list.add(1); getList(list); List&lt;String> strings = new ArrayList&lt;>(); strings.add("hello"); getList(strings);//编译期报错 } public static List getList(List&lt;? extends Number> list) { return list; } } public class Test { public static void main(String[] args) { List&lt;Integer> list = new ArrayList&lt;>(); list.add(1); getList(list);// 编译期报错 List&lt;Test2> test2s = new ArrayList&lt;>(); getList(test2s); } //上边界为接口的实现，只要是实现了此接口的类都可以被当做泛型传进来 public static List getList(List&lt;? extends Test1> list) { return list; } } interface Test1{ } class Test2 implements Test1{} 以上可知上边界就是你传入的类型必须得是E的子类，或者是实现接口的类。 下边界通配符（泛型的下限） 就是传入的类型必须得是E以及E的父类，举个例子 public class Test { public static void main(String[] args) { List&lt;Animals> animals = new ArrayList&lt;>(); getList(animals); List&lt;Cat> cats = new ArrayList&lt;>(); getList(cats); List&lt;Dog> dogs = new ArrayList&lt;>(); getList(dogs);//编译出错，因为Dog不是Cat的父类 } public static List getList(List&lt;? super Cat> list) { return list; } } class Animals{} class Cat extends Animals{} class Dog extends Animals{} 上下边界通配符的副作用上边界通配符会导致修改失效，但是获取有效 下边界通配符会导致获取有效，但是修改失效 PECS原则频繁往外读取内容的,适合用上界extends。 经常往里插入的,适合用下界super。]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String table详解]]></title>
    <url>%2F2020%2F03%2F21%2Fstring-table-xiang-jie%2F</url>
    <content type="text"><![CDATA[String table又称为String pool，字符串常量池，其存在于堆中(jdk1.8及其以后改的)。最重要的一点，String table中存储的并不是String类型的对象，存储的而是指向String对象的索引，真实对象还是存储在堆中。 String字节码直接使用双引号声明出来的String对象会直接存储在常量池中一定要先记住这句话 在学习之前首先先学习一下String的字节码 案例一/** * @author yang * @date 2020/3/20 下午 1:49 */ public class EnuTest{ public static void main(String[] args){ String a="a"; String b="b"; } } 对应字节码 0 ldc #2 &lt;a&gt;//把符号引用变为字符串对象引用,且加入到StringTable中去 2 astore_1//把字符串对象引用存入局部变量表1位置 3 ldc #3 &lt;b&gt;//把符号引用变为字符串对象引用,且加入到StringTable中去 5 astore_2//把字符串对象引用存入局部变量表1位置 6 return案例二public class EnuTest{ public static void main(String[] args){ String a="a"; String b="b"; String d=a+b;//新加入代码 } } 对应字节码 0 ldc #2 &lt;a&gt; 2 astore_1 3 ldc #3 &lt;b&gt; 5 astore_2 9 new #5 &lt;java/lang/StringBuilder&gt;//创建StringBuilder对象 12 dup 13 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;//调用无参数构造方法 16 aload_1 17 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;//调用append方法追加 20 aload_2 21 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;//调用append方法追加 24 invokevirtual #8 &lt;java/lang/StringBuilder.toString&gt;//调用toString方法打印 27 astore 4 29 returnStringBuilder源码 @Override public String toString() { // Create a copy, don't share the array return new String(value, 0, count);//可以发现String d=a+b;new 了一个新对象，并且这个新对象并没有加入到StringTable（字符串常量池中） } 可以发现String d=a+b;new 了一个新对象，并且这个新对象并没有加入到StringTable（字符串常量池中） 究竟什么时候会存入字符串常量池呢? 经过反复实验发现 直接使用双引号声明出来的String对象会直接存储在常量池中。 演示public class EnuTest{ public static void main(String[] args){ String a=new String("abc")+new String("bcd");//[abc,bcd]存入了常量池 } } 对应字节码文件 0 new #2 &lt;java/lang/StringBuilder&gt; 3 dup 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt; 7 new #4 &lt;java/lang/String&gt; 10 dup 11 ldc #5 &lt;abc&gt;//第一次 13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt; 16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt; 19 new #4 &lt;java/lang/String&gt; 22 dup 23 ldc #8 &lt;bcd&gt;//第二次 25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt; 28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt; 31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt; 34 astore_1 35 return 案例三public class EnuTest{ public static void main(String[] args){ String a="a"; String b="b"; String c="ab"; String d="a"+"b"; } } 对应字节码 0 ldc #2 &lt;a> 2 astore_1 3 ldc #3 &lt;b> 5 astore_2 6 ldc #4 &lt;ab> 8 astore_3 9 ldc #4 &lt;ab> 11 astore 4 13 return 我们仔细阅读不难发现String c=”ab”和String d是相等的，因为他们指向的是同一个常量池。 接下来我们都明白了，我们就看一些题目吧 public class EnuTest{ public static void main(String[] args){ String a="a"; String b="b"; String c="ab"; String d="a"+"b"; String e=new String("a")+new String("b");//出现引号的只有a和b也就是说字符串常量池只有[a,b] System.out.println(c==d); System.out.println(c==e); } } 答案是 true false是不是现在就很清楚了。 要是不清楚还有终极大招public class EnuTest{ public static void main(String[] args){ String abc=new String("abc"); System.out.println(abc.intern()==abc);//false原因是abc.intern虽然打算存入abc但是字符串常量池已经有了,所有返回了字符串常量池的引用,所以对象abc和常量池的引用一定不相等啊 System.out.println(abc.intern()=="abc");//true这个原因就不需要解释了吧 abc=abc.intern();//这次我们改变引，引用常量池中的 System.out.println(abc);//打印结果还是abc } } 是不是感觉明白点了，那么接下来我们在玩点骚气的 public class EnuTest{ public static void main(String[] args){ String a="a"; String bc="bc"; String abc=new String("abc").intern();//此时常量池中只有[a,bc,abc] String bcd="abc";//他直接从常量池中取出了"abc"的引用 System.out.println(bcd==abc);//true } } intern解释3.String.intern() in JDK6 Jdk6中常量池位于PermGen（永久代）中，PermGen是一块主要用于存放已加载的类信息和字符串池的大小固定的区域。执行intern()方法时，若常量池中不存在等值的字符串，JVM就会在常量池中创建一个等值的字符串，然后返回该字符串的引用。除此以外，JVM 会自动在常量池中保存一份之前已使用过的字符串集合。Jdk6中使用intern()方法的主要问题就在于常量池被保存在PermGen中：首先，PermGen是一块大小固定的区域，一般不同的平台PermGen的默认大小也不相同，大致在32M到96M之间。所以不能对不受控制的运行时字符串（如用户输入信息等）使用intern()方法，否则很有可能会引发PermGen内存溢出；其次String对象保存在Java堆区，Java堆区与PermGen是物理隔离的，因此如果对多个不等值的字符串对象执行intern操作，则会导致内存中存在许多重复的字符串，会造成性能损失。 4.String.intern() in JDK7 Jdk7将常量池从PermGen区移到了Java堆区，执行intern操作时，如果常量池已经存在该字符串，则直接返回字符串引用，否则复制该字符串对象的引用到常量池中并返回。堆区的大小一般不受限，所以将常量池从PremGen区移到堆区使得常量池的使用不再受限于固定大小。除此之外，位于堆区的常量池中的对象可以被垃圾回收。当常量池中的字符串不再存在指向它的引用时，JVM就会回收该字符串。可以使用 -XX:StringTableSize 虚拟机参数设置字符串池的map大小。字符串池内部实现为一个HashMap，所以当能够确定程序中需要intern的字符串数目时，可以将该map的size设置为所需数目*2（减少hash冲突），这样就可以使得String.intern()每次都只需要常量时间和相当小的内存就能够将一个String存入字符串池中。 StringTable这个地方也是可以被垃圾回收的，当没有持有这个字符串常量池的引用时就会被垃圾回收掉 StringTable的底层实现是HashTable 调优方案一由于底层实现是HashTable，当字符串常量池特别大的时候可以使用参数-XX:StringTableSize=大小来增加桶容量 这样可以减少hash碰撞 方案二如果有一批字符串常量量也特别大，比如全国人民的地址信息，你会发现这些信息有好些是重复的，就可以利用这些重复信息来实现优化。 总结想把字符串加入常量池（StringTable）只有两种方法 常量池中没有的字符，通过intern加入 常量池没有字符是，双引号括起来的会被加入]]></content>
      <tags>
        <tag>字节码</tag>
        <tag>StringTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态内部类何时被加载]]></title>
    <url>%2F2020%2F03%2F21%2Fjing-tai-nei-bu-lei-he-shi-bei-jia-zai%2F</url>
    <content type="text"><![CDATA[首先先看一段代码 /** * @author yang * @date 2020/3/20 下午 1:49 */ public class EnuTest{ public static void main(String[] args) { Demo demo = new Demo(); } } class Demo { static int a=0; static { System.out.println("外部类被加载"); } public static class Inner{ static { System.out.println("内部类被加载"); } public static void run(){ System.out.println("内部类方法被调用"); } } } 外部类被加载 也就说说初始化内部类的时候并没有初始化里面的静态内部类，也是被动调用 再来看第二段代码 /** * @author yang * @date 2020/3/20 下午 1:49 */ public class EnuTest{ public static void main(String[] args) { Demo.Inner.run();//唯一改变的地方，直接调用静态内部类的静态方法 } } class Demo { static int a=0; static { System.out.println("外部类被加载"); } public static class Inner{ static { System.out.println("内部类被加载"); } public static void run(){ System.out.println("内部类方法被调用"); } } } 运行结果 内部类被加载 内部类方法被调用也就说说这个静态内部类的初始化并不会触发外部类的初始化，即可以单独存在，也就是说这种调用方法是被动调用 接下来看第三段代码 /** * @author yang * @date 2020/3/20 下午 1:49 */ public class EnuTest{ public static void main(String[] args) { Demo.Inner.run(); } } class Demo { static int a=0;//因为内部类是静态的，内部要想访问除非静态，或者内部类创建外部对象 static { System.out.println("外部类被加载"); } public static class Inner{ static { System.out.println("内部类被加载"); } public static void run(){ System.out.println("内部类方法被调用"+a);//代码唯一改变的地方 } } } 内部类被加载 外部类被加载 内部类方法被调用0也就是证实了内部类的存在并不依赖外部类的 结论外部类的初始化并不会触发内部类的初始化。 内部类的先初始化也不会导致外部类的初始化。 如果内部类的静态方法使用到了外部类，那么静态内部类会先初始化然后初始化外部类。 非静态内部类依赖外部类吗这个答案可想而知，我们无论如何，只要创建内部类，就一定要保证外部类的存在，答案是依赖]]></content>
      <tags>
        <tag>内部类</tag>
        <tag>被动调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integer陷阱]]></title>
    <url>%2F2020%2F03%2F20%2Finteger-xian-jing%2F</url>
    <content type="text"><![CDATA[首先对象使用==比较的是是否为同一个对象 public class EnuTest { public static void main(String[] args) { Integer integer1=110; Integer integer2=110; System.out.println(integer2==integer1); Integer integer3=150; Integer integer4=150; System.out.println(integer3==integer4); } } //输出结果为 true false 为什么会这样呢，是不是发现和String很像，当然我们这篇文章并不讨论String。 原因分析jdk1.5引入了装箱和拆箱的机制。 当我们打开Integer的源码就会发现,java.lang.Integer类里面有个成员静态内部类IntegerCache private static class IntegerCache { static final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high >= 127; } private IntegerCache() {} } 我们仔细阅读这个源码不难发现他维护了一个缓存区，这个缓存区[-128, 127] 之间的数都会被缓存。是不是顿时感觉就明白了，别慌。 你仔细看看问题发生的代码 Integer integer5=new Integer(110); Integer integer6=new Integer(110); system.out.println(integer5==integer6); //结果是false 不是说凡是在[-128,127]之间的都会被缓存吗，(这里先不讨论new就是创建了一个新的对象) 我们打开Integer的构造函数 public Integer(int value) { this.value = value; } public Integer(String s) throws NumberFormatException { this.value = parseInt(s, 10); } 发现都没有和IntegerCache发生关系，所以不可能为true。 问题就来了，java是如何把[-128,127]存储到IntegerCache中的呢，似乎这个问题陷入了死角。 前面说过，在jdk1.5中引入了自动装箱和拆箱概念，问题就发生在这。 public static void run(){ int a=100; Integer integer=110;//自动装箱 integer=100;//自动装箱 } 接下来是反编译后的字节码 0 bipush 100//100入操作数栈 2 istore_0//100弹出操作数栈，并保存到局部变量表0位置上，0位置上就是a 3 bipush 110//100入操作数栈 5 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;//调用valueOf方法 8 astore_1//栈顶保存到局部变量表1位置上，1位置上就是integer 9 bipush 100 11 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;//调用valueOf方法 14 astore_1//栈顶保存到局部变量表1位置上，1位置上就是integer 15 sipush 150 18 invokestatic #2 &lt;java/lang/Integer.valueOf&gt; 21 astore_2//栈顶保存到局部变量表1位置上，1位置上就是integer 22 return对比一下源代码我们发现 虚拟机居然调用了valueOf这个方法,而且我们发现基本数据类型是不会调用这个方法的,也就说说这个自动装箱和拆箱其实是编译器搞的，也就是当编译期发现了这个装箱就会增加一个调用方法valueOf(int i)这个方法。 那么我们就看一下valueOf的源代码吧 public static Integer valueOf(int i) {//编译期调用的正是这个方法 if (i >= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)//判断有没有超出缓冲区的范围 return IntegerCache.cache[i + (-IntegerCache.low)];//返回缓冲区中的结果 return new Integer(i); } public static Integer valueOf(String s) throws NumberFormatException { return Integer.valueOf(parseInt(s, 10)); } public static Integer valueOf(String s, int radix) throws NumberFormatException { return Integer.valueOf(parseInt(s,radix)); } 我们发现只有valueOf(int i)这个确实是这样的。 仔细看一下8个包装类型发现并不是所有的类型都有这个缓冲区的, 有缓存区的有的有Character，Byte,Short，Long. 猜想IntegerCache的设计思路 首先这个类的作用是维护一个缓冲区，也就说说所有的Integer类型都要共用的一个类，并且Integer是非静态的类，也就说说这个类一定是静态的，因为如果不是静态的，那么所有的Integer将无法共享这个静态成员内部类。 然后这个类肯定只能Integer访问和使用，不能让其他类使用，所有这个类一定是私有的成员内部类，。 如果这个类是私有的那么Intger想要访问，必须通过里面的静态非私有属性或者静态非私有方法来访问。 以上是我的猜想，那么接下来咱们验证一下吧. private static class IntegerCache {//确实是私有的且静态的 static final int low = -128; static final int high; static final Integer cache[];//外部可以通过这个非私属性拿到这个属性，并且是default（包）权限 static { int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); assert IntegerCache.high >= 127; } private IntegerCache() {} }]]></content>
      <tags>
        <tag>Integer</tag>
        <tag>陷阱</tag>
        <tag>源码</tag>
        <tag>字节码</tag>
        <tag>猜想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4操作系统进程同步和2.5经典进程的同步问题]]></title>
    <url>%2F2020%2F03%2F20%2F2.4-cao-zuo-xi-tong-jin-cheng-tong-bu-he-2.5-jing-dian-jin-cheng-de-tong-bu-wen-ti%2F</url>
    <content type="text"><![CDATA[简介​ 进程同步是一个操作系统级别的概念,是在多道程序的环境下，存在着不同的制约关系，为了协调这种互相制约的关系，实现资源共享和进程协作，从而避免进程之间的冲突，引入了进程同步。 进程描述定义 进程是程序的一次执行。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 本教材定义进程为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 临界资源​ 在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。 ​ 对于临界资源的访问，必须是互诉进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。 ​ 对于临界区的访问过程分为四个部分： 进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞 临界区:在临界区做操作 退出区:清除临界区被占用的标志 剩余区：进程与临界区不相关部分的代码 临界资源使用规则：忙则等待、优先等待、空闲让进、让权等待（在临界区的进程，不能在临界区内长时间处于事件等待，必须在一定时间退出临界区）。 多个进程常常需要共同修改某些共享变量、表格、文件数据库等，协作完成一些功能。共享协作带来了进程的同步和互斥、死锁、饥饿等问题。 进程同步 ​ 进程同步也是进程之间直接的制约关系，是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系来源于他们之间的合作。 ​ 比如说进程A需要从缓冲区读取进程B产生的信息，当缓冲区为空时，进程B因为读取不到信息而被阻塞。而当进程A产生信息放入缓冲区时，进程B才会被唤醒。 进程互斥 ​ 进程互斥是进程之间的间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待。只有当使用临界资源的进程退出临界区后，这个进程才会解除阻塞状态。 ​ 比如进程B需要访问打印机，但此时进程A占有了打印机，进程B会被阻塞，直到进程A释放了打印机资源,进程B才可以继续执行。 实现临界区互斥的基本方法硬件实现方法 ​ 通过硬件实现临界区最简单的办法就是关CPU的中断。从计算机原理我们知道，CPU进行进程切换是需要通过中断来进行。如果屏蔽了中断那么就可以保证当前进程顺利的将临界区代码执行完，从而实现了互斥。这个办法的步骤就是:屏蔽中断–执行临界区–开中断。但这样做并不好，这大大限制了处理器交替执行任务的能力。并且将关中断的权限交给用户代码，那么如果用户代码屏蔽了中断后不再开，那系统岂不是跪了？ 信号量实现方式 ​ 这也是我们比较熟悉P V操作。通过设置一个表示资源个数的信号量S，通过对信号量S的P和V操作来实现进程的的互斥。 ​ P和V操作分别表示占有和释放。P V操作是操作系统的原语，意味着具有原子性。 ​ P操作首先减少信号量，表示有一个进程将占用或等待资源，然后检测S是否小于0,如果小于0则阻塞，如果大于0则占有资源进行执行。 ​ V操作是和P操作相反的操作，首先增加信号量，表示占用或等待资源的进程减少了1个。然后检测S是否小于0，如果小于0则唤醒等待使用S资源的其它进程。 ​ 前面我们C#模拟进程的同步和互斥其实算是信号量进行实现的。 经典进程的同步问题生产者–消费者问题 ​ 问题描述:生产者-消费者问题是一个经典的进程同步问题，该问题最早由Dijkstra提出，用以演示他提出的信号量机制。本作业要求设计在同一个进程地址空间内执行的两个线程。生产者线程生产物品，然后将物品放置在一个空缓冲区中供消费者线程消费。消费者线程从缓冲区中获得物品，然后释放缓冲区。当生产者线程生产物品时，如果没有空缓冲区可用，那么生产者线程必须等待消费者线程释放出一个空缓冲区。当消费者线程消费物品时，如果没有满的缓冲区，那么消费者线程将被阻塞，直到新的物品被生产出来 ​ 这里生产者和消费者是既同步又互斥的关系，首先只有生产者生产了，消费着才能消费，这里是同步的关系。但他们对于临界区的访问又是互斥的关系。因此需要三个信号量empty和full用于同步缓冲区，而mut变量用于在访问缓冲区时是互斥的。 读者–写者问题 问题描述:​ 一个数据文件或记录，统称数据对象，可被多个进程共享，其中有些进程只要求读称为”读者”，而另一些进程要求写或修改称为”写者”。 ​ 规定:允许多个读者同时读一个共享对象，但禁止读者、写者同时访问一个共享对象，也禁止多个写者访问一个共享对象，否则将违反Bernstein并发执行条件。 问题分析​ 通过描述可以分析，这里的读者和写者是互斥的，而写者和写者也是互斥的，但读者之间并不互斥。 ​ 由此我们可以设置3个变量，一个用来统计读者的数量，另外两个分别用于对读者数量读写的互斥，读者和读者写者和写者的互斥。 哲学家进餐问题 问题描述:​ 有五个哲学家，他们的生活方式是交替地进行思考和进餐。哲学家们公用一张圆桌，周围放有五把椅子，每人坐一把。在圆桌上有五个碗和五根筷子，当一个哲学家思考时，他不与其他人交谈，饥饿时便试图取用其左、右最靠近他的筷子，但他可能一根都拿不到。只有在他拿到两根筷子时，方能进餐，进餐完后，放下筷子又继续思考。 根据问题描述,五个哲学家分别可以看作是五个进程。五只筷子分别看作是五个资源。只有当哲学家分别拥有左右的资源时，才得以进餐。如果不指定规则，当每个哲学家手中只拿了一只筷子时会造成死锁，从而五个哲学家都因为吃不到饭而饿死。因此我们的策略是让哲学家同时拿起两只筷子。因此我们需要对每个资源设置一个信号量，此外，还需要使得哲学家同时拿起两只筷子而设置一个互斥信号量，]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java零碎小细节]]></title>
    <url>%2F2020%2F03%2F19%2Fjava-ling-sui-xiao-xi-jie%2F</url>
    <content type="text"><![CDATA[boolean大小问题问题引入今天在看java编程思想的时候发现8个基本类型变量基本上都有明确的大小，但是boolean并没有大小。 解决来源是《Java虚拟机规范》一书中的描述：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。 使用局部变量定义数组的时候数组会被初始化当使用局部变量的时候必须先初始化才能使用，但是使用局部变量定义数组的时候数组里面的所有元素都会被初始化为零值。 问题分析 成员变量的值存放于java堆中，在创建对象的时候JVM在分配内存时将整块区域置为零即完成了初始化，方便快捷。 而局部变量运行时被分配于虚拟机栈中，量大，生命周期短，如果由JVM完成初始化，将是一笔很大的性能开销。所以java规定局部变量手动必须初始化。 当一个对象使用关键字“new”创建时，会在堆上分配内存空间，然后返回对象的引用，这对数组来说也是一样的，因为数组也是一个对象,所以和成员变量一样在整块区域置为零即完成了初始化； JAVA何时加载静态语句块父类静态代码块 &gt; 子类静态代码块 Java虚拟机加载类时，就会执行该块代码。父类构造函数 &gt; 子类构造函数 （先有父亲，后有孩子）如果是多级继承关系的话，高层的父类首先执行，然后依次递减。总结：静态优先执行，父类优先于子类执行。 静态代码块是在JVM加载类的时候执行的，而且静态代码块执行且仅执行一次 静态代码块什么时候开始执行 静态代码块在初始化阶段才会被执行，也就说单纯的类加载是不会执行静态代码块的。 也就说有些情况是不会触发这个静态代码块的执行的。 主动加载和被动加载的区别在于，主动加载会触发类的初始化。 主动加载的情况 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类； 使用Jdk1.7动态语言支持的时候的一些情况。 当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化) 类不被加载情况举例package jvm; public class ClassLoaderTest { public static void main(String[] args) throws ClassNotFoundException { //1. System.out.println(Demo.class);//不会执行初始化阶段 //2. Class.forName("jvm.Demo");//会执行初始化阶段也就说说会执行静态代码块 } } class Demo{ static { System.out.println("被加载了"); hello(); } public static void hello(){ System.out.println("hello方法被执行了!"); } } 当然不会触发静态代码块的方案还有很多. 非静态方法都隐藏一参数this非静态非方法都有一个隐藏参数this，也就说this只有非静态方法才能用 演示这是两个方法，一个静态方法，一个非静态方法 public static void f1(){ } public void f2(){ } 我们可以看到方法f1压根没有局部变量表，但是方法f2局部变量表有个this Java中创建子类实例时会创建父类实例？首先每个类的这些元数据，无论是在构建这个类的实例还是调用这个类某个对象的方法，都会访问方法区的这些元数据。构建一个对象时，JVM会在堆中给对象分配空间，这些空间用来存储当前对象实例属性以及其父类的实例属性（而这些属性信息都是从方法区获得） 注意，这里并不是仅仅为当前对象的实例属性分配空间，还需要给父类的实例属性分配。 总之，会为父类分配堆内存，但是这块内存属于子类的堆内存。 i++和++i的区别i++和++i都会变成四个字节码指令，其中不同的地方在2,3条指令，这两个指令是 iload 把局部变量表中的值加载到操作数栈中 iinc * by * 第一个占位符表示局部变量表的位置，第二个表示该位置自增的数，比如inc 1 by 1就表示 1位置自增1 注意只有这两条指令 区别i++是先iload后 inc，++i是先inc后iload 陷阱public class EnuTest{ public static void main(String[] args){ int a=0; for (int i = 0; i &lt; 10; i++) a=a++; System.out.println(a); } } 比如这行代码结果就是0，就是利用了这个坑，道理也很简单，每次a自增前都把当前值0加载到了操作数栈中，然后因为有个等于号对应指令就是把操作数栈中栈顶的值存入局部变量表中，也就是说a自增后又被重新覆盖为0了 Java中，如果对整数不指定类型，默认时int类型，对小数不指定类型，默认是double类型如果要指定长整型，最好写为long a = 100000000L,如果要指定为单精度最好写为float a= 12.34F Java程序的种类有：（a）内嵌于Web文件中，由浏览器来观看的_Applet （b）可独立运行的 Application （c）服务器端的 Servlets 多态调用过程package thread.demoone; /** * @author yang * @date 2020/4/15 下午 3:34 */ class Test { public static void main(String[] args) { System.out.println(new B().getValue()); } static class A { protected int value; public A (int v) { setValue(v); } public void setValue(int value) { this.value= value; } public int getValue() { try { value ++; return value; } finally { this.setValue(value); System.out.println(value); } } } static class B extends A { public B () { super(5); setValue(getValue()- 3); } public void setValue(int value) { super.setValue(2 * value); } } } //结果为 22 34 17]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm学习第三天-类加载器]]></title>
    <url>%2F2020%2F03%2F19%2Fjvm-xue-xi-di-san-tian-lei-jia-zai-qi%2F</url>
    <content type="text"><![CDATA[类加载器 虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 类与类加载器对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。 这段代码就演示了这种情况 package jvm; import java.io.IOException; import java.io.InputStream; public class ClassLoaderTest { public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException { ClassLoader myLoader = new ClassLoader() { @Override public Class&lt;?> loadClass(String name) throws ClassNotFoundException { String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream inputStream = getClass().getResourceAsStream(fileName); if (inputStream == null) { return super.loadClass(name); } try { byte[] b = new byte[inputStream.available()]; inputStream.read(b); return defineClass(name, b, 0, b.length); } catch (IOException e) { throw new ClassNotFoundException(); } } }; Object obj = myLoader.loadClass("jvm.ClassLoaderTest").newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof jvm.ClassLoaderTest); ClassLoaderTest classLoaderTest = new ClassLoaderTest(); System.out.println(classLoaderTest.getClass()); System.out.println(classLoaderTest instanceof jvm.ClassLoaderTest); } } //运行结果为 class jvm.ClassLoaderTest false class jvm.ClassLoaderTest true 双亲委派模型从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。 从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器： 启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。 扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。 应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。我们的应用程序都是由这三类加载器互相配合进行加载的。另外还有自定义类加载器。自定义类加载器(必须继承 ClassLoader)。 这些类加载器之间的关系 如上图所示的类加载器之间的这种层次关系，就称为类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。 双亲委派模型的工作过程为如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。 优点 保证了系统的安全性 保证了同一个类由各种类加载器加载都是同一个类 模型实现 protected synchronized Class&lt;?> loadClass(String name, boolean resolve) throws ClassNotFoundException { { //首先，检查请求的类是否已经被加载过了 Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //如果父类加载器抛出ClassNotFoundException //说明父类加载器无法完成加载请求 } if (c == null) { //在父类加载器无法加载的时候 //再调用本身的findClass方法来进行类加载 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } }]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>虚拟器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql的zip安装方法]]></title>
    <url>%2F2020%2F03%2F18%2Fmysql-de-zip-an-zhuang-fang-fa%2F</url>
    <content type="text"><![CDATA[windows安装方法本文来自https://howwrite.github.io/ 下载文件先去清华大学镜像站下载文件 找到想要版本的mysql,进去下载对应的zip文件,我下载的是mysql8.0的64位版:mysql-8.0.11-winx64.zip 下载完成后解压到合适的位置,如：C:\mysql-8.0.11 配置 解压完后在根目录创建一个名为my.ini的文件,添加以下内容 [mysqld] character-set-server=utf8 port = 3306 # 设置mysql的安装目录 basedir=D:\\mysql-8.0.11 # 设置mysql数据库的数据的存放目录 datadir=D:\\mysql-8.0.11\\data default-storage-engine = INNODB collation-server = utf8_general_ci [mysql] default-character-set=utf8 [mysql.server] default-character-set=utf8 [mysql_safe] default-character-set=utf8 [client] default-character-set=utf8 basedir是解压目录,datadir是mysql存放数据的目录 然后打开电脑的环境变量 新建系统变量MYSQL_HOME=C:\mysql-8.0.11(解压路径) 在path中增加%MYSQL_HOME%\bin 在mysql的bin目录下运行初始化系统命令 mysqld --initialize 初始化成功后，会在data文件夹下生成一些文件，其中xxx.err文件中说明了root账户的临时密码 如 [Server] A temporary password is generated for root@localhost: JafC,2cE&lt;C# 那么JafC,2cE&lt;C#就是临时密码,一般在第二行就会看到 注册mysql服务 mysqld -install MySQL 启动mysql服务 net start MySQL 停止mysql服务 net stop MySQL 先用root和临时密码登录数据库 ubuntu18安装mysql说明：此种方式完全参考官方提供的教程https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/。 注意：通过APT方式安装的版本都是现在最新的版本，现在我安装的是5.7.18。通过这种方式安装好之后开机自启动都已经配置好，和命令行上的环境变量，无需手动配置。 (可省略)下载官方提供的mysql-apt-config.deb包进行APT源设置，下载地址：https://dev.mysql.com/downloads/repo/apt/ 下载了,然后运行sudo dpkg -i xxx.deb 运行这个安装包 第一个确定进去选择5.7,然后选ok 然后运行sudo apt-get update 然后运行sudo apt-get install mysql-server 中间会让你输入密码 如果依赖不足,输入sudo apt-get install -f 打开etc\mysql\mysql.conf.d\mysql.cnf在下面加上 character-set-server=utf8default-storage-engine = INNODBcollation-server = utf8_general_ci[mysql]default-character-set=utf8[mysql.server]default-character-set=utf8[mysql_safe]default-character-set=utf8[client]default-character-set=utf8 服务管理 #启动sudo service mysql start#停止sudo service mysql stop#服务状态sudo service mysql status通用 执行更改新密码 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new_password&#39;; 刷新 flush privileges; 退出重启服务器用新密码登录即可 改密码 update user set authentication_string = password(&quot;new_password&quot;) where user=&#39;root&#39;;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm学习第二天-虚拟机执行子系统]]></title>
    <url>%2F2020%2F03%2F18%2Fjvm-xue-xi-di-er-tian-xu-ni-ji-zhi-xing-zi-xi-tong%2F</url>
    <content type="text"><![CDATA[字节码简介Java字节码指令由一个字节长度的，代表某种特定操作含义的数字（操作码）以及其后的零至多个代表此操作所需参数（操作数）。此外字节码指令是面向操作数栈的，这里操作数栈在功能上对应实体机的寄存器但是结构上有所区别。 字节码与数据类型在字节码指令集中，大多数指令都对应的其操作所对应的数据类型信息，比如iload表示从局部变量表中加载int型的数据到操作栈中，fload从局部变量表中加载float型的数据到操作栈中…但是由于Java字节码的操作码只有一个字节（即0~255），这意味着指令集的操作码总数不可能超过256条。所以如果要求Java运行时所有的数据类型都有对应的与数据类型相关的指令去支持的话，操作码的总数将超过256条。所以JAVA字节码指令集被设计为Not Orthogonal（非完全独立）,即并非每种数据类型和每种操作都有对应的指令，有一些指令可以在必要的时候将一些不被支持的数据类型转换为被支持的数据类型。我们可以以数据类型为列，操作指令为行制作一张表，其中为空的项即说明虚拟机不支持对这种数据类型进行这项操作。 加载和存储指令加载和存储指令用于将数据在帧栈中的局部变量表和操作数栈之间传输。 将一个局部变量表加载到操作数栈：iload、iload_、lload、lload_、fload、fload_、dload、dload_、aload、aload_。将一个数值从操作数栈储存到局部变量表：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstore_,astore,astore_ 运算指令 运算指令用于对操作数栈上的值进行某种特定的运算。 加法运算：iadd,ladd,fadd,dadd。减法运算：isub,lsub,fsub,dsub。乘法运算：imul,lmul,fmul,dmul。除法运算：idiv,ldiv,fdiv,ddiv。求余指令：irem,lrem,frem,drem。取反指令：imeg,lmeg,fmeg,dmeg。位移指令：ishl,ishr,iushr,lshl,lshr,lushr。按位或指令：ior,lor。按位与指令：iand,land。按位异或指令：ixor,lxor。局部变量自增指令：iinc。比较指令：dcmpg,dcmpl,fcmpg,fcmpl,lcmp。注：只有在除法指令（idiv,ldiv)和求余指令（irem,lrem)当出现除数为零时会导致虚拟机抛出AirtmeticException异常，其余整形和浮点型运算场景都不会抛出异常 类型转换指令类型转换指令可以将两种不同数值类型进行相互转换。Java虚拟机天然支持基本数据类型的宽化类型转换，例如int到long、flost、double等。对于窄化数据类型转化则必须用显示的转换指令： i2b(int -&gt; boolean)i2c(int -&gt; char)i2s(int -&gt; short)l2i(long -&gt; int)f2i(float -&gt; int)f2l(float -&gt; long)d2i(double -&gt; int)d2l(double -&gt; long)d2f(double -&gt; float) 对象创建与访问指令创建类实例的指令：new创建数组的指令：newarray,anewarray,multianewarray访问类字段（static字段）和实例字段（非static字段）的指令：getfield,putfield,getstatic,putstatic将一个数组元素加载到操作数栈的指令:baload,caload,saload,iaload,faload,daload,aaload将一个操作数栈的值存储到数组元素中的指令：bastore,castore,iastore,sastore,fastore,fastore,dastore,aastore取数组长度的指令：arraylength检查类实例类型的指令：instanceof,checkcast 操作数栈管理指令将一个操作数栈的栈顶一个或两个元素出栈：pop、pop2。复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1,dup2_x1,dup_x2,dup2_x2。将栈顶端的两个数值交换：swap。控制转移指令 控制转移指令可以让Java虚拟机有条件或者无条件的从指定的位置而不是控制转移指令的下一条指令继续执行程序。 条件分支：ifeq,ifit,ifle,ifgt,ifnull,ifnonnull,if_icmpeq,if_icmpne,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne。复合条件分支：tableswitch,lookupswitch。无条件分支：gosto,goto_w,jsr,jsr_w,ret。 方法调用和返回指令invokevirtual:用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）。invokeinterface:用于调用接口方法，它在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。invokespecial:用于调用一些需要特殊处理的实例方法，包括实例的初始化方法，私有方法和父类方法。invokestatic:用于调用类方法（static方法）invokedynamic:用于运行时动态解析出调用点限定符所应用的方法，并执行该方法。（前面的分派逻辑都固化在虚拟机内部，而该指令的分派逻辑是由用户自定义）。方法返回指令：ireture(返回类型是int,short,byte,char,boolean时),lreturn,freturn,dreturn,areturn,另外还有一条return供void方法、实例/类/接口的初始化方法使用。 异常处理指令显式抛出异常指令：athrow 同步指令monitorenter,monitorexit 代码分析 public void test(){ int a=10; int b=10; int c=a+b; } 0 bipush 10//存入10到操作数栈 2 istore_1//弹出栈顶元素存入位置1的局部变量中,而且位置1对应的是a 3 bipush 10//存入10到操作数栈 5 istore_2//弹出栈顶元素存入位置2的局部变量中,而且位置2对应的是b 6 iload_1//取出局部变量表1位置的int型变量存放在栈顶 7 iload_2//取出局部变量表2位置的int型变量存放在栈顶 8 iadd//弹出操作数栈的两个元素求和并把结果存入操作数栈中 9 istore_3//弹出操作数栈顶元素存放在局部变量表3的位置，对应变量为c 10 return 虚拟类的加载机制 类加载时机java语言中类型的加载连接以及初始化过程都是在程序运行期间完成的，这种策略虽然会使类加载时稍微增加一些性能开销，但是会为java应用程序提供高度的灵活性。java里天生就可以动态扩展语言特性就是依赖运行期间动态加载和动态连接这个特点实现的。比如，如果编写一个面向接口的程序，可以等到运行时再指定其具体实现类。（解析阶段则不一定:在某些情况下可以在初始化阶段之后开始，这是为了支持java语言的运行时绑定特性(也称为动态绑定或晚期绑定). 加载” 是 “类加载” 过程的一个阶段，切不可将二者混淆。 加载阶段由三个基本动作组成： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 主动加载和被动加载主动加载和被动加载的区别在于，主动加载会触发类的初始化。 类必须初始化的6种情况 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类； 使用Jdk1.7动态语言支持的时候的一些情况。 当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化) 相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass（）方法）。 也就是说我们在加载的时候可以从很多地方加载，例如从压缩包加载，从网络加载，运行时计算生成等。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。 加载数组数组类本身不通过类加载器创建，它时有java虚拟机直接在内存中动态构造出来的，但数组类与类加载器仍然有很密切的关系，因为数组的元素类型（数组去掉所有维度的类型）最终还是要靠类加载器来完成。 连接验证验证是链接阶段的第一步，这一步主要的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。 因为仅仅依靠java代码层面一些无法做到的事情java代码也可以表示出来，例如数组越界，所以jvm的编译期在字节码上看见这种事情会直接拒绝编译 验证阶段主要包括四个检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。 文件格式验证验证class文件格式规范，例如： class文件是否已魔术0xCAFEBABE开头 ， 主、次版本号是否在当前虚拟机处理范围之内等 元数据验证这个阶段是对字节码描述的信息进行语义分析，以保证起描述的信息符合java语言规范要求。验证点可能包括：这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)、这个类是否继承了不允许被继承的类(被final修饰的)、如果这个类的父类是抽象类，是否实现了起父类或接口中要求实现的所有方法。 字节码验证进行数据流和控制流分析，这个阶段对类的方法体进行校验分析，这个阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如：保证访法体中的类型转换有效，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但不能把一个父类对象赋值给子类数据类型、保证跳转命令不会跳转到方法体以外的字节码命令上。 符号引用验证准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(方法区是一个逻辑上的区域，在JDK7之前，HoSpot使用永久代来实现方法区，这是符合这种逻辑概念的，但是在JDK8及其以后类变量会随着Class对象一起放在java堆中)中进行分配。这个阶段中有两个容易产生混淆的知识点，首先是这时候进行内存分配的仅包括类变量(static 修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为:**public static int value = 12; 那么变量value在准备阶段过后的初始值为0而不是12，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为12的动作将在初始化阶段才会被执行。 上面所说的“通常情况”下初始值是零值，那相对于一些特殊的情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，建设上面类变量value定义为：public static final int value = 123; 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value设置为123 数据类型 零值 int 0 long 0L short (short)0 char ‘\u0000’ byte (byte)0 boolean false float 0.0f double 0.0d reference null 解析 解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。 直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。 虚拟机规范并没有规定解析阶段发生的具体时间，只要求了在执行anewarry、checkcast、getfield、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析，所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。 解析的动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。分别对应编译后常量池内的CONSTANT_Class_Info、CONSTANT_Fieldref_Info、CONSTANT_Methodef_Info、CONSTANT_InterfaceMethoder_Info四种常量类型。 类、接口的解析 字段解析 类方法解析 接口方法解析 初始化类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程。在以下四种情况下初始化过程会被触发执行： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化 jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类 在上面准备阶段 public static int value = 12; 在准备阶段完成后 value的值为0，而在初始化阶调用了类构造器&lt; clinit &gt;()方法，这个阶段完成后value的值为12。 类构造器&lt; clinit &gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句快可以赋值，但是不能访问。 类构造器&lt; clinit &gt;()方法与类的构造函数(实例构造函数&lt; init &gt;()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()方法已经执行完毕。因此在虚拟机中的第一个执行的&lt; clinit &gt;()方法的类肯定是java.lang.Object。 由于父类的&lt; clinit &gt;()方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。 &lt; clinit &gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，那么编译器可以不为这个类生成&lt; clinit &gt;()方法。 接口中不能使用静态语句块，但接口与类不太能够的是，执行接口的&lt; clinit &gt;()方法不需要先执行父接口的&lt; clinit &gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt; clinit &gt;()方法。 虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的&lt; clinit &gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit &gt;()方法完毕。如果一个类的&lt; clinit &gt;()方法中有耗时很长的操作，那就可能造成多个进程阻塞。]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA反射详解]]></title>
    <url>%2F2020%2F03%2F15%2Fjava-fan-she-xiang-jie%2F</url>
    <content type="text"><![CDATA[概述定义JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 用途最重要的用途就是解耦，许多框架配合java反射技术以及工厂模式进行解耦，也就是说通过配置文件的方式创建对象 获取字节码的方式 Class.forName(“全限定类名”);将字节码加载进内存，返回Class对象.(多用于配置文件中，读取配置文件加载类) 类名.Class：通过类名属性获取Class 对象.getClass():通过对象的父类Object定义的getClass()方法获取字节码 反射机制的相关类与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class类Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true Field类Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 Method类Method代表类的方法。 方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类Constructor代表类的构造方法。 方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 演示Person类 public class Person { private String name="默认值"; public int age; public String getName() { return name; } } 获取Person的属性 public static void main(String[] args) throws ClassNotFoundException { Class personClass = Class.forName("Person");//这里要写全限定类名 //获取Person类的所有public属性 Field[] fields = personClass.getFields(); System.out.println("--------public属性--------"); for (Field field : fields) { System.out.println(field.getName()); } //获取Person类所有属性包括privice System.out.println("--------所有属性--------"); Field[] declaredFields = personClass.getDeclaredFields(); for (Field declaredField : declaredFields) { System.out.println(declaredField.getName()); } } 结果为 --------public属性-------- age --------所有属性-------- name age 修改Person属性的值（甚至可以修改他的私有属性） public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException { Class personClass = Class.forName("Person");//加载到内存 Person person = (Person) personClass.newInstance();//实例化对象 Field age = personClass.getField("age");//获取Public属性 age.setInt(person,12);//修改其属性值 //强行设置私有属性的值 Field name = personClass.getDeclaredField("name"); name.setAccessible(true);//取消 Java 语言访问检查，否则会报错 name.set(person,"当你在控制台看见我的时候,我已经修改了private的值啦!!!"); System.out.println("Public设置的值"+person.age+"\nprivate设置的值"+person.getName()); } 读取配置文件创建指定的类并执行指定的方法bean.Properties配置文件 classpath=Person method=getName import java.io.IOException; import java.io.InputStream; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Properties; public class JVMTest{ public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException, IOException, NoSuchMethodException, InvocationTargetException { //读取配置文件类似spring框架里面的配置文件 Properties properties=readProperties(); //实例化配置文件里面指定的类 Object ob=beanFactory((String) properties.get("classpath")); //运行实例化类的配置文件指定的方法并且接收返回值 Object rel=runMethod((String) properties.get("method"),ob); System.out.println(rel); } /** * 运行指定的方法 * @param methodName 方法名 * @param cls 类 */ public static Object runMethod(String methodName,Object cls) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { Method method = cls.getClass().getMethod(methodName); return method.invoke(cls); } /** * 根据传入的全类名创建对应的类 * @param classPath 全类名 * @return * @throws ClassNotFoundException * @throws IllegalAccessException * @throws InstantiationException */ public static Object beanFactory(String classPath) throws ClassNotFoundException, IllegalAccessException, InstantiationException { return Class.forName(classPath).newInstance(); } /** * 读取配置文件里面的信息并返回 * @return * @throws IOException */ public static Properties readProperties() throws IOException { InputStream resourceAsStream = Object.class.getResourceAsStream("/bean.Properties"); Properties properties = new Properties(); properties.load(resourceAsStream); return properties; } } 运行结果 默认值]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm学习第一天-自动内存管理]]></title>
    <url>%2F2020%2F03%2F14%2Fjvm-xue-xi-di-yi-tian-zi-dong-nei-cun-guan-li%2F</url>
    <content type="text"><![CDATA[运行时数据区域 方法区 堆 虚拟机栈 本地方法栈 程序计数器 其中前两个是线程共享的，后三个是线程独有的 程序计数器 程序计数器是一个记录着当前线程所执行的字节码的行号指示器。 如果线程执行的是一个java方法，那么这个计数器就表示正在执行的虚拟机字节码 如果这个线程执行的是本地（Native）方法，那么这个计数器的值为空 虚拟机栈栈与堆的区别栈是一种运行时结构，堆是一种存储结构 虚拟机栈特点 和程序计数器一样是线程私有的 会产生oom错误 不需要GC（垃圾回收） 虚拟机栈运行过程每个方法被执行的时候，java虚拟机都会在虚拟机栈创建一个栈帧，当然，每个方法结束后都会移除该栈帧，也就是说在栈顶的栈帧一定是当前执行的方法的栈帧. 在编译程序代码的时候，栈帧中需要多大的局部变量表内存，多深的操作数栈都已经完全确定了。 因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 栈帧 栈帧包含局部变量表，操作数栈，动态连接，方法出口等信息 两个栈帧的数据共享 局部变量表的共享 在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的，但是大多虚拟机的实现里都会进行一些优化处理，两个栈帧出现一部分重叠，这样做不仅节约了一些空间，更重要的是进行方法调用时就可以直接共用一部分数据。 局部变量表存放了编译期可知的各种java虚拟机基本数据类型和对象引用类型（reference），也有可能是指向对象的起始地址或者代表一个对象的句柄 局部变量表在编译期间确定大小 变量槽局部变量的存储使用变量槽表示，其中long和double使用两个变量槽 在方法运行期间不会改变局部变量表的大小，（大小指的是不会改变变量槽的数量） Slot复用 为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的， 也就是说当PC计数器的指令指已经超出了某个变量的作用域（执行完毕）， 那这个变量对应的Slot就可以交给其他变量使用。 优点 ： 节省栈帧空间。 缺点 ： 影响到系统的垃圾收集行为。 （如大方法占用较多的Slot，执行完该方法的作用域后没有对Slot赋值或者清空设置null值，垃圾回收器便不能及时的回收该内存。）变量槽的复用当一个变量超出了他的作用域范围，那么这个变量的位置可以被复用. 演示 public void test(){ int a=1; { int b=a; } int c=2; } 加入上述代码不存在复用的情况下应该是4个局部变量，但是由于b的作用域范围超出了，所以b的变量槽就被c所复用。也就是数上述代码分配的局部变量长度为3 异常如果线程请求的栈深度大于虚拟机所允许的深度，则会抛出StackOverFlowError异常，如果虚拟机栈容量可以动态扩展，当栈扩展无法申请到新的内存的时候会抛出OutOfMemoryError异常 操作数栈是一个后入先出的栈，和局部变量表一样，在编译时候他的最大深度被写入到了Code属性的max_stacks数据项中，其中32位数据占用容量为1,64位操作数占用容量为2 本地方法栈 本地方法栈和虚拟机栈功能是非常类似的，异常也是非常类似，本地方法栈就是执行一些（Native）的本地方法 在Hot-Spot虚拟机中将虚拟机栈和本地方法栈合二为一 JAVA堆java堆是虚拟机所管理的内存中最大的一块。（注意是虚拟机管理） 作用存放对象实例和数组 java对象实例几乎都在这上面存放（注意几乎） 特点 java堆被所有的线程所共享 java堆在物理上可以是不连续的，但是在逻辑上应该被视为连续的 堆大小是可以固定的，也是可以设置大小的（通过-Xmx和-Xms设置） 如果java虚拟机没有完成实例分配，并且堆也无法在扩展时，java虚拟机将会抛出OutOfMemoryError异常 方法区和java堆一样是各个线程共享的内存区域，他用于存储已经被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据，这里也是需要垃圾回收的。 运行时常量池运行时常量池是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项就是常量池。并且常量池相对于Class文件的另一个重要特征就是具备动态性 用于存放编译期生成的各种字面量与符号引用，这些内容在类加载后存放到方法区的运行时常量池中。 常量池无法申请到内存时会抛出OutOfMemoryError异常 如何判断对象是否死亡有项研究表明，新生代中的内存有百分之98熬不过第一轮回收 引用计数法在对象的内部添加一个引用计数器，当一个地方引用它时计数器就加一；当引用失效时，计数器值就减一，（java虚拟机并不是使用这种方法来进行判定的） 特点优点虽然占用了一些额外内存空间，但是它原理很简单，判定效率也很高。 缺点如果两个对象的静态变量相互持有对方，并且这两个对象永远不会执行，那么上面的方法是无法回收这两个“垃圾的” 可达性分析算法（java和C#都是使用这个算法进行判断对象是否存活）通过一系列称为“GC Roots”的根对象作为起始节点集，然后根据引用关系向下搜索，搜索过程中所走过的路径被称为引用链，如果某个对象与GC Roots间没有任何引用链相连，那么这个对象不可能再次被使用。 过程如果对象在进行可达性分析发现并没有与GC Roots相连，那么将会第一次标记这个对象，在随后进行一次筛选，筛选的条件是看看对象是否有必要执行finalize()方法，（一个对象只能被执行一次finalize方法），如果对象没有覆盖该方法或该方法已经被调用过了，那么就没有必要执行，对象将会被回收，如果执行了finalize方法，且对象在方法中重新持有了对象的引用，那么这个对象可以被救活。 扩展finalize()如今已经被官方声明为不推荐使用语法，有些教科书上说这个方法适合做一些对象被回收时的清理工作，事实上这是个错误的，try-catch-finally比这个方法更适合做这些事情。 知道了哪些对象已经死亡，那么如何清理这些对象分代收集理论收集器应该讲java堆划分不同区域，然后回收对象依据其年龄（即对象熬过垃圾收集过程的次数）分配到不同的区域中 如果一个区域中的对象都是朝生熄灭的，那么我们把他们放在一起，称他们为“新生代” 如果都是一些年龄比较大的那么我们把他们放在一起，称他们为”老年代” 带来的问题对象不是孤立的，对象之间可能出现跨代引用，但是我们可以得知，如果一个老年代对象引用了一个新生代的对象，那么这个新生代的对象大概率会存活，因为老年代对象引用了他。 标记-清除算法第一个阶段标记所有需要回收的对象，标记完成后统一回收所有的对象，当然也可以标记不要要回收的对象，标记完成后统一回收没有标记的对象。 特点 执行效率不稳定，如果java堆中包含大量对象。而且大部分是需要被回收的，这时必须进行大量标记和清除动作，导致标记和清除过程随着对象数量增长而降低。 内存空间的碎片化问题，标记后会产生大量不连续的内存碎片。 标记-复制算法将内存按容量划分为大小相等的两块，每次使用只使用其中的一块，当其中的一块用完后，就把所有存活的对象复制到另一块上面，然后把原来的内存块全部清除。 特点优点 解决了标记-除算法内存空间碎片化问题 实现简单运行高效，分配内存时按顺序分配即可 缺点 如果内存中多数对象都是存活的，那么这种算法复制时会产生大量的时间开销 内存浪费严重，将可用内存缩小了原来的一半 标记-整理算法和标记-清除算法一样，但是后续不是对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界内存。 特点缺点 如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动并更新所有这些对象的敌法将会是一个消耗极大的操作。 而且这种移动对象必须全程暂停用户应用程序。 简单的介绍一下强引用,软引用,弱引用,虚引用无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。 JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。 JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱） 强引用(StrongReference)以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 软引用(SoftReference)如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 弱引用(WeakReference)如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 虚引用（PhantomReference）“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。 经典垃圾收集器Serial收集器Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择，时至今日，垃圾收集器的不断改进，不断出新，Serial依然在我们的垃圾收集器的选项里面。 特点 优点：简单高效，拥有很高的单线程收集效率 缺点：收集过程需要暂停所有线程 使用算法：复制算法 适用范围：新生代 应用：Client模式下的默认新生代收集器 对于Serial收集器缺点有一个比较有意思的故事：Serial收集器的运行过程需要暂停应用程序所有线程（Stop The World），它带给用户的恶劣体验。早期HotSpot虚拟机的设计者们表示完全理解，但也同时表示非常委屈：“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾，虽然垃圾收集这项工作听起来和打扫房间属于一个工种，但实际上肯定还要比打扫房间复杂得多！（现在的垃圾收集器一样需要停顿，只是都做到了毫秒级）使用该垃圾收集器 -XX:+UseSerialGC使用之前我们可以去查看一下，当前虚拟机是否使用的Serial，如果是我们不需要去更改，如果不是则添加参数：-XX:+UseSerialGC。 ParNew收集器ParNew收集器实质上是Serial收集器的多线程并行版本 ParNew收集器的特点：优点：在多CPU时，比Serial效率高。 缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。 使用算法：复制算法 适用范围： 新生代应用：运行在Server模式下的虚拟机中首选的新生代收集器使用ParNew收集器 -XX:+UseParNewGC Parallel Scavenge收集器Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。 吞吐量 = 运行用户代码时间/运行用户代码时间 + 运行垃圾收集器时间。 比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。 若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。 吞吐量我们可以自行控制？吞吐量我们从上面的描述可以看到，他是一个比值。那么我们自然能够通过调整比值的参数来影响吞吐量。主要涉及的命令有一下两个 -XX:MaxGCPauseMillis 控制最大的垃圾收集时间-XX:GCTimeRatio 直接设置吞吐量的大小根据吞吐量对应的计算公式我们可以看到，当我们的垃圾收集停顿时间变短的时候（垃圾收集停顿是一个大于0的毫秒数），我们的吞吐量在增大。不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变得更快，当我们把这个参数设置的更小的时候，它对应的能够有效收集的时间或者空间会变小。假若停顿时间为100ms能够收集500M的堆空间，那么50ms能够收集的空间可能会低于250M的堆空间。垃圾收集器的有效工作时间变短，收集垃圾的效率并不一定提高，同时对应的也只能相对的调整我们的吞吐量。 使用Parallel Scavenge收集器 -XX:+UseParallelGCSerial Old收集器Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。 Parallel Old收集器Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理算法”进行垃圾回收。 CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括： 1）初始标记（CMS initial mark）2）并发标记（CMS concurrent mark）3）重新标记（CMS remark）4）并发清除（CMS concurrent sweep）由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。 CMS收集器特点：优点：并发收集、低停顿缺点：产生大量空间碎片、并发阶段会降低吞吐量 使用CMS收集器 -XX:+UseConcMarkSweepGCGarbage First收集器Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它是一款主要面向服务端应用的垃圾收集器 使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 G1收集器的运作过程大致可划分为以下四个步骤：初始标记（Initial Marking）并发标记（Concurrent Marking）最终标记（Final Marking）筛选回收（Live Data Counting and Evacuation） 判断是否需要使用G1收集器？（1）50%以上的堆被存活对象占用（2）对象分配和晋升的速度变化非常大（3）垃圾回收时间比较长使用Garbage First收集器 -XX:+UseG1G]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中Native关键字]]></title>
    <url>%2F2020%2F03%2F13%2Fjava-zhong-native-guan-jian-zi%2F</url>
    <content type="text"><![CDATA[Native 今天在看java.lang.Object类的时候发现有个静态代码块由Native修饰，并且很疑惑。 native关键字说明被修饰的方法是一个原生态方法，并且方法的实现并不是由java来实现的，而是通过其他语言实现的，例如C++，也可以理解为这是一个java平台和本地c代码交互的API全称Java Native Interface，简称JNI。 为什么需要有这个关键字呢 与java环境外交互，这是本地方法存在的主要原因 有些需求的实现对于java来说非常困难，而且有性能问题的时候需要借助本地方法实现 来着百科对JNI的解释SUN公司发布的Java 本地接口(JNI)提供了将Java与C/C++、汇编等本地代码集成的方案，该规范使得在 Java 虚拟机内运行的 Java 代码能够与其它编程语言互相操作，包括创建本地方法、更新Java对象、调用Java方法，引用 Java类，捕捉和抛出异常等，也允许 Java代码调用 C/C++或汇编语言编写的程序和库。作为一个标准程序接口，它没有对底层 Java虚拟机的实现施加任何限制，并具有以下特点： 二进制兼容。本地方法库与同一平台上所有Java 虚拟机之间实现二进制兼容，即对于给定平台开发人员只需要维护一种版本的本地方法库。 效率高。为了实现实时系统，JNI 在效率与虚拟机无关性之间进行了优化，以保障高效运行。 功能强。JNI 提供了大量的函数及接口让本地方法与Java 虚拟机内核相互操作，增强两者的功能。 本地代码与 Java 虚拟机之间是通过 JNI 函数实现相互操作的。JNI 函数通过接口指针来获得，本地方法将 JNI 接口指针当作参数来接受。虚拟机保证在从相同的 Java 线程中对本地方法进行多次调用时，传递给本地方法的接口指针是相同的，本地方法被不同的 Java 线程调用时，它接受不同的 JNI接口指针。 示例代码public class HelloWorld { public native void displayHelloWorld();//所有native关键词修饰的都是对本地的声明 static { System.loadLibrary("hello");//载入本地库 } public static void main(String[] args) { new HelloWorld().displayHelloWorld(); } }]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JNI</tag>
        <tag>Java Native Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM虚拟机入门]]></title>
    <url>%2F2020%2F03%2F12%2Fjvm-xu-ni-ji-ru-men%2F</url>
    <content type="text"><![CDATA[JVM简介 JVM是JavaVirtualMachine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 JRE/JDK/JVM是什么关系？ JRE(JavaRuntimeEnvironment，Java运行环境)，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。JDK(Java Development Kit)是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。 JVM(JavaVirtualMachine，Java虚拟机)是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。 其他虚拟机通用平台的虚拟机Classic VMJDK1 与 JDK2 的官方默认虚拟机，世界第一种 java 虚拟机通过纯解释器执行 Java 代码，即时编译器只能通过外挂的形式存在，并且不能与解释器一起运行。（那个时候的 Java 很慢） Exact VMSun 公司为了解决 Classic VM 的效率问题而计划研发的，但只在 Solaris 系统上发布过，后来就被 HotSpot 取代了因其使用准确式内存管理而闻名。（知道内存中某一块区域存放的是哪一种数据结构，有利于垃圾收集） HotSpotJDK3 之后的官方默认虚拟机同样有准确式内存管理因其热点探测技术而闻名。（知道哪一段代码经常执行，将其编译成机器代码，提高运行效率） JRockitBEA 公司研发的，对服务端高度优化的虚拟机其垃圾收集机制和 MissionControl 服务套件，一直处于 Java 虚拟机的领先水平Oracle 在 2008 年收购 BEA 公司，在 2009 年收购 Sun 公司。Oracle 计划从 JDK8 开始将两种虚拟机融合成一种。（JDK8 的 HotSpot 已经放弃用永久代来实现方法区，转而使用元空间） J9IBM 公司研发，主要为了在自家研发的产品上跑 Java 程序 其他虚拟机Dalvik VMGoogle 为 Android 开发而研发的虚拟机，不是 java 虚拟机，但关系很密切Dalvik VM 基于寄存器运行，而 JVM 基于栈Dalvik 通过将 class 文件转化为 dex 文件来运行 Microsoft JVM微软曾经在其操作系统上开发了一款 win 专用的 JVM （Win 平台下最快的虚拟机），后和 Sun 打官司输掉，该项目停止。 Apache HarmonyApache 开发的 JDK，但一直没有得到 Sun 公司的授权，Apache 因此退出了 JCP后 Sun 公司开源了 OpenJDK，Apache Harmony 项目就变得不太热门64 位虚拟机因为指针膨胀和数据对齐补白等缘故，64 位虚拟机比 32 位虚拟机所需要消耗的内存更大 （约多 10% - 30% 的开销，性能相差 15%）现在大多数商用系统都是通过虚拟集群的方式来支持大于 4G 的内存。64 位的虚拟机还有一段路要走]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx入门]]></title>
    <url>%2F2020%2F03%2F11%2Fnginx-ru-men%2F</url>
    <content type="text"><![CDATA[nginx入门简介 ginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。 三大功能反向代理什么是代理，和什么是反向代理正向代理加假如 你需要访问谷歌，但是你不能直接访问，需要借助翻墙软件，那么这种行为就是正向代理，即用户—&gt;访问翻墙的服务器(代理服务器)—-&gt;谷歌. 需要明确的是，这种代理服务器带你你访问的方法是由用户主动发起的，对于谷歌来说，他并不能直接知道你，也就是说谷歌对于用户来说是透明的（这里有点不恰当，能大概理解意思即可），但是用户对于谷歌来说谷歌并不知道用户是否使用了代理服务器 反向代理反向代理和正向代理恰好相反，即代理由用户主动变成了谷歌主动。反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。 负载均衡负载均衡：多在高并发情况下需要使用。其原理就是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。 Nginx可使用的负载均衡策略有：轮询（默认）、权重、ip_hash、url_hash(第三方)、fair(第三方)。 动静分离 常用于前后端分离，Nginx提供的动静分离是指把动态请求和静态请求分离开，合适的服务器处理相应的请求，使整个服务器系统的性能、效率更高。 Nginx可以根据配置对不同的请求做不同转发，这是动态分离的基础。静态请求对应的静态资源可以直接放在Nginx上做缓冲，更好的做法是放在相应的缓冲服务器上。动态请求由相应的后端服务器处理。 配置文件详解nginx 文件结构... #全局块 events { #events块 ... } http #http块 { ... #http全局块 server #server块 { ... #server全局块 location [PATTERN] #location块 { ... } location [PATTERN] { ... } } server { ... } ... #http全局块 } 1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。 2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。 3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。 4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。 5、location块：配置请求的路由，以及各种页面的处理情况。 配置举例#定义Nginx运行的用户和用户组 user www www; #nginx进程数，建议设置为等于CPU总核心数。 worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ] error_log /usr/local/nginx/logs/error.log info; #进程pid文件 pid /usr/local/nginx/logs/nginx.pid; #指定进程可以打开的最大描述符：数目 #工作模式与连接数上限 #这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。 #现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。 #这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。 worker_rlimit_nofile 65535; events { #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误. open_file_cache_errors on; } #设定http服务器，利用它的反向代理功能提供负载均衡支持 http { #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream piao.jd.com { #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配 #1、轮询（默认） #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 #2、weight #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 #例如： #upstream bakend { # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #} #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 #例如： #upstream bakend { # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #} #3、fair（第三方） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend { # server server1; # server server2; # fair; #} #4、url_hash（第三方） #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 #upstream backend { # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #} #tips: #upstream bakend #在需要使用负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表示单前的server暂时不参与负载 #2.weight为weight越大，负载的权重就越大。 #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 } #虚拟主机的配置 server { #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.jd.com jd.com; index index.html index.htm index.php; root /data/www/jd; #对******进行负载均衡 location ~ .*.(php|php5)?$ { fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; } #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ { expires 10d; } #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ { expires 1h; } #日志格式设定 #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。 #反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;; #定义本虚拟主机的访问日志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 &quot;/&quot; 启用反向代理 location / { proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数， #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。 #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小 proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置 #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; } #设定查看Nginx状态的地址 location /NginxStatus { stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 } #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ { proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; } #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ { expires 15d; } location ~ .*.(js|css)?$ { expires 1h; } } }]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>分页</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis入门]]></title>
    <url>%2F2020%2F03%2F11%2Fredis-ru-men%2F</url>
    <content type="text"><![CDATA[Redis简介 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 BSD协议 BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销 售，因此是对商业集成很友好的协议。 很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者 二次开发。 非关系型数据库什么是数据库？ 数据库是数据的仓库。 与普通的“数据仓库”不同的是，数据库依据“数据结构”来组织数据，因为“数据结构”，所以我们看到的数据是比较“条理化”的（比如不会跟以前的普通文件存储式存储成一个文件那么不条理化，我们的数据库分成一个个库，分成一个个表，分成一条条记录，这些记录是多么分明） 也因为其“数据结构”式，所以有极高的查找速率（比如B-Tree查找法），（由于专精，可以根据自己的结构特性来快速查找，所以对于数据库的查找会比较快捷；不像普通文件系统的“查找”那么通用） 如果与EXCEL来比的话，能明显的看出数据库的好处，我们能给一个个“字段”添加“约束”（比如约束一列的值不能为空） 数据库与普通的文件系统的主要区别（起因）：数据库能快速查找对应的数据 常说的XX数据库，其实实质上是XX数据库管理系统。数据库管理系统是一个软件，是数据库管理的程序实现。 什么是关系型数据库？ 关系型数据库是依据关系模型来创建的数据库。 所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型,因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。 关系型数据可以很好地存储一些关系模型的数据，比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”） 关系模型是我们生活中能经常遇见的模型，存储这类数据一般用关系型数据库 关系模型包括数据结构（数据存储的问题，二维表）、操作指令集合（SQL语句）、完整性约束(表内数据约束、表与表之间的约束)。 性能官方的bench-mark数据： 测试完成了50个并发执行100000个请求。 设置和获取的值是一个256字节字符串。 Linux box是运行Linux 2.6,这是X3320 Xeon 2.5 ghz。 文本执行使用loopback接口(127.0.0.1)。 结果:读的速度是110000次/s,写的速度是81000次/s 线程问题redis是单线程，线程安全 redis可以能够快速执行的原因： 绝大部分请求是纯粹的内存操作（非常快速） 采用单线程,避免了不必要的上下文切换和竞争条件 非阻塞IO - IO多路复用 IO多路复用中有三种方式：select,poll,epoll。需要注意的是，select,poll是线程不安全的，epoll是线程安全的 redis内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。 数据类型字符串、哈希、列表、集合、有序集合 类型 简介 特性 场景 String(字符串) 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash(字典) 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性 List(列表) 链表(双向链表) 增删快,提供了操作某一段元素的API 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 Set(集合) 哈希表实现,元素不重复 1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set(有序集合) 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列 String（字符串）string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。 实例redis 127.0.0.1:6379> SET runoob "Hello World!" OK redis 127.0.0.1:6379> GET runoob "Hello World!" 在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 runoob，对应的值为 菜鸟教程。 注意：一个键最大能存储 512MB。 Hash（哈希）Redis hash 是一个键值(key=&gt;value)对集合。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 实例DEL runoob 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value redis 127.0.0.1:6379> DEL runoob redis 127.0.0.1:6379> HMSET runoob field1 "Hello" field2 "World" "OK" redis 127.0.0.1:6379> HGET runoob field1 "Hello" redis 127.0.0.1:6379> HGET runoob field2 "World" 实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。 每个 hash 可以存储 232 List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 实例redis 127.0.0.1:6379> DEL runoob redis 127.0.0.1:6379> lpush runoob redis (integer) 1 redis 127.0.0.1:6379> lpush runoob mongodb (integer) 2 redis 127.0.0.1:6379> lpush runoob rabitmq (integer) 3 redis 127.0.0.1:6379> lrange runoob 0 10 1) "rabitmq" 2) "mongodb" 3) "redis" redis 127.0.0.1:6379> 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 Set（集合）Redis 的 Set 是 string 类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 sadd 命令添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。 sadd key member实例redis 127.0.0.1:6379> DEL runoob redis 127.0.0.1:6379> sadd runoob redis (integer) 1 redis 127.0.0.1:6379> sadd runoob mongodb (integer) 1 redis 127.0.0.1:6379> sadd runoob rabitmq (integer) 1 redis 127.0.0.1:6379> sadd runoob rabitmq (integer) 0 redis 127.0.0.1:6379> smembers runoob 1) "redis" 2) "rabitmq" 3) "mongodb" 注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复。 zadd 命令添加元素到集合，元素在集合中存在则更新对应score zadd key score member 实例redis 127.0.0.1:6379> DEL runoob redis 127.0.0.1:6379> zadd runoob 0 redis (integer) 1 redis 127.0.0.1:6379> zadd runoob 0 mongodb (integer) 1 redis 127.0.0.1:6379> zadd runoob 0 rabitmq (integer) 1 redis 127.0.0.1:6379> zadd runoob 0 rabitmq (integer) 0 redis 127.0.0.1:6379> > ZRANGEBYSCORE runoob 0 1000 1) "mongodb" 2) "rabitmq" 3) "redis"]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis常用命令]]></title>
    <url>%2F2020%2F03%2F09%2Fredis-chang-yong-ming-ling%2F</url>
    <content type="text"><![CDATA[Redis 常用命令登录 redis-cli -p 5566 -a password检查key是否存在 EXISTS key搜索某关键字 KSYS *4返回一个Key所影响的vsl的类型 TYPE key Stringset key value ：给数据库中名称为key的string赋予值value get key ：返回数据库中名称为key的string的value getset key value ：给名称为key的string赋予上一次的value mget key1 key2,… key N ：返回库中多个string的value setnx key value ：添加string，名称为key，值为value setex key time value ：向库中添加string，设定过期时间time mset key N value N ：批量设置多个string的值 msetnx key N value N ：如果所有名称为key i的string都不存在 incr key ：名称为key的string增1操作 incrby key integer ：名称为key的string增加integer decr key ：名称为key的string减1操作 decrby key integer ：名称为key的string减少integer append key value ：名称为key的string的值附加value substr key start end ：返回名称为key的string的value的子串 Hashhset key field value ：向名称为key的hash中添加元素field hget key field ：返回名称为key的hash中field对应的value hmget key fields ：返回名称为key的hash中field i对应的value hmset key fields ：向名称为key的hash中添加元素field hincrby key field integer ：将名称为key的hash中field的value增加integer hexists key field ：名称为key的hash中是否存在键为field的域 hdel key field ：删除名称为key的hash中键为field的域 hlen key ：返回名称为key的hash中元素个数 hkeys key ：返回名称为key的hash中所有键 hvals key ：返回名称为key的hash中所有键对应的value hgetall key ：返回名称为key的hash中所有的键（field）及其对应的value Listrpush key value ：在名称为key的list尾添加一个值为value的元素 lpush key value ：在名称为key的list头添加一个值为value的 元素 llen key ：返回名称为key的list的长度 lrange key start end ：返回名称为key的list中start至end之间的元素 ltrim key start end ：截取名称为key的list lindex key index ：返回名称为key的list中index位置的元素 lset key index value ：给名称为key的list中index位置的元素赋值 lrem key count value ：删除count个key的list中值为value的元素 lpop key ：返回并删除名称为key的list中的首元素 rpop key ：返回并删除名称为key的list中的尾元素 blpop key1 key2,… key N timeout ：lpop命令的block版本。 brpop key1 key2,… key N timeout ：rpop的block版本。 rpoplpush srckey dstkey ：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部 setsadd key member ：向名称为key的set中添加元素member srem key member ：删除名称为key的set中的元素member spop key ：随机返回并删除名称为key的set中一个元素 smove srckey dstkey member ：移到集合元素 scard key ：返回名称为key的set的基数 sismember key member ：member是否是名称为key的set的元素 sinter key1 key2,…key N ：求交集 sinterstore dstkey keys ：求交集并将交集保存到dstkey的集合 sunion key1 keys ：求并集 sunionstore dstkey keys ：求并集并将并集保存到dstkey的集合 sdiff key1 keys ：求差集 sdiffstore dstkey keys ：求差集并将差集保存到dstkey的集合 smembers key ：返回名称为key的set的所有元素 srandmember key ：随机返回名称为key的set的一个元素 对value操作exists key ：确认一个key是否存在 del key ：删除一个key type key ：返回值的类型 keys pattern ：返回满足给定pattern的所有key randomkey：随机返回key空间的一个 keyrename oldname newname ：重命名key dbsize：返回当前数据库中key的数目 expire：设定一个key的活动时间（s） ttl：获得一个key的活动时间 select index ：按索引查询 move key dbindex ：移动当前数据库中的key到dbindex数据库 flushdb：删除当前选择数据库中的所有key flushall：删除所有数据库中的所有key]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2F2020%2F03%2F09%2Fshe-ji-mo-shi-zhi-zu-he-mo-shi%2F</url>
    <content type="text"><![CDATA[组合模式 组合模式也叫合成模式，用来描述部分和整体的关系。组合模式，也是很多人没有听说过的，那就不妨了解一下。其实组合模式就是上级管理下级的关系模式，比如说经理可以管理几个员工，他是有增删改查功能，而经理也是被总经理管理。。。 类型 结构型 适用场景 维护和战士部分-整体的场景，如树形菜单、文件和文件夹管理。 从一个整体中能够独立出部分模块或功能场景。 优点 高层模块调用简单：一颗树形结构中所有节点都是Component，局部和整体对调用者来说没有任何区别，高层模块不必关心自己处理的是单个对象还是整个组合结构。 节点自由增加：容易扩展，想要增加节点只要找到它的父节点就行，符合开闭原则，对后续的维护非常有利。 缺点 使得设计更加复杂。客户端需要花更多时间理清类之间的层次关系。 例子 定义 允许将对象组合成树形结构来表现”整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 特点 组件接口同时具有叶子节点和父节点的属性，具有2种角色。组合模式以单一责任设计原则换取透明性。 ### 代码实例import java.util.ArrayList; import java.util.List; /** * 菜单组件，同时具有菜单和菜的角色，菜单可以有子菜单 */ abstract class MenuComponent { /* 菜具有的方法 */ // 获取菜名 public String getName() { throw new UnsupportedOperationException(); } // 获取菜价格 public int getPrice() { throw new UnsupportedOperationException(); } /* 菜单具有的方法 */ // 向菜单中添加菜或子菜单 public void add(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } /* 共有方法 */ public void print() { throw new UnsupportedOperationException(); } } // 菜 class MenuItem extends MenuComponent { public String name; public int price; public MenuItem(String name, int price) { this.name = name; this.price = price; } @Override public String getName() { return name; } @Override public int getPrice() { return price; } @Override public void print() { System.out.println("菜名: " + name + ": " + price); } } // 菜单 class Menu extends MenuComponent { // 用于存储菜名或子菜单 public List&lt;MenuComponent> list = new ArrayList&lt;>(); public String menuName; public Menu(String menuName) { this.menuName = menuName; } @Override public void add(MenuComponent menuComponent) { list.add(menuComponent); } @Override public String getName() { return menuName; } @Override public void print() { System.out.println("菜单名: " + menuName); list.forEach(MenuComponent::print); } } // 客户端演示 class Client { public MenuComponent menuComponent; public void setMenuComponent(MenuComponent menuComponent) { this.menuComponent = menuComponent; } public void print() { menuComponent.print(); } public static void main(String[] args) { Menu menu = new Menu("主菜单"); menu.add(new MenuItem("可乐", 3)); menu.add(new MenuItem("炸鸡", 15)); Menu subMenu = new Menu("子菜单"); subMenu.add(new MenuItem("汉堡", 20)); subMenu.add(new MenuItem("薯条", 10)); // 将子菜单加入主菜单 menu.add(subMenu); Client client = new Client(); client.setMenuComponent(menu); // 递归打印 client.print(); } } 总结这样我们就很方便的表示了整体和部分的关系]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
        <tag>结构型</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2020%2F03%2F09%2Fshe-ji-mo-shi-zhi-dai-li-mo-shi%2F</url>
    <content type="text"><![CDATA[代理模式代理(Proxy)是一种设计模式,提供了间接对目标对象进行访问的方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的功能上,增加额外的功能补充,即扩展目标对象的功能. 这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。 举个例子来说明代理的作用:明星与经纪人之间就是被代理和代理的关系,明星出演活动的时候，明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人) 来解决.这就是代理思想在现实中的一个例子。 静态代理在使用静态代理时,被代理对象与代理对象需要一起实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类. // 接口 interface IStar { void sing(); } // 真实对象 class LDHStar implements IStar { @Override public void sing() { System.out.println("刘德华唱歌"); } } // 代理类需要有真实对象的控制权 (引用) class ProxyManger implements IStar { // 真实对象的引用 private IStar star; public ProxyManger() { super(); } public ProxyManger(IStar star) { super(); this.star = star; } @Override public void sing() { System.out.println("唱歌前准备"); star.sing(); System.out.println("善后工作"); } } class Test{ public static void main(String[] args) { // 创建明星对象 IStar ldh = new LDHStar(); ProxyManger proxy = new ProxyManger(ldh); proxy.sing(); } } 静态代理总结:优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护. 而动态代理方式可以解决上面的问题 动态代理动态代理的主要特点就是能够在程序运行时JVM才为被代理对象生成代理对象。 常说的动态代理也叫做JDK代理也是一种接口代理，JDK中生成代理对象的代理类就是Proxy，所在包是java.lang.reflect //目标类接口 interface IDog{ void run(); } //目标类 class GunDog implements IDog{ @Override public void run() { System.out.println("猎狗在跑"); } } class DogUtils{ public static void method1() { System.out.println("增强方式一"); } public static void method2() { System.out.println("增强方式二"); } } class MyInvocationHandle implements InvocationHandler{ private Object target; public void setTarget(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { DogUtils.method1(); method.invoke(target, args); DogUtils.method2(); return null; } } //生产代理对象的工厂 class MyProxyFactory{ public static Object getProxy(Object target) { MyInvocationHandle handle = new MyInvocationHandle(); handle.setTarget(target); Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handle); return proxy; } } public class ProxyDemo { public static void main(String[] args) { IDog dog = new GunDog(); IDog proxy =(IDog) MyProxyFactory.getProxy(dog); proxy.run(); } } 总结：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能使用动态代理，因此这也算是这种方式的缺陷。 Cglib代理上面的静态代理和动态代理模式有个相同点就是都要求目标对象是实现一个接口的对象,然而并不是任何对象都会实现一个接口，也存在没有实现任何的接口的对象, 这时就可以使用继承目标类以目标对象子类的方式实现代理,这种方法就叫做:Cglib代理，也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展. 使用JDK动态代理有一个限制,就是被代理的对象必须实现一个或多个接口,若想代理没有实现接口的类,就需要使用Cglib实现. public class CglibProxy { public static void main(String[] args) { int[] arr = new int[100000]; for (int i = 0; i &lt; arr.length; i++) { arr[i] = (int) (Math.random() * 1000); } //实例化一个增强器，也就是cglib中的一个class generator Enhancer enhancer = new Enhancer(); //设置目标类 enhancer.setSuperclass(ArraySort2.class); //设置拦截对象，这里直接使用匿名内部类写法 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object object , Method method, Object[] args, MethodProxy proxy) throws Throwable { String sortName = method.getName(); switch (sortName) { case "bubbleSort": sortName = "冒泡排序"; break; case "selectSort": sortName = "选择排序"; break; case "quickSort": sortName = "快速排序"; break; default: break; } long start = System.currentTimeMillis(); //此处一定要使用proxy的invokeSuper方法来调用目标类的方法 proxy.invokeSuper(object, args); long end = System.currentTimeMillis(); System.out.println("本次" + sortName + "的执行时间为: " + (end -start) + "ms"); return null; } }); //生成代理类并返回一个实例 ArraySort2 arraySort = (ArraySort2) enhancer.create(); arraySort.bubbleSort(arr); arraySort.selectSort(arr); arraySort.quickSort(arr); } } class ArraySort2{ public void quickSort(int[] arr) { Arrays.sort(arr); } public void selectSort(int[] arr) { for (int i = 0; i &lt; arr.length; i++) { for (int j = i+1; j &lt; arr.length; j++) { if (arr[i] > arr[j]) { int temp = 0; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } } public void bubbleSort(int[] arr) { for (int i = 0; i &lt; arr.length - 1; i++) { for (int j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] > arr[j + 1]) { int temp = 0; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } } } 总结： 在Spring的AOP编程中: 如果加入容器的目标对象有实现接口,用JDK代理 如果目标对象没有实现接口,用Cglib代理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰者模式]]></title>
    <url>%2F2020%2F03%2F09%2Fshe-ji-mo-shi-zhi-zhuang-shi-zhe-mo-shi%2F</url>
    <content type="text"><![CDATA[装饰者模式定义（动态扩展被装饰者类的功能） 在不改变原有对象的基础之上，将功能附加到对象上。提供了比继承更有弹性的替代方案（扩展原有对象功能） 类型 结构型 适用场景 扩展一个类的功能或者给一个类添加附加职责 给一个对象动态的添加功能，或动态撤销功能。 特点优点 可以动态扩展被装饰类的功能 继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能。（继承在扩展功能是静态的，必须在编译时就确定好，而使用装饰者可以在运行时决定，装饰者也建立在继承的基础之上的） 通过使用不同装饰类以及这些类的排列组合，可以实现不同的效果。 符合开闭原则 缺点 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。 装饰者相关的设计模式 装饰者和代理模式 装饰者模式关注的是对象的动态添加功能。代理模式关注的是对对象的控制访问，对它的用户隐藏对象的具体信息。 装饰者模式和适配器模式 装饰者模式和被装饰的类要实现同一个接口，或者装饰类是被装饰的类的子类。 适配器模式和被适配的类具有不同的接口。 面开始看代码，看代码之前首先假设一个应用场景吧假设我们现在在路边摊看到一个卖煎饼果子的，现在想买煎饼果子，煎饼果子一般的话都是可以加鸡蛋加香肠什么的，好那我们就来模拟一下加在煎饼果子上加东西的操作。 首先我们看一下使用继承的方式怎么实现。 创建一个煎饼果子类 public class Battercake { protected String getDesc(){ return "煎饼果子"; } protected int cost(){ return 8; } } 加鸡蛋类，我们让加鸡蛋类继承煎饼果子类 public class BattercakeWithEgg extends Battercake { @Override public String getDesc() { return super.getDesc()+" 加一个鸡蛋"; } @Override public int cost() { return super.cost()+1; } } 加香肠类，同样的继承煎饼果子类。 public class BattercakeWithEggSausage extends BattercakeWithEgg { @Override public String getDesc() { return super.getDesc()+ " 加一根香肠"; } @Override public int cost() { return super.cost()+2; } } 测试类 public class DecoratorV1Test { public static void main(String[] args) { Battercake battercake = new Battercake(); System.out.println(battercake.getDesc()+" 销售价格:"+battercake.cost()); Battercake battercakeWithEgg = new BattercakeWithEgg(); System.out.println(battercakeWithEgg.getDesc()+" 销售价格:"+battercakeWithEgg.cost()); Battercake battercakeWithEggSausage = new BattercakeWithEggSausage(); System.out.println(battercakeWithEggSausage.getDesc()+" 销售价格:"+battercakeWithEggSausage.cost()); } } 输出结果 煎饼 销售价格:8 煎饼 加一个鸡蛋 销售价格:9 煎饼 加一个鸡蛋 加一根香肠 销售价格:11 这样做有个问题，什么问题呢？假设我们现在要加2个鸡蛋呢？糟糕我们没写加2个鸡蛋的类，如果还有3个4个什么的那是不是就要类爆炸了。下面我们使用装饰者模式实现一下。 首先我们定义一个抽象的煎饼果子 public abstract class ABattercake { protected abstract String getDesc(); protected abstract int cost(); } 实体煎饼果子类，实体煎饼果子继承了抽象煎饼果子类。 public class Battercake extends ABattercake { @Override protected String getDesc() { return "煎饼"; } @Override protected int cost() { return 8; } } 装饰父类，这里也是可以使用抽象类，等会儿我们再说什么时候使用抽象类什么时候使用实体类。注意构造器和这个里面的花费、描述方法的写法。这里注入一个抽象煎饼类的对象。我们的获取描述花费的操作都委托抽象煎饼类来执行，为什么要这么做可以去看看我之前的文章依赖倒置原则。 public class AbstractDecorator extends ABattercake { private ABattercake aBattercake; public AbstractDecorator(ABattercake aBattercake) { this.aBattercake = aBattercake; } @Override protected String getDesc() { return this.aBattercake.getDesc(); } @Override protected int cost() { return this.aBattercake.cost(); } } 鸡蛋的装饰类，这里注意他的构造器，参数是父类的对象抽象煎饼类对象，这里获取描述和花费方法都是调用了父类的方法。 public class EggDecorator extends AbstractDecorator { public EggDecorator(ABattercake aBattercake) { super(aBattercake); } @Override protected String getDesc() { return super.getDesc()+" 加一个鸡蛋"; } @Override protected int cost() { return super.cost()+1; } } 香肠装饰类 public class SausageDecorator extends AbstractDecorator{ public SausageDecorator(ABattercake aBattercake) { super(aBattercake); } @Override protected String getDesc() { return super.getDesc()+" 加一根香肠"; } @Override protected int cost() { return super.cost()+2; } } 最后是测试类，创建一个实体煎饼果子类并赋值给抽象煎饼果子类，然后将这个父类对象注入装饰类，再把得到的对象赋值给创建的抽象对象。 public class DecoratorV2Test { public static void main(String[] args) { ABattercake aBattercake; aBattercake = new Battercake(); aBattercake = new EggDecorator(aBattercake); aBattercake = new EggDecorator(aBattercake); aBattercake = new SausageDecorator(aBattercake); System.out.println(aBattercake.getDesc()+" 销售价格:"+aBattercake.cost()); } } 输入结果 煎饼 加一个鸡蛋 加一个鸡蛋 加一根香肠 销售价格:12 最后我们来说说装饰父类什么时候使用抽象类。一般当我们需要在具体的类中都需涛执行一些特定的操作时。我们一般就会使用抽象类，并定义抽象方法。 public abstract class AbstractDecorator extends ABattercake { private ABattercake aBattercake; public AbstractDecorator(ABattercake aBattercake) { this.aBattercake = aBattercake; } //定义每个抽象类的独特方法 protected abstract void doSomething(); @Override protected String getDesc() { return this.aBattercake.getDesc(); } @Override protected int cost() { return this.aBattercake.cost(); } }]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
        <tag>结构型</tag>
        <tag>装饰者模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F2020%2F03%2F05%2Fshe-ji-mo-shi-zhi-gua-pei-qi-mo-shi%2F</url>
    <content type="text"><![CDATA[适配器模式 适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。 根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。 角色Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 类适配器假设要给一个手机充电，但是手机充电器只能是5v现在有一个220v的电源 被适配类，电源 package adapter; /** * 需要被使用的类 */ public class Volt220 { int v=220; public int volt(){ return v; } } 使用者,即充电器(只需要传入一个实现VoltInter接口的类传入即可充电) package adapter; /** * 手机充电器类 */ public class PhoneCharger{ public void charger(VoltInter volt){ if(volt.getVolt()!=5){ System.out.println("电压不适配，无法充电"); }else{ System.out.println("充电电压5V"); } } } 接口 package adapter; /** * 电压接口,要想给手机充电必须先实现这个接口 */ public interface VoltInter { /** * 获取电压 * @return */ public int getVolt(); } 适配器类(继承被适配类，实现使用者的接口或者抽象类) package adapter; /** * 适配器,基础被使用类，实现电源接口 */ public class ChargerAdapter extends Volt220 implements VoltInter{ @Override public int getVolt() { System.out.println("正在将"+super.volt()+"转换为5v"); return super.volt()/44; } } 这样一个类适配器就完成了，当然你肯定会有很多疑问，比如为什么要使用继承呢，不是继承违反了迪米特法则么，而不是把被适配者传入呢，别慌嘛，因为这是类适配器，底下肯定还要解决这个问题. 特点 违反了迪米特法则，增加了耦合度 因为继承了被适配类，所以可以根据需要重写被适配者，增加了灵活性 对象适配器只需要把上面的代码的适配器更改即可 package adapter; /** * 适配器,基础被使用类，实现电源接口 */ public class ChargerAdapter implements VoltInter{ private Volt220 volt220; public ChargerAdapter(Volt220 volt220) { this.volt220=volt220; } @Override public int getVolt() { System.out.println("正在将"+volt220.volt()+"转换为5v"); return volt220.volt()/44; } } 根据合成复用原则，这样通过传入参数的方式，当然也可以是接口，就解决了类适配器的问题。而且这种方式是一种较为常用的方式 特点 对象适配器和类适配器其实算是同一种思想，只是实现方式不同，根据合成复用原则，使用组合代替继承，所以他解决了继承被适配类的局限性问题，也不需要dist是接口 使用成本更低，更灵活 接口适配器模式当你想实现一个接口但又不想实现所有接口方法，只想去实现一部分方法时，就用中默认的适配器模式，他的方法是在接口和具体实现类中添加一个抽象类，而用抽象类去空实现目标接口的所有方法。而具体的实现类只需要覆盖其需要完成的方法即可。代码如下： 接口 package adapter; /** * 有一个接口 */ public interface Interface { public void method1(); public void method2(); public void method3(); public void method4(); } 抽象类 package adapter; /** *适配器 * 实现该接口所有的方法,但是都是空实现，方便使用这个抽象类的对象只需要关注其中一部分方法，无需全部实现 */ public class Abstract implements Interface{ @Override public void method1() { } @Override public void method2() { } @Override public void method3() { } @Override public void method4() { } } 客户端 package adapter; public class Test { public static void main(String[] args) { //客户端使用只需要实现接口中的一部分即可，就无需实现该接口的所有实现类 new Abstract(){ @Override public void method1(){ }; }; } 这种方法是不是很像gui编程里面事件监听呢，其实他们就是接口适配器模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>接口</tag>
        <tag>适配器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机推挽输出和开漏输出和准双向IO以及上拉电阻]]></title>
    <url>%2F2020%2F03%2F05%2Fdan-pian-ji-tui-wan-shu-chu-he-kai-lou-shu-chu-he-zhun-shuang-xiang-io-yi-ji-shang-la-dian-zu%2F</url>
    <content type="text"><![CDATA[推挽输出推挽输出既可以输出低电平，也可以输出高电平，可以直接驱动功耗不大的数字器件。 推挽电路是由两个三极管或MOSFET，以推挽方式存在于电路中，电路工作时，两只对称的开关管每次只有一个导通，所以导通损耗小、效率高、既提高电路的负载能力，又提高开关速度。其示意结构如下图所示： 当内部输出1电平时,上边的MOS管导通同时下边的MOS管截至,IO口输出高电平; 当内部输出0电平时,上边的MOS管截至同时下边的MOS管导通,IO口输出低电平; 开漏输出开漏输出只能输出低电平,如果要输出高电平必须通过上拉电阻才能实现。就类似于三级管的集电极输出,. 当io口为低电平的时候三极管不导通也就是输出低电平 当io口为高电平的时候三极管导通就输出高电平，也就是说让电路同时具备了高低电平的能力 准双向IO这个可以理解为吧开漏输出集成到了单片机的内部]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>上拉电阻</tag>
        <tag>推挽</tag>
        <tag>开漏</tag>
        <tag>三极管</tag>
        <tag>准双向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2F2020%2F03%2F05%2Fshe-ji-mo-shi-zhi-yuan-xing-mo-shi%2F</url>
    <content type="text"><![CDATA[原型模式 原型模式是一种创建型设计模式,它通过复制一个已经存在的实例来返回新的实例,而不是新建实例.被复制的实例就是我们所称的原型,这个原型是可定制的.原型模式多用于创建复杂的或者耗时的实例, 因为这种情况下,复制一个已经存在的实例可以使程序运行更高效,或者创建值相等,只是命名不一样的同类数据. 特点原型模式中的拷贝分为”浅拷贝”和”深拷贝”:浅拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对 深拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制. 场景现在有一个问题假设我们需要创建一个对象一百次。你就想了，这很简单啊，直接for循环new它一百次就是ojbk了，其实有一个更好的办法，这个办法速度更快，就是java提供的复制 浅拷贝Person类,其中我们只要实现Cloneable接口里面的clone方法即可实现克隆 package Protptype; public class Person implements Cloneable{ private String name; private int age; private Person friend; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person getFriend() { return friend; } public void setFriend(Person friend) { this.friend = friend; } @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } @Override public String toString() { return "Person{" + "name='" + name + '\'' + ", age=" + age + ", friend=" + friend + '}'; } } 但是我为什么标题说他是浅拷贝呢，请看接下来的例子 package Protptype; public class Test { public static void main(String[] args) { Person friend=new Person(); friend.setName("小明"); Person person=new Person(); person.setName("小红"); person.setAge(18); person.setFriend(friend); Person clone=null; try { clone= (Person) person.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } System.out.println("改名前"); System.out.println(person); System.out.println(clone); friend.setName("王小明"); person.setName("王小红"); System.out.println("改名后"); System.out.println(person); System.out.println(clone); } } 改名前 Person{name=&#39;小红&#39;, age=18, friend=Person{name=&#39;小明&#39;, age=0, friend=null}} Person{name=&#39;小红&#39;, age=18, friend=Person{name=&#39;小明&#39;, age=0, friend=null}} 改名后 Person{name=&#39;小红&#39;, age=18, friend=Person{name=&#39;王小明&#39;, age=0, friend=null}} Person{name=&#39;小红的克隆人&#39;, age=18, friend=Person{name=&#39;王小明&#39;, age=0, friend=null}}从上面看出来，当小红的朋友改名字的时候克隆人的朋友也跟着改名字，这么说明他俩的朋友是同一个人，也就是说发生了值复制，也说明了浅复制对于普通变量来说是值复制，对于引用变量来说只是复制了引用，但是为什么改了名字，克隆人的名字和原来人的名字没有一起变化呢，难道string不是引用变量么，不不不，因为String特殊的原因，这里两人的String不是同一个对象，那么我们应该如何实现深复制呢 深复制(clone方法里面clone引用型变量)package Protptype; public class Person implements Cloneable{ private String name; private int age; private Person friend; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person getFriend() { return friend; } public void setFriend(Person friend) { this.friend = friend; } @Override public Object clone() throws CloneNotSupportedException {//在克隆方法中手动复制子类 Person person= (Person) super.clone(); person.setFriend(new Person()); return person; } @Override public String toString() { return "Person{" + "name='" + name + '\'' + ", age=" + age + ", friend=" + friend + '}'; } } 深复制(使用序列化和反序列化推荐使用)package Protptype; import java.io.*; public class Person implements Cloneable,Serializable{ private String name; private int age; private Person friend; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person getFriend() { return friend; } public void setFriend(Person friend) { this.friend = friend; } @Override public Object clone() throws CloneNotSupportedException {//在克隆方法中手动复制子类 return super.clone(); } /** * 深克隆，使用序列化和反序列化进行克隆 * @return * @throws IOException * @throws ClassNotFoundException */ public Object deepClone() throws IOException, ClassNotFoundException { /** * 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject( this ); /** * 写出当前对象二进制流 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois; ois = new ObjectInputStream(bis); return ois.readObject(); } @Override public String toString() { return "Person{" + "name='" + name + '\'' + ", age=" + age + ", friend=" + friend + '}'; } } 结果 改名前 Person{name=&#39;小红&#39;, age=18, friend=Person{name=&#39;小明&#39;, age=0, friend=null}} Person{name=&#39;小红&#39;, age=18, friend=Person{name=&#39;小明&#39;, age=0, friend=null}} 改名后 Person{name=&#39;小红&#39;, age=18, friend=Person{name=&#39;王小明&#39;, age=0, friend=null}} Person{name=&#39;小红的克隆人&#39;, age=18, friend=Person{name=&#39;小明&#39;, age=0, friend=null}}]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>原则</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <url>%2F2020%2F03%2F03%2Fshe-ji-mo-shi-zhi-gong-han-mo-shi%2F</url>
    <content type="text"><![CDATA[工厂模式 厂模式又称为创建模式，它是建对象的一种最佳方式。工厂模式的本质就是用工厂方法代替new操作创建一种实例化对象的方式。一句话中总结就是方便创建 同种类型接口产品 的 复杂对象。 重要特征根据传入的参数不同，来获取大量的对象 适用场景 创建对象需要大量重复的代码。 创建对象需要访问某些信息，而这些信息不应该包含在复合类中。 创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。 简单工厂模式简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。 直接看代码：定义一个抽象产品类形状类Shape abstract class Shape(){ public abstract void shape(); } 定义具体产品： class Circle extends Shape{ public void shape(){ System.out.println("圆形"); } } class Rectangle extends Shape{ public void shape(){ System.out.println("矩形"); } } class Triangle extends Shape{ public void shape(){ System.out.println("三角形"); } } 定义一个工厂生产具体产品 public class ShapeFactory{ public static Shape getshape(String sh){ if(sh.equals("圆形")){ return new Circle(); }else if(sh.equals("矩形")){ return new Rectangle(); }else if(sh.equals("三角形")){ return new Triangle(); }else { return null; } } public static void main(String args[]){//根据需要获取指定对象，和new相比向当于交出了对象的创建 ShapeFactory.getshape("圆形").shape(); } } 从简单工厂中我们可以看出使用一个静态方法将实例化的创建和使用分离开。我们只需要调用方法传递参数就可以获得我们需要的对象。 缺点:我们不难看出如果我们想要增加一个形状类的产品不仅需要添加一个导出类而且我们必须要修改静态方法getshape，这样就违背了开闭原则（对于扩展是开放的，对于修改是封闭的） 工厂模式 假如说我们吧工厂也抽象出来，每次修改工厂产品的时候我们都可以写一个真正的工厂实现抽象工厂，那么我们是不是就解决了简单工厂没有遵守的开闭原则 抽象工厂：为具体工厂提供接口，也就是提供规范，只能有一个。 具体工厂：实现抽象工厂接口的类，可以有多个，根据需要生产的产品的变化可以使用其他的具体工厂 抽象产品：具体产品的父类。 具体产品：工厂模式中所有创建的对象都是具体产品的实例。 直接看代码：定义一个抽象产品类形状类Shape和一个工厂超类 abstract class Shape(){ public abstract void shape(); } abstract class Factory(){ public abstract void CreatShape(); } 定义具体产品： class Circle extends Shape{ public void shape(){ System.out.println("圆形"); } } class Rectangle extends Shape{ public void shape(){ System.out.println("矩形"); } } class Triangle extends Shape{ public void shape(){ System.out.println("三角形"); } } 定义多个个工厂生产具体产品 public class CircleFactory extends Factory { public static Shape CreatShape(String sh){ if(sh.equals("圆形")){ return new Circle(); }else { return null; } } } public class RectangleFactory{ public static Shape CreatShape(String sh){ if(sh.equals("矩形")){ return new Rectangle(); }else { return null; } } } 客户端 public class Test{ public static void main(String args[]){ //根据需要获取指定对象，和new相比向当于交出了对象创建 getshape(new CircleFactory()); } public static void getshape(Factory fac){ fac.CreatShape().shape(); } } 如上所示：即使我们增加一个新的形状类，我们也只需要增加相应的工厂类，不需要修改代码的任何方法。当我们需要这个新产品的时候我们只需要getshap（new 新的工厂类），其他的我们不用去关心，不需要了解方法的实现，对象是如何创建的，我们只需要调用方法就行了——良好的封装性。优点： 良好的封装性：如上面所说。 可以是代码结构变得清晰，有效的封装变化，通常new一个具体类是很复杂多变的，通过工厂方法将new的过 程封装在具体工厂的方法中，调用者无须知道实例化的过程，只需要调用方法就可以得到自己想要的产品。 优点 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销； 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类； 一个具体工厂只能创建一种具体产品 缺点 当一个类不知道它所需要的对象的类时 在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可； 当一个类希望通过其子类来指定创建对象时 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 工厂模式举例java.lang.Calendar类就是一个单例模式+简单工厂模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>原则</tag>
        <tag>工厂设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例设计模式]]></title>
    <url>%2F2020%2F03%2F03%2Fshe-ji-mo-shi-zhi-dan-li-she-ji-mo-shi%2F</url>
    <content type="text"><![CDATA[单例设计模式 单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。 优点： 在内存中只有一个对象，节省内存空间； 避免频繁的创建销毁对象，可以提高性能； 避免对共享资源的多重占用，简化访问； 为整个系统提供一个全局访问点。 缺点： 不适用于变化频繁的对象； 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出； 如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失； 单例设计模式种类 恶汉式 懒汉式 双重检查 静态内部类 枚举 恶汉式(成员变量)public class Singleton01 { public static void main(String[] args) { System.out.println("单例设计模式恶汉式~"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); } } /** * 单例设计模式恶汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 02.提供静态方法提供给外部获取该类 */ class Singleton { private Singleton(){}; //final可以优化 private static final Singleton singleton=new Singleton(); public static Singleton getInstance(){ return singleton; } } 特点 只要类加载就立刻创建对象 如果这个类永远没有被使用那么还是会创建这个对象并且浪费内存 由于在类装载的时候实例化这个对象，所以不会造成线程安全问题 恶汉式(静态代码块)public class Singleton01 { public static void main(String[] args) { System.out.println("单例设计模式恶汉式~"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); } } /** * 单例设计模式恶汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 02.提供静态方法提供给外部获取该类 */ class Singleton { static { singleton=new Singleton(); } private Singleton(){}; private static Singleton singleton; public static Singleton getInstance(){ return singleton; } } 特点这个特点和上面一样 懒汉式(延迟加载，但线程不安全)public class Singleton01 { public static void main(String[] args) { System.out.println("单例设计模式懒汉式~线程不安全"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); } } /** * 单例设计模式懒汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 03.提供静态方法提供给外部获取该类 * 04.提供静态方法中判断是否已经创建对象 */ class Singleton { private Singleton(){}; private static Singleton singleton; public static Singleton getInstance(){ if(singleton==null){ //有可能多个线程同时进入这个代码块，以至于单例模式并不单例 singleton=new Singleton(); } return singleton; } } 特点 实现了懒加载，保证了不浪费内存，但是带来了新的问题 在多线程的情况下有可能创建多个Singleton对象 懒汉式(延迟加载，方法同步)public class Singleton01 { public static void main(String[] args) { System.out.println("单例设计模式懒汉式~线程不安全"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); } } /** * 单例设计模式懒汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 03.提供静态方法提供给外部获取该类 * 04.提供静态方法中判断是否已经创建对象 */ class Singleton { private Singleton(){}; private static Singleton singleton; //相比上面的添加了方发锁，来保证线程安全问题，但是多个线程创建对象的时候其他现在必须在外部等待 public static synchronized Singleton getInstance(){ if(singleton==null){ singleton=new Singleton(); } return singleton; } } 特点 实现了懒加载，也避免了线程安全问题。 但是由于同步方法颗粒度过大，导致创建的时候验证影响效率 懒汉式(延迟加载，双重检查)public class Singleton01 { public static void main(String[] args) { System.out.println("单例设计模式懒汉式~线程不安全"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); } } /** * 单例设计模式懒汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 03.提供静态方法提供给外部获取该类 * 04.提供静态方法中判断是否已经创建对象 */ class Singleton { private Singleton(){}; private static volatile Singleton singleton; public static Singleton getInstance(){ if(singleton==null){ synchronized (Singleton.class){ //在创建单例设计模式的时候双重检查保证了多个线程中只有一个线程去创建静态对象，二其他线程无需等待 if(singleton==null) { singleton = new Singleton(); } } } return singleton; } } 关于volatile关键字的使用，在单线程的环境下是不存在指令重排的情况，涉及到多线程就会涉及到指令重排。比如创建对象大致为三个过程：1.开辟内存空间2.创建对象。3.对象指定内存空间。在创建对象的过程中，多线程环境中是不一定会按照指令的顺序来进行创建对象。所以需要添加volitile关键字，保证对象是创建完毕再继续使用。 特点 实现了该类的懒加载 解决了线程问题，并且也解决了性能问题,推荐使用 静态内部类class Singleton1{ private static Singleton1 singleton; private Singleton1(){}; private static class LazyHolder { //防止内部误操作，不小心对其使用了代理或者其他的情况，final修饰，不允许改变 private static final Singleton1 INSTANCE = new Singleton1(); } public static Singleton1 getInstance(){ return LazyHolder.INSTANCE; } } 通过内部类来实现懒加载单例模式，该种实现方式也较为常用。关于内部类实现懒加载的解释：类信息只有在使用其Class相关的时候才会加载字节码相关的类信息。静态内部类同样如此，只有在用到静态内部类的时候才会去用到我们内部类的静态相关信息。所以称其为懒加载。 很多种单例的写法都有一个通病，就是无法防止反射机制的漏洞，从而无法保证对象的唯一性，如下举例： 利用如下的反正代码对上文构造的单例进行对象的创建。 枚举enum Singleton1 { INSTANCE; public void sayOk(){ System.out.println("OK"); } } 嘿嘿嘿就是这么简单。 其实这就是 enum 的一块语法糖，JVM 会阻止反射获取枚举类的私有构造方法。 仍然使用上文的反射代码来进行测试，发现，报错。嘿嘿，完美解决反射的问题。 4、缺点 使用枚举的方法是起到了单例的作用，但是也有一个弊端， 那就是 无法进行懒加载。 单例模式举例java.lang.Runtime这个类就是个典型的懒汉模式单例设计模式]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>原则</tag>
        <tag>单例设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之七大原则]]></title>
    <url>%2F2020%2F02%2F23%2Fshe-ji-mo-shi-zhi-qi-da-yuan-ze%2F</url>
    <content type="text"><![CDATA[设计模式什么是设计模式 设计模式最早是从建筑领域引入到软件工程领域的，软件开发者在平时开发软件的时候发现有些场景和需求在不同的软件开发中是很相似的，于是乎将这些解决方案抽象出来就形成了设计模式 设计模式的目的和作用(5大作用目的) 代码重用性 可读性 可扩展性 可靠性 使程序呈现高内聚，低耦合的特性 设计模式的七大原则 单一职责原则 接口隔离原则 依赖倒置(倒转)原则 里氏替换原则 迪米特法则 合成复用原则 开闭原则 单一职责原则介绍 对于一个类来说一个类应该只负责一项职责，如果一个类负责多个职责，则应该拆分这个类，（如果这个类功能特别单一则可以违反类单一职责原则，但是要遵循方法单一职责原则） 举例太简单了，太容易了就不举例了╮(╯▽╰)╭ 单一职责原则细节和注意事项 降低类的复杂度，一个类只负责一项职责 提高类的可读性，可维护性 降低变更引起的风险 通常情况下要遵守单一职责原则，只有逻辑足够简单，才可以违反类单一则责原则，但是要在方法层面上遵循单一职责原则 接口隔离原则介绍 一个类不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 举例类A和类B都依赖一个接口interface,并且类A只需要这个接口的前几个方法，而类B只需要后几个方法，类A1和类B1都是对该接口的实现，不过类A1主要由类A调用实现，如果只有一个接口的话，那么类A1和类B1都要实现这个接口的所有方法。 错误示范interface I { public void method1(); public void method2(); public void method3(); public void method4(); public void method5(); } class A{ public void depend1(I i){ i.method1(); } public void depend2(I i){ i.method2(); } public void depend3(I i){ i.method3(); } } class A1 implements I{ public void method1() { System.out.println("类A1实现接口I的方法1"); } public void method2() { System.out.println("类A1实现接口I的方法2"); } public void method3() { System.out.println("类A1实现接口I的方法3"); } //对于类A1来说，method4和method5不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method4() {} public void method5() {} } class B{ public void depend2(I i){ i.method4(); } public void depend3(I i){ i.method5(); } } class B1 implements I{ public void method1() {} //对于类B1来说，method2和method3不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method2() {} public void method3() {} public void method4() { System.out.println("类B1实现接口I的方法4"); } public void method5() { System.out.println("类B1实现接口I的方法5"); } } 正确示范上述情况其实我们可以把I接口分解成两个接口，让A1实现接口一让B1实现接口2即可，这样就隔离开了这两个接口，并且这两个接口都是他们的最小接口，那这样就是接口隔离原则了。 interface I1 { public void method1(); public void method2(); public void method3(); } interface I2 { public void method4(); public void method5(); } class A{ public void depend1(I1 i){ i.method1(); } public void depend2(I1 i){ i.method2(); } public void depend3(I1 i){ i.method3(); } } class A1 implements I1{//那么就可以不实现4和5方法了 public void method1() { System.out.println("类A1实现接口I1的方法1"); } public void method2() { System.out.println("类A1实现接口I1的方法2"); } public void method3() { System.out.println("类A1实现接口I1的方法3"); } } class B{ public void depend2(I2 i){ i.method4(); } public void depend3(I2 i){ i.method5(); } } class B1 implements I2{ public void method4() { System.out.println("类B1实现接口I2的方法4"); } public void method5() { System.out.println("类B1实现接口I2的方法5"); } } 接口隔离原则细节和注意事项 接口要高内聚。什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互. 定制服务。一个系统或系统内的模块之间必然会有耦合，有耦合就要相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或者是单纯的数据交换），我们设计时就需要给各个访问者（也就是客户端）定制服务，什么是定制服务？单独为一个个体提供优良优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的定义要采用定制服务，采用定制服务就必然有一个要求就是：只提供访问者需要的方法，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 接口尽量小，但是要有限度。接口的设计粒度是越小系统越灵活，这是不争的事实，但是这就带来成接口数量过多，使设计结构的复杂化，开发难度增加，维护性降低，这不是一个项目或产品所期望看到的。所以一定要适度。 依赖倒置原则介绍 1、高层模块不应该依赖底层模块，二者都应该依赖抽象。 2、抽象不应该依赖细节，细节应该依赖抽象。 3、依赖倒置的中心思想是面向接口编程。 4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。 5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。 举例错误示范假如我喜欢玩游戏，那么有两个类，一个类是我只有一个方法就是玩，然后还有一个游戏类 class My{ public void play(Factorio i){ System.out.println("我在玩"+i.getName()); } } class Factorio{ public String getName(){ return "异星工厂"; } } public class Test{ public static void main(String[]args){ new My().play(new Factorio()); } } 假如说我玩的游戏不知一个，有多个游戏那么上面代码怎么办呢，是不是就需要写多个play方法重载之类进行解决呢。 正确示范interface Play{ public void getName(); } class My{ public void play(Play i){ System.out.println("我在玩"+i.getName()); } } class Factorio implements Play{ public String getName(){ return "异星工厂"; } } class BF4 implements Play{ public String getName(){ return "战地4"; } } public class Test{ public static void main(String[]args){ new My().play(new Factorio()); new My().play(new BF4()); } } 这样每次新增功能的改动就非常小了 注意事项 低层模块尽量都要有抽象类或者接口，或者而知都有，这样程序稳定性更好 变量的生命类型尽量是抽象类或者接口，这样我们的变量引用和实际对象间就存在一个缓存层，利于程序的扩展和优化 继承时遵循里氏原则 抽象不应该依赖细节 细节应该依赖抽象 里氏替换原则介绍 里氏替换原则(LSP)指的是所有引用基类的地方都可以透明的使用其子类的对象 可以理解为:只要有父类出现的地方，都可以使用子类来替代。而且不会出现任何错误或者异常。但是反过来却不行。子类出现的地方,不能使用父类来替代。 如果不符合上述的规定的话，我们可以想象子类的实例化调用方法时候,调用的确实父类的方法。会出现意想不到的结果 代码就不放出来了,这个也没有啥好说的里氏替换原则细节和注意事项 子类必须实现父类的抽象方法，但不得重写父类的非抽象(已实现的)方法。 子类中可增加自己特有的方法。(可以随时扩展) 当子类覆盖或者实现父类的方法时,方法的前置条件(方法形参)要比父类输入参数更加宽松。否则会调用到父类的方法。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。否则会调用到父类的方法。 开闭原则定义 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 举例现在有一个图形基础类还有两个继承图形基础类的子类三角形和正方形，还有一个工具类可以将传入的图形之类画出来 错误示范class Graph{ Integer id; } class Triangle extends Graph{ public Triangle(){ super.id=1; } public void drawTriangle(){ System.out.println("画三角形"); } } class Square extends Graph{ public Triangle(){ super.id=2; } public void drawSquare(){ System.out.println("画正方形"); } } class Painting{ void painting(Graph g){ if(g.id==1){ g.drawTriangle(); }else if(g.id==2){ g.drawSquare(); } } } public class Test{ public static void main(String[] args){ Painting p=new Painting(); p.painting(new drawTriangle()); } } 如果现在我们有一个新的需求需要添加一个新的图形，那么一定得修改工具类Painting里面的方法，而且还要添加新的类 正确示范 class Graph{ Integer id; abstract void draw(); } class Triangle extends Graph{ public Triangle(){ super.id=1; } public void draw(){ System.out.println("画三角形"); } } class Square extends Graph{ public Triangle(){ super.id=2; } public void draw(){ System.out.println("画正方形"); } } class Painting{ void painting(Graph g){ g.draw(); } } public class Test{ public static void main(String[] args){ Painting p=new Painting(); p.painting(new drawTriangle()); } } 我们把基础图形类Graph的一个方法draw定义成抽象的，接下来他的所有子类都实现这个方法，那么我们新增一个新的图形类那么只需要继承这个基础图形类即可，无需在修改工具类Painting类里面的方法，这样就满足了开闭原则。 那么我们为什么要在基类Graph里面新添一个抽象方法而不让其他的子类的同一个名字来解决呢，因为painting这个方法的参数是基类的，如果只是单独修改子类的方法为draw那么就不满足多态的概念，仔细想想为什么吧。 开闭原则细节和注意事项 要是面向对象的编程，在开发过程中都会强调开闭原则 是最基础的设计原则，其他五个设计原则都是开闭原则的具体形态 可以提高代码的复用性 可以提高代码的可维护性 用抽象构建框架，用实现扩展细节 迪米特法则（最少知道原则）定义迪米特法则(Law of Demeter, LoD)是1987年秋天由lan holland在美国东北大学一个叫做迪米特的项目设计提出的，它要求一个对象应该对其他对象有最少的了解，所以迪米特法则又叫做最少知识原则（Least Knowledge Principle, LKP）。 举例举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。 //总公司员工 class Employee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; } } //分公司员工 class SubEmployee{ private String id; public void setId(String id){ this.id = id; } public String getId(){ return id; } } class SubCompanyManager{ public List&lt;SubEmployee> getAllEmployee(){ List&lt;SubEmployee> list = new ArrayList&lt;SubEmployee>(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId("分公司"+i); list.add(emp); } return list; } } class CompanyManager{ public List&lt;Employee> getAllEmployee(){ List&lt;Employee> list = new ArrayList&lt;Employee>(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId("总公司"+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ List&lt;SubEmployee> list1 = sub.getAllEmployee(); for(SubEmployee e:list1){ System.out.println(e.getId()); } List&lt;Employee> list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } //客户端 public class Client{ public static void main(String[] args){ CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); } } 现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下: class SubCompanyManager{ public List&lt;SubEmployee> getAllEmployee(){ List&lt;SubEmployee> list = new ArrayList&lt;SubEmployee>(); for(int i=0; i&lt;100; i++){ SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId("分公司"+i); list.add(emp); } return list; } public void printEmployee(){ List&lt;SubEmployee> list = this.getAllEmployee(); for(SubEmployee e:list){ System.out.println(e.getId()); } } } class CompanyManager{ public List&lt;Employee> getAllEmployee(){ List&lt;Employee> list = new ArrayList&lt;Employee>(); for(int i=0; i&lt;30; i++){ Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId("总公司"+i); list.add(emp); } return list; } public void printAllEmployee(SubCompanyManager sub){ sub.printEmployee(); List&lt;Employee> list2 = this.getAllEmployee(); for(Employee e:list2){ System.out.println(e.getId()); } } } 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 合成复用原则 软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现 问题由来：通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 解决方案：合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电路基础]]></title>
    <url>%2F2020%2F02%2F16%2Fdian-lu-ji-chu%2F</url>
    <content type="text"><![CDATA[前言 最近在学习51单片机，但是无奈初中电路知识忘了，结果难以理解现在的一些东西，比如上拉电阻，于是乎我打算学习一下电路的基本知识. 欧姆定律在同一电路中，通过某一导体的电流跟这段导体两端的电压成正比，跟这段导体的电阻成反比,这就是欧姆定律. U=I*R I=U/R 分压定律和分流定律在串联电路中，各电阻上的电流相等，各电阻两端的电压之和等于电路总电压。可知每个电阻上的电压小于电路总电压，故串联电阻分压。 在并联电路中，各电阻两端的电压相等，各电阻上的电流之和等于总电流（干路电流）。可知每个电阻上的电流小于总电流（干路电流），故并联电阻分流。 电阻的串并联就好像水流，串联只有一条道路，电阻越大，流的越慢，并联的支路越多，电流越大。 那么问题来了怎么计算并联电路的支路上的电流呢 例子分流假设有一个并联电路，其中有两个路，我们假设这两条支路个有一个电阻。 分路1电流=干路电流*分路2电阻/（分路电阻1+分路电阻2） 分压假设有一个串联电路，其中有两个电阻 电阻1电压=总电压*(电阻1大小)/(电阻1+电阻2) 其实能把这些电路知识想象成水流就能明白很多了，例如电流的大小就是水流的大小，电阻就是河道对水流的阻碍，电压大小就是水流速度，那么久很容易啦(^o^)/~]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>电路</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot缓存详解]]></title>
    <url>%2F2020%2F02%2F14%2Fspringboot-huan-cun-xiang-jie%2F</url>
    <content type="text"><![CDATA[缓存的作用 缓存就是用于数据交换的缓冲区，一半特点就是速度快。 1.热点数据放入缓存以减少对数据库的访问次数2.临时数据放入缓存中减少数据库的压力，例如短信验证码3分钟有效就可以放入缓存中，超过3分钟就从缓存中去掉。不同缓存的作用操作系统磁盘缓存 ——&gt; 减少磁盘机械操作。数据库缓存——&gt;减少文件系统IO。应用程序缓存——&gt;减少对数据库的查询。Web服务器缓存——&gt;减少应用服务器请求。客户端浏览器缓存——&gt;减少对网站的访问。 缓存的策略1.基于访问时间 2.基于频率 3.基于访问模式 JSR107jsr107定义了5个核心接口 CachingProvider缓存提供者，定义了创建、配置、获取、管理多个CachingManager,并且一个java应用可以在运行期有多个CachingProviderCachingManage缓存管理器，定义了创建、配置、获取、管理多个唯一命名的Cache,这些Cache存在CacheManage的上下文中，并且CacheManage只能被一个CachingProvider拥有Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。Entry是一个存储在Cache中的key-value对。Expiry每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。springboot缓存抽象Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 使用Spring缓存抽象时我们需要关注以下两点； 确定方法需要被缓存以及他们的缓存策略 从缓存中读取之前缓存存储的数据 三、 几个重要概念和缓存注解 Cache 缓存接口，定义缓存操作。实现有： RedisCache、 EhCacheCache、 ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 简要说明： @Cacheable注解加载方法中，那么该方法第一次会查询数据库，然后就会吧数据放在缓存中，使用Cache 进行数据的读取等操作。 @CacheEvict删除缓存，例如根据id删除用户，那么也要删除缓存中的用户信息 @CachePut更新缓存，例如更新用户信息后，同时也要更新缓存中的用户信息 Cache SpEL available metadata 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})）， 则有两个cache #root.caches[0].name argument name evaluation context 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的 形式， 0代表参数的索引； #iban 、 #a0 、 #p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如 ‘unless’ ， ’cache put’的表达式 ’cache evict’的表达式 beforeInvocation=false） #result 四、缓存使用 1、引入spring-boot-starter-cache模块 2、 @EnableCaching开启缓存 3、使用缓存注解 4、切换为其他缓存* SpELSpring Cache提供了一些供我们使用的SpEL上下文数据，下表直接摘自Spring官方文档： 名称 位置 描述 示例 methodName root对象 当前被调用的方法名 #root.methodname method root对象 当前被调用的方法 #root.method.name target root对象 当前被调用的目标对象实例 #root.target targetClass root对象 当前被调用的目标对象的类 #root.targetClass args root对象 当前被调用的方法的参数列表 #root.args[0] caches root对象 当前方法调用使用的缓存列表 #root.caches[0].name Argument Name 执行上下文 当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数 #artsian.id result 执行上下文 方法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false） #result 注意： 1.当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。 如 @Cacheable(key = &quot;targetClass + methodName +#p0&quot;)2.使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。 如： @Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;) @Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;)SpEL提供了多种运算符 类型 运算符 关系 &lt;，&gt;，&lt;=，&gt;=，==，!=，lt，gt，le，ge，eq，ne 算术 +，- ，* ，/，%，^ 逻辑 &amp;&amp;，||，!，and，or，not，between，instanceof 条件 ?: (ternary)，?: (elvis) 正则表达式 matches 其他类型 ?.，?[…]，![…]，^[…]，$[…] 演示1.开始使用前需要导入依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-cache&lt;/artifactId> &lt;/dependency> 2.然后在启动类注解@EnableCaching开启缓存@SpringBootApplication @EnableCaching //开启缓存 public class DemoApplication{ public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } } 3.缓存@Cacheable``@Cacheable注解会先查询是否已经有缓存，有会使用缓存，没有则会执行方法并缓存。 @Cacheable(value = &quot;emp&quot; ,key = &quot;targetClass + methodName +#p0&quot;) public List&lt;NewJob&gt; queryAll(User uid) { return newJobDao.findAllByUid(uid); }此处的value是必需的，它指定了你的缓存存放在哪块命名空间。 此处的key是使用的spEL表达式，参考上章。这里有一个小坑，如果你把methodName换成method运行会报错，观察它们的返回类型，原因在于methodName是String而methoh是Method。 此处的User实体类一定要实现序列化public class User implements Serializable，否则会报java.io.NotSerializableException异常。 到这里，你已经可以运行程序检验缓存功能是否实现。 深入源码，查看它的其它属性 我们打开@Cacheable注解的源码，可以看到该注解提供的其他属性，如： String[] cacheNames() default {}; //和value注解差不多，二选一 String keyGenerator() default &quot;&quot;; //key的生成器。key/keyGenerator二选一使用 String cacheManager() default &quot;&quot;; //指定缓存管理器 String cacheResolver() default &quot;&quot;; //或者指定获取解析器 String condition() default &quot;&quot;; //条件符合则缓存 String unless() default &quot;&quot;; //条件符合则不缓存 boolean sync() default false; //是否使用异步模式4.配置@CacheConfig当我们需要缓存的地方越来越多，你可以使用@CacheConfig(cacheNames = {&quot;myCache&quot;})注解来统一指定value的值，这时可省略value，如果你在你的方法依旧写上了value，那么依然以方法的value值为准。 使用方法如下： @CacheConfig(cacheNames = {"myCache"}) public class BotRelationServiceImpl implements BotRelationService { @Override @Cacheable(key = "targetClass + methodName +#p0")//此处没写value public List&lt;BotRelation> findAllLimit(int num) { return botRelationRepository.findAllLimit(num); } } 查看它的其它属性 String keyGenerator() default ""; //key的生成器。key/keyGenerator二选一使用 String cacheManager() default ""; //指定缓存管理器 String cacheResolver() default ""; //或者指定获取解析器 5.更新@CachePut@CachePut注解的作用 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用 。简单来说就是用户更新缓存数据。但需要注意的是该注解的value 和 key 必须与要更新的缓存相同，也就是与@Cacheable 相同。示例： @CachePut(value = "emp", key = "targetClass + #p0") public NewJob updata(NewJob job) { NewJob newJob = newJobDao.findAllById(job.getId()); newJob.updata(job); return job; } @Cacheable(value = "emp", key = "targetClass +#p0")//清空缓存 public NewJob save(NewJob job) { newJobDao.save(job); return job; } 查看它的其它属性 String[] cacheNames() default {}; //与value二选一 String keyGenerator() default ""; //key的生成器。key/keyGenerator二选一使用 String cacheManager() default ""; //指定缓存管理器 String cacheResolver() default ""; //或者指定获取解析器 String condition() default ""; //条件符合则缓存 String unless() default ""; //条件符合则不缓存 6.清除@CacheEvict@CachEvict 的作用 主要针对方法配置，能够根据一定的条件对缓存进行清空 。 属性 解释 示例 allEntries 是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存 @CachEvict(value=”testcache”,allEntries=true) beforeInvocation 是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存 @CachEvict(value=”testcache”，beforeInvocation=true) 示例： @Cacheable(value = "emp",key = "#p0.id") public NewJob save(NewJob job) { newJobDao.save(job); return job; } //清除一条缓存，key为要清空的数据 @CacheEvict(value="emp",key="#id") public void delect(int id) { newJobDao.deleteAllById(id); } //方法调用后清空所有缓存 @CacheEvict(value="accountCache",allEntries=true) public void delectAll() { newJobDao.deleteAll(); } //方法调用前清空所有缓存 @CacheEvict(value="accountCache",beforeInvocation=true) public void delectAll() { newJobDao.deleteAll(); } 其他属性 String[] cacheNames() default {}; //与value二选一 String keyGenerator() default &quot;&quot;; //key的生成器。key/keyGenerator二选一使用 String cacheManager() default &quot;&quot;; //指定缓存管理器 String cacheResolver() default &quot;&quot;; //或者指定获取解析器 String condition() default &quot;&quot;; //条件符合则清空7.组合@Caching有时候我们可能组合多个Cache注解使用，此时就需要@Caching组合多个注解标签了。 @Caching(cacheable = { @Cacheable(value = "emp",key = "#p0"), ... }, put = { @CachePut(value = "emp",key = "#p0"), ... },evict = { @CacheEvict(value = "emp",key = "#p0"), .... }) public User save(User user) { .... } 下面讲到的整合第三方缓存组件都是基于上面的已经完成的步骤，所以一个应用要先做好你的缓存逻辑，再来整合其他cache组件。 五：整合EHCACHEEhcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 1.导入依赖整合ehcache必须要导入它的依赖。 &lt;dependency> &lt;groupId>net.sf.ehcache&lt;/groupId> &lt;artifactId>ehcache&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-cache&lt;/artifactId> &lt;/dependency> 2.yml配置需要说明的是config: classpath:/ehcache.xml可以不用写，因为默认就是这个路径。但ehcache.xml必须有。 spring: cache: type: ehcache ehcache: config: classpath:/ehcache.xml 3.ehcache.xml在resources目录下新建ehcache.xml，注释啥的应该可以说相当详细了 &lt;ehcache> &lt;!-- 磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存 path:指定在硬盘上存储对象的路径 path可以配置的目录有： user.home（用户的家目录） user.dir（用户当前的工作目录） java.io.tmpdir（默认的临时目录） ehcache.disk.store.dir（ehcache的配置目录） 绝对路径（如：d:\\ehcache） 查看路径方法：String tmpDir = System.getProperty("java.io.tmpdir"); --> &lt;diskStore path="java.io.tmpdir" /> &lt;!-- defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理 maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象 eternal:代表对象是否永不过期 (指定true则下面两项配置需为0无限期) timeToIdleSeconds:最大的发呆时间 /秒 timeToLiveSeconds:最大的存活时间 /秒 overflowToDisk:是否允许对象被写入到磁盘 说明：下列配置自缓存建立起600秒(10分钟)有效 。 在有效的600秒(10分钟)内，如果连续120秒(2分钟)未访问缓存，则缓存失效。 就算有访问，也只会存活600秒。 --> &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="600" overflowToDisk="true" /> &lt;cache name="myCache" maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="600" overflowToDisk="true" /> &lt;/ehcache> 4.使用缓存@CacheConfig(cacheNames = {“myCache”})设置ehcache的名称，这个名称必须在ehcache.xml已配置 。 @CacheConfig(cacheNames = {"myCache"}) public class BotRelationServiceImpl implements BotRelationService { @Cacheable(key = "targetClass + methodName +#p0") public List&lt;BotRelation> findAllLimit(int num) { return botRelationRepository.findAllLimit(num); } } 整合完毕！ 别忘了在启动类开启缓存！]]></content>
      <categories>
        <category>框架</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SSM</tag>
        <tag>Mybatis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <url>%2F2020%2F01%2F30%2Fdocker-ru-men%2F</url>
    <content type="text"><![CDATA[Docker入门前言 docker是一种容器,其产生的目的只要是解决了开发环境和运维环境不同的一个解决方案，解决了运行环境和配置环境的问题，但是它又和虚拟化技术不同，docker比虚拟化技术占用资源更少，启动更快，甚至启动是毫秒级的 Docker的重要部分镜像 将软件环境打包好的模板，用来创建容器的，一个镜像可以创建多个容器。 容器 Docker的运行组件，启动一个镜像就是一个容器，容器与容器之间相互隔离，并且互不影响。 仓库仓库就是镜像的仓库，分为私有仓库和公共仓库，其中私有仓库是自己的镜像仓库，公共仓库是docker提供的仓库 docker常用命令1、Docker容器信息##查看docker容器版本 docker version ##查看docker容器信息 docker info ##查看docker容器帮助 docker --help2、镜像操作提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。 2.1、镜像查看##列出本地images docker images ##含中间映像层 docker images -a ##只显示镜像ID docker images -q ##含中间映像层 docker images -qa ##显示镜像摘要信息(DIGEST列) docker images --digests ##显示镜像完整信息 docker images --no-trunc ##显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc 显示完整的提交记录；-q 仅列出提交记录ID docker history -H redis2.2、镜像搜索##搜索仓库MySQL镜像 docker search mysql ## --filter=stars=600：只显示 starts&gt;=600 的镜像 docker search --filter=stars=600 mysql ## --no-trunc 显示镜像完整 DESCRIPTION 描述 docker search --no-trunc mysql ## --automated ：只列出 AUTOMATED=OK 的镜像 docker search --automated mysql 2.3、镜像下载##下载Redis官方最新镜像，相当于：docker pull redis:latest docker pull redis ##下载仓库所有Redis镜像 docker pull -a redis ##下载私人仓库镜像 docker pull bitnami/redis 2.4、镜像删除##单个镜像删除，相当于：docker rmi redis:latest docker rmi redis ##强制删除(针对基于镜像有运行的容器进程) docker rmi -f redis ##多个镜像删除，不同镜像间以空格间隔 docker rmi -f redis tomcat nginx ##删除本地全部镜像 docker rmi -f $(docker images -q)2.5、镜像构建##（1）编写dockerfile cd /docker/dockerfile vim mycentos ##（2）构建docker镜像 docker build -f /docker/dockerfile/mycentos -t mycentos:1.13、容器操作提示：对于容器的操作可使用CONTAINER ID 或 NAMES。 3.1、容器启动##新建并启动容器，参数：-i 以交互模式运行容器；-t 为容器重新分配一个伪输入终端；--name 为容器指定一个名称 docker run -i -t --name mycentos ##后台启动容器，参数：-d 已守护方式启动容器 docker run -d mycentos注意：此时使用”docker ps -a”会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。 ##启动一个或多个已经被停止的容器 docker start redis ##重启容器 docker restart redis3.2、容器进程##top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS] ##列出redis容器中运行进程 docker top redis ##查看所有运行容器的进程信息 for i in `docker ps |grep Up|awk &#39;{print $1}&#39;`;do echo \ &amp;&amp;docker top $i; done3.3、容器日志##查看redis容器日志，默认参数 docker logs rabbitmq ##查看redis容器日志，参数：-f 跟踪日志输出；-t 显示时间戳；--tail 仅列出最新N条容器日志； docker logs -f -t --tail=20 redis ##查看容器redis从2019年05月21日后的最新10条日志。 docker logs --since=&quot;2019-05-21&quot; --tail=10 redis3.4、容器的进入与退出##使用run方式在创建时进入 docker run -it centos /bin/bash ##关闭容器并退出 exit ##仅退出容器，不关闭 快捷键：Ctrl + P + Q ##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false 确保CTRL-D或CTRL-C不会关闭容器 docker attach --sig-proxy=false centos ##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i 即使没有附加也保持STDIN 打开；-t 分配一个伪终端 docker exec -i -t centos /bin/bash ##以交互模式在容器中执行命令，结果返回到当前终端屏幕 docker exec -i -t centos ls -l /tmp ##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端 docker exec -d centos touch cache.txt 3.5、查看容器##查看正在运行的容器 docker ps ##查看正在运行的容器的ID docker ps -q ##查看正在运行+历史运行过的容器 docker ps -a ##显示运行容器总文件大小 docker ps -s ##显示最近创建容器 docker ps -l ##显示最近创建的3个容器 docker ps -n 3 ##不截断输出 docker ps --no-trunc ##获取镜像redis的元信息 docker inspect redis ##获取正在运行的容器redis的 IP docker inspect --format=&#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39; redis3.6、容器的停止与删除##停止一个运行中的容器 docker stop redis ##杀掉一个运行中的容器 docker kill redis ##删除一个已停止的容器 docker rm redis ##删除一个运行中的容器 docker rm -f redis ##删除多个容器 docker rm -f $(docker ps -a -q) docker ps -a -q | xargs docker rm ## -l 移除容器间的网络连接，连接名为 db docker rm -l db ## -v 删除容器，并删除容器挂载的数据卷 docker rm -v redis3.7、生成镜像##基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停 docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID] myredis:v1.13.8、容器与主机间的数据拷贝##将rabbitmq容器中的文件copy至本地路径 docker cp rabbitmq:/[container_path] [local_path] ##将主机文件copy至rabbitmq容器 docker cp [local_path] rabbitmq:/[container_path]/ ##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别） docker cp [local_path] rabbitmq:/[container_path]]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue入门]]></title>
    <url>%2F2019%2F12%2F26%2Fvue-ru-men%2F</url>
    <content type="text"><![CDATA[vue入门&lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app">&amp;#123;&amp;#123; msg &amp;#125;&amp;#125;&lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"#app",//挂载点 data:&amp;#123; msg :"哈哈哈1" &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 挂载点（el:）作用： 挂载点的作用就是设置vue的作用范围，如果&#123;&#123;&#125;&#125;取值在选择器外部则原样显示，当然挂载点可以是id选择器，类选择器，还有class选择器，（开发中推荐使用id选择器） 特殊情况选择器不能作用到body标签和html标签以及单标签上 演示使用类选择器 &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app" class="class">&amp;#123;&amp;#123; msg &amp;#125;&amp;#125;&lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; //el:"#app",id选择器 //el:"div",标签选择器 el:".class", data:&amp;#123; msg :"哈哈哈1" &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 数据对象（data:）作用 vue中用到的数据定义在data中 data中可以写复杂类型的数据 &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;div>&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div> &lt;div>&amp;#123;&amp;#123;arr[0]&amp;#125;&amp;#125;&lt;/div> &lt;div>&amp;#123;&amp;#123;map.name&amp;#125;&amp;#125;&lt;/div> &lt;div>&amp;#123;&amp;#123;isTrue&amp;#125;&amp;#125;&lt;/div> &lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"哈哈哈1",//字符串类型 arr:["1","2","3","4"],//数组 map:&amp;#123;"name":"张珊"&amp;#125;,//map isTrue:true//布尔类型 &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 结果为 哈哈哈1 1 张珊 truev-text作用v-text指令的作用是设置标签的内容（textContext） 默认写法会替换全部内容，使用差值表达式&#123;&#123;&#125;&#125;可以替换指定内容 &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;div v-text="msg">&lt;/div> &lt;div>&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;差值表达式&lt;/div> &lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"哈哈哈1",//字符串类型 &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 结果 哈哈哈1 哈哈哈1差值表达式v-html和v-text区别:v-text会把元素内容替换为字符串，如果有特殊字符也会当做字符串， v-html会吧里面的标签解析出来 作用 v-html指令的作用是:设置元素的innerHTML 内容中有html结果会被解析为标签 v-text指令无论内容是什么，都会解析为文本 &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;div v-text="msg">&lt;/div> &lt;div v-html="msg">&lt;/div> &lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"&lt;a>哈哈哈&lt;/a>",//字符串类型 &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 结果： &lt;a&gt;哈哈哈&lt;/a&gt; 哈哈哈v-on作用: v-on指令的作用是：为元素绑定事件 指令可以简写为@ 绑定的方法必须在methods属性中 事件名不需要写on &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;button type="button" v-on:click="click(1)">v-on&lt;/button> &lt;button type="button" @click="click(1)">@&lt;/button> &lt;div>&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div> &lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"&lt;a>哈哈哈&lt;/a>",//字符串类型 &amp;#125;, methods:&amp;#123; click:function(num)&amp;#123; this.msg="被点击"+num; &amp;#125; &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 结果 v-on @ 被点击1v-show作用 v-show指令的作用是：根据真假切换元素的显示状态 原理是修改元素的display，实现显示和隐藏 指令后面的内容都会被解析为布尔值 &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;div v-show="isTrue">&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div> &lt;div v-show="isFalse">&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div> &lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"&lt;a>哈哈哈&lt;/a>",//字符串类型 isTrue:true, isFalse:false &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 结果 &lt;a&gt;哈哈哈&lt;/a&gt;v-if作用 v-if指令的作用是：根据表达式的真假切换元素的显示 本质是操作和移除dom元素 v-bind作用 属性绑定（因为标签内部不能使用差值表达式，所以要通过属性绑定的方式实现这个功能） &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;a v-bind:href="msg">去b站&lt;/a> &lt;a :href="msg">去b站&lt;/a> &lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"https://www.bilibili.com/",//字符串类型 &amp;#125; &amp;#125;) &lt;/script> &lt;/html> v-for作用 v-for根据数据生成列表结构 数组经常和v-for使用 语法是(item,index) in 数据 item和index可以结合其他指令一起使用 &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;ul> &lt;li v-for="item in arr">&amp;#123;&amp;#123;item&amp;#125;&amp;#125;&lt;/li> &lt;br /> &lt;li v-for="(item,index) in arr">&amp;#123;&amp;#123;index&amp;#125;&amp;#125;:&amp;#123;&amp;#123;item&amp;#125;&amp;#125;&lt;/li> &lt;br /> &lt;li v-for="(item,index) in arr">&amp;#123;&amp;#123;index+1&amp;#125;&amp;#125;:&amp;#123;&amp;#123;item&amp;#125;&amp;#125;&lt;/li> &lt;/ul> &lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"https://www.bilibili.com/",//字符串类型 arr:[1,2,3,4,5,6,7,8] &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 结果 1 2 3 4 5 6 7 8 0:1 1:2 2:3 3:4 4:5 5:6 6:7 7:8 1:1 2:2 3:3 4:4 5:5 6:6 7:7 8:8v-model（双向数据绑定，仅限表单）作用（也就是表单改变数据也改变，数据改变表单同时改变） v-model指令的作用是便捷的设置和获取表单元素的值 绑定的数据会和表单元素值想关联 &lt;!DOCTYPE html> &lt;html lang="zh"> &lt;head> &lt;meta charset="UTF-8"> &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"> &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"> &lt;title>Hello Vue&lt;/title> &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --> &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js">&lt;/script> &lt;/head> &lt;body> &lt;div id="app"> &lt;input type="text" v-model="msg" :placeholder="msg"> &lt;button type="button" v-on:click="click">v-on&lt;/button> msg结果:&lt;div>&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div> &lt;/div> &lt;/body> &lt;script> var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"哈哈哈",//字符串类型 &amp;#125;, methods:&amp;#123; click:function()&amp;#123; this.msg="被点击"; &amp;#125; &amp;#125; &amp;#125;) &lt;/script> &lt;/html> 结构 被点击 v-on msg结果: 被点击]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>前端</tag>
        <tag>习惯</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uni-app入门]]></title>
    <url>%2F2019%2F12%2F25%2Funi-app-ru-men%2F</url>
    <content type="text"><![CDATA[uni-app入门 有个老师想让我们做一款评分上传文件的软件，但是要求最好是安卓端，我也不会安卓，因为我是搞后台的，但是也搞过一点前端，于是乎我就学一点这个吧，也方便以后使用。 首先目录结构┌─components uni-app组件目录 │ └─comp-a.vue 可复用的a组件 ├─hybrid 存放本地网页的目录，详见 ├─platforms 存放各平台专用页面的目录，详见 ├─pages 业务页面文件存放的目录 │ ├─index │ │ └─index.vue index页面 │ └─list │ └─list.vue list页面 ├─static 存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此 ├─wxcomponents 存放小程序组件的目录 ├─main.js Vue初始化入口文件 ├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期 ├─manifest.json 配置应用名称、appid、logo、版本等打包信息 └─pages.json 配置页面路由、导航条、选项卡等页面类信息页面样式与布局uni-app 支持的通用 css 单位包括 px、rpx（也就说你全当小程序宽度就是750px,因为底层已经做好了适配） px 即屏幕像素 rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。以750宽的屏幕为基准，750rpx恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大。 vue页面支持普通H5单位，但在nvue里不支持： rem 默认根字体大小为 屏幕宽度/20（微信小程序、头条小程序、App、H5） vh viewpoint height，视窗高度，1vh等于视窗高度的1% vw viewpoint width，视窗宽度，1vw等于视窗宽度的1% nvue还不支持百分比单位。（nvue标准就可以让小程序拥有更高的性能） App端，在 pages.json 里的 titleNView 或页面里写的 plus api 中涉及的单位，只支持 px。注意此时不支持 rpx Vue文件解析.vue 文件是一个自定义的文件类型，用类 HTML 语法描述一个 Vue 组件。每个 .vue 文件包含三种类型的顶级语言块 &lt;template&gt;、&lt;script&gt; 和 &lt;style&gt;，还允许添加可选的自定义块： {{ msg }} export default { data () { return { msg: 'Hello world!' } } } .example { color: red; } This could be e.g. documentation for the component. vue-loader 会解析文件，提取每个语言块，如有必要会通过其它 loader 处理，最后将他们组装成一个 ES Module，它的默认导出是一个 Vue.js 组件选项的对象。 vue-loader 支持使用非默认语言，比如 CSS 预处理器，预编译的 HTML 模版语言，通过设置语言块的 lang 属性。例如，你可以像下面这样使用 Sass 语法编写样式： /* write Sass! */ 更多细节可以在使用预处理器中找到。 语言块模板 每个 .vue 文件最多包含一个 &lt;template&gt; 块。 内容将被提取并传递给 vue-template-compiler 为字符串，预处理为 JavaScript 渲染函数，并最终注入到从 &lt;script&gt; 导出的组件中。 脚本 每个 .vue 文件最多包含一个 &lt;script&gt; 块。 这个脚本会作为一个 ES Module 来执行。 它的默认导出应该是一个 Vue.js 的组件选项对象。也可以导出由 Vue.extend() 创建的扩展对象，但是普通对象是更好的选择。 任何匹配 .js 文件 (或通过它的 lang 特性指定的扩展名) 的 webpack 规则都将会运用到这个 &lt;script&gt; 块的内容中。 样式 默认匹配：/\.css$/。 一个 .vue 文件可以包含多个 &lt;style&gt; 标签。 标签可以有 scoped 或者 module 属性 (查看 scoped CSS和 CSS Modules) 以帮助你将样式封装到当前组件。具有不同封装模式的多个 标签可以在同一个组件中混合使用。 任何匹配 .css 文件 (或通过它的 lang 特性指定的扩展名) 的 webpack 规则都将会运用到这个 &lt;style&gt; 块的内容中。 自定义块可以在 .vue 文件中添加额外的自定义块来实现项目的特定需求，例如 &lt;docs&gt; 块。vue-loader 将会使用标签名来查找对应的 webpack loader 来应用在对应的块上。webpack loader 需要在 vue-loader 的选项 loaders 中指定。 更多细节，查看自定义块。 Src 导入如果喜欢把 .vue 文件分隔到多个文件中，你可以通过 src 属性导入外部文件： 需要注意的是 src 导入遵循和 webpack 模块请求相同的路径解析规则，这意味着： 相对路径需要以 ./ 开始 你可以从 NPM 依赖中导入资源： 在自定义块上同样支持 src 导入，例如： 注释在语言块中使用该语言块对应的注释语法 (HTML、CSS、JavaScript、Jade 等)。顶层注释使用 HTML 注释语法：&lt;!-- comment contents here --&gt;。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>前端</tag>
        <tag>习惯</tag>
        <tag>app</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡特兰数详解]]></title>
    <url>%2F2019%2F12%2F19%2Fqia-te-lan-shu-xiang-jie%2F</url>
    <content type="text"><![CDATA[卡特兰数1,1,2,5,14,42,132常见公式 问题一由 个“(”和 个“)”组成的字符串，要求左括号和右括号是匹配的，问一共有多少种合法的括号组合方式?解析:​ 加上现在有三对括号，我们吧这三对括号所有的情况排列下来 ​ $\color{red}()$()() 红色括号内没有括号 ​ $\color{red}()$(()) ​ $\color{red}($() $\color{red}{)}$() 红色括号内有一对括号 ​ $\color{red}($()()$\color{red}{)}$ 红色括号内有两对括号 ​ $\color{red}($(())$\color{red}{)}$ markdown染色太累了（╮(╯▽╰)╭） 到目前为止是不是发现有些规律呢？ 当n=3的时候假设f(n)就表示括号有三对的所有情况 ​ f(3)=f(0) * f(2)+f(1) * f(1)+f(2)*f(0) 上面这个公式和规律又有啥关系呢？我们可以这么想，第一个括号一定是左括号，那么第一个对括号一定是会出现，那么第一对括号之间可能出现一对括号或者到n-1对括号，为啥是n-1对呢，因为第一对括号已经确定了，所有里面最多只能有n-1对，所以说n对括号应该是: f(n)=f(0) * f(n-1)+…+f(n-1)*f(0)当然也有特殊情况，当n=0的时候答案应该是1,想一想为什么所有根据上面的公式我们写出代码 #include&lt;iostream> using namespace std; int sum[20];//存放卡特兰数结果等价于f(n) int f(int num)//计算num项的卡特兰数 { if(sum[num]!=-1) return sum[num]; else if(num==1) return 1; else if(num==0) return 1; else { int sum1=0; for(int i=0;i&lt;num;i++) { sum1+=f(i)*f(num-i-1); } return sum[num]=sum1; } } int main(void) { sum[0]=1; sum[1]=1; for(int i=0;i&lt;10;i++) sum[i]=-1; for(int i=1;i&lt;10;i++) { cout&lt;&lt;f(i)&lt;&lt;endl; } return 0; } 上面的代码固然能够计算卡特兰数，当然不能忘了文章开头写的几个公式来一个线性复杂度的卡特兰数 #include&lt;iostream> using namespace std; long long catalan[20]; int main(void) { int n; cin>>n; catalan[0]=1; for(int i=1;i&lt;=n;i++)//公式3求解 catalan[i]=(catalan[i-1]*(4*i-2))/(i+1); cout&lt;&lt;catalan[n]; } 其实上面这个代码的缺点也很明显，虽然速度很快，但是大多的卡特兰数体型的值都是比较大的，并且需要取模运算的，例如题型洛谷 P3200 栈所以接下来一个更通用的卡特兰数解法 #include&lt;iostream> using namespace std; int catalan[1000010];//注意卡特兰数数组的初始化结果为0 int main(void) { int n,p;//n为计算第几项卡特兰数，p是取模 cin>>n>>p; //初始化前两项 catalan[0] =1; catalan[1] =1; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;n;j++) catalan[i]=(catalan[j]*catalan[i-j-1]%p+catalan[i])%p; cout&lt;&lt;catalan[n]; return 0; } 其他类似题型问题一有2n个人排成一行进入剧场。入场费 5 元。其中只有 个人有一张 5 元钞票，另外n人只有 10 元钞票，剧院无其它钞票，问有多少中方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？ 问题分析首先这个问题也是2n类型的问题，然后就是一个5元的和一个10元的结合在一起就能满足类似括号问题，5元就是左括号，10元就是右括号，那么问题就转换成了求解卡特兰数问题。 问题二 n个不同的数依次进栈，求不同的出栈结果的种数 问题分析首先这个问题也是满足2n个问题的，因为题目进栈和出栈的次数是一样的所有也满足2n问题，同时也转换成了括号问题，也就变成了求解卡特兰数。 问题三 n个结点可够造多少个不同的二叉树？ 问题分析f(n)就表示n个节点二叉树构造的不同二叉树，那么当n=3的时候f(n)=f(0) * f(2)+f(1) * f(1)+f(2) * f(0),为什么会是这样呢，一个二叉树的所有情况应该是根节点左子树的所有情况乘以右子数的所有情况，并且左子数所有节点加右节点等于n-1，如果左子树有0个节点那么右子树就有2个节点，依次类推会发现就是括号问题。]]></content>
      <categories>
        <category>算法</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式session]]></title>
    <url>%2F2019%2F12%2F14%2Ffen-bu-shi-session%2F</url>
    <content type="text"><![CDATA[分布式session入门前言 我院大佬要安排一个项目，有一块要有人负责session这一块，于是乎没人想学，我就接下这个活了，希望自己能理解的不错吧。 session介绍session简介session是一次浏览器和服务器的交互会话，那会话又是什么呢，牛津词典的解释是进行某个活动连续的一段时间。 session作用session复制原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。 优点：如果其中一个服务器挂掉不会影响这个服务器集群。 缺点：如果用户访问量非常庞大，那么个个服务器之间进行session同步的次数会非常的多，以至于占用大量内网带宽 演示:1.复制多分tomcat 2.设置每个tomcat的server.xml来开启tomcat集群功能 3.在web.xml中添加信息：通知应用当前在集群环境中。 粘性session原理：粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。 优点：简单，不需要对session做任何处理。 缺点：缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的session信息都将失效。 适用场景：发生故障对客户产生的影响较小；服务器发生故障是低概率事件。]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>Spring</tag>
        <tag>SSM</tag>
        <tag>Mybatis</tag>
        <tag>习惯</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安阳师院软件学院报名系统使用流程]]></title>
    <url>%2F2019%2F11%2F27%2Fan-yang-shi-yuan-ruan-jian-xue-yuan-bao-ming-xi-tong-shi-yong-liu-cheng%2F</url>
    <content type="text"><![CDATA[安阳师院软件学院报名系统使用流程团队赛报名流程请大家使用谷歌浏览器或者国内的浏览器切换到极速模式在来打开本网站报名系统 前言 首先团队赛比赛有多个人参赛，该系统针对这类比赛提供团队比赛账号的注册，也就是说报名这类比赛必须先注册好个人账号，然后由团队账号邀请您加入该团队，之后进行报名。 第一步：注册属于您的个人账号1.进入登陆页面后点击创建账号,随后就能创建个人账号 学号和姓名必须要真实有效，否则影响您的获奖证书 电子邮箱可以用来找回密码 然后点击注册即可 第二步：如果您的队伍有团队账号请跳过这一步1.注册一个团队账号，在注册页面的上面有个团队账号点击即可 电子邮箱可以用来找回密码 第三步：登陆您团队账号1.登陆进去以后在导航栏找到管理我的团队 在邀请一栏中输入您队友的学号点击发送邀请即可，此时，该用户就会收到一个邀请信息，如果对方同意，那么在下面这一栏就会出现他的个人信息。 3.2个人账号同意加入队伍第一步登陆您的个人账号，点击导航栏的信封 第二步同意团队邀请 接下来在我加入的团队里面就能看见您当前加入的团队 第四步：报名比赛 团队比赛只能由团队账号报名 接下来点击导航栏的所有比赛找到您想参加的比赛点击报名即可如果没有邀请码可以直接确认跳过邀请码 如果没有邀请码点击确认即可 恭喜您成功报名个人赛报名流程第一步：您登陆您的个人账号 第二步：找到您要报名的比赛点击报名即可。]]></content>
      <categories>
        <category>软件学院</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>报名系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot入门环境搭建]]></title>
    <url>%2F2019%2F11%2F05%2Fspringboot-ru-men-huan-jing-da-jian%2F</url>
    <content type="text"><![CDATA[SpringBoot入门环境搭建技术栈Springboot,mybatis,logback 开始第一步，idea新建SpringBoot工程 第二部配置开发环境 application.yml logging: file: path: logger spring: profiles: active: dev mybatis: mapper-locations: classpath:mapping/*.xml application-dev-yml spring: #注意下面的username和password的写法，这两个是大坑 datasource: url: jdbc:mysql://localhost:3306/dirver username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver http: encoding: force: true charset: utf-8 enabled: true server: port: 8081 tomcat: uri-encoding: UTF-8 第三步，使用mybatis-Generator生成mapper和mapping 第四步，配置logback]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf入门教程]]></title>
    <url>%2F2019%2F11%2F01%2Fthymeleaf-ru-men-jiao-cheng%2F</url>
    <content type="text"><![CDATA[Thymeleaf入门教程前言 最近在学习SpringBoot框架，以前在写web项目的时候一直使用的是JSP页面模板语言，但是在SpringBoot中已经不推荐使用了。所有要使用新的模板语言了，整合SpringBoot推荐这个Thymeleaf模板语言，所有就学习这个模板引擎吧 SpringBoot支持的模板语言 Thymeleaf(SpringBoot框架推荐) FreeMarker Velocity Groovy JSP … 1.快速开始首先要想使用Thymeleaf要添加依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-thymeleaf&lt;/artifactId> &lt;/dependency> SpringBoot默认的存放模板页面的路径是src/main/resource/tempates或者src/main/view/templates 然后创建一个Controller对象，在其中进行参数传递 @Controller public class ThymeleafController { @RequestMapping(value = "show", method = RequestMethod.GET) public String show(Model model){ model.addAttribute("uid","123456789"); model.addAttribute("name","Jerry"); return "show"; } } 在SpringBoot默认页面下创建html文件(注意第二行的Thymeleaf的约束) &lt;!DOCTYPE HTML> &lt;html xmlns:th="http://www.thymeleaf.org"> &lt;head> &lt;title>SpringBoot模版渲染&lt;/title> &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/> &lt;/head> &lt;body> &lt;p th:text="'用户ID：' + ${uid}"/> &lt;p th:text="'用户名称：' + ${name}"/> &lt;/body> &lt;/html> 这样就会生成这样的html文件 &lt;!DOCTYPE HTML> &lt;html xmlns:th="http://www.thymeleaf.org"> &lt;head> &lt;title>SpringBoot模版渲染&lt;/title> &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/> &lt;/head> &lt;body> &lt;p>用户ID：123456789&lt;/p> &lt;p>用户名称：Jerry&lt;/p> &lt;/body> &lt;/html> 标准表达式 ${...} : 变量表达式。 *{...} : 选择表达式。 #{...} : 消息 (i18n) 表达式。 @{...} : 链接 (URL) 表达式。 ~{...} : 片段表达式。 变量表达式变量表达式是OGNL表达式 - 如果将Thymeleaf 与Spring - 集成在上下文变量上(也称为Spring术语中的模型属性)，则为Spring EL。 它们看起来像这样: ${person.name} 选择表达式选择表达式就像变量表达式一样，它们不是整个上下文变量映射上执行，而是在先前选择的对象。 它们看起来像这样: *{customer.name} 它们所作用的对象由th:object属性指定: &lt;div th:object="${book}"> ... &lt;span th:text="*{title}">...&lt;/span> ... &lt;/div> 所以这相当于: { // th:object="${book}" final Book selection = (Book) context.getVariable("book"); // th:text="*{title}" output(selection.getTitle()); } 消息(i18n)表达式消息表达式(通常称为文本外部化，国际化或i18n)允许从外部源(如:.properties)文件中检索特定于语言环境的消息，通过键来引用这引用消息。 在Spring应用程序中，它将自动与Spring的MessageSource机制集成。如下 - #{main.title} #{message.entrycreated(${entryId})} 以下是在模板中使用它们的方式: &lt;table> ... &lt;th th:text="#{header.address.city}">...&lt;/th> &lt;th th:text="#{header.address.country}">...&lt;/th> ... &lt;/table> 请注意，如果希望消息键由上下文变量的值确定，或者希望将变量指定为参数，则可以在消息表达式中使用变量表达式: #{${config.adminWelcomeKey}(${session.user.name})}]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot入门]]></title>
    <url>%2F2019%2F10%2F20%2Fspringboot-ru-men%2F</url>
    <content type="text"><![CDATA[springboot入门概述: 什么是springboot 它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。 它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架 使用springboot有什么好处回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要： 1）配置 web.xml，加载 spring 和 spring mvc 2）配置数据库连接、配置日志文件 3）配置家在配置文件的读取，开启注解 4）配置mapper文件 ….. 而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了… 划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。 快速入门 1.导入maven坐标&lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;/properties> &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>1.5.9.RELEASE&lt;/version> &lt;/parent> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.11&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;/dependencies> 2.新建springboot入口（其他包必须与此类在同级目录或者子包下 ）package com.qs304; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class SpringbootRunMain { public static void main(String[] args) { SpringApplication.run(SpringbootRunMain.class,args); } } 3.编写controllerpackage com.qs304.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.ResponseBody; @Controller public class HellpController { @RequestMapping("/hello") @ResponseBody public String helloWorld(){ return "HelloWorld"; } } 然后浏览器输入ip+项目名称就能访问了 默认生成的Spring Boot项目 主程序已经生成好了，我们只需要完成我们自己的逻辑 resources 文件夹中目录结构 static：保存所有的静态资源； js、css、images； templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot应用的配置文件；可以修改一些默认设置； Springboot研究 1.POM文件1.父项目（一般作为依赖管理） &lt;parent> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-parent&lt;/artifactId> &lt;version>1.5.9.RELEASE&lt;/version> &lt;/parent> 这个starter父项目还依赖了一个叫spring-boot-dependencies的父项目spring-boot-starter-parent(定义了每一个依赖的版本,管理springboot版本仲裁中心，定义了所有的依赖版本)&lt;properties> &lt;!-- Dependency versions --> &lt;activemq.version>5.14.5&lt;/activemq.version> &lt;antlr2.version>2.7.7&lt;/antlr2.version> &lt;appengine-sdk.version>1.9.59&lt;/appengine-sdk.version> &lt;artemis.version>1.5.5&lt;/artemis.version> &lt;aspectj.version>1.8.13&lt;/aspectj.version> &lt;assertj.version>2.6.0&lt;/assertj.version> &lt;atomikos.version>3.9.3&lt;/atomikos.version> &lt;bitronix.version>2.1.4&lt;/bitronix.version> &lt;caffeine.version>2.3.5&lt;/caffeine.version> &lt;cassandra-driver.version>3.1.4&lt;/cassandra-driver.version> &lt;classmate.version>1.3.4&lt;/classmate.version> &lt;commons-beanutils.version>1.9.3&lt;/commons-beanutils.version> &lt;commons-collections.version>3.2.2&lt;/commons-collections.version> &lt;commons-codec.version>1.10&lt;/commons-codec.version> &lt;commons-dbcp.version>1.4&lt;/commons-dbcp.version> &lt;commons-dbcp2.version>2.1.1&lt;/commons-dbcp2.version> &lt;commons-digester.version>2.1&lt;/commons-digester.version> &lt;commons-pool.version>1.6&lt;/commons-pool.version> ... &lt;/properties> 没有被定义的依赖还是需要我们手动进行版本的定义的 2.依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-web&lt;/artifactId> &lt;/dependency> spring-boot-starter-web：​ spring-boot-starter:是springboot的场景启动器，帮我们导入了web模块相关的依赖 也就是所还有很多其他的场景 springbot将所有的功能抽取出来，做成了一个个的starters（启动器）,只需要在项目里面引入这些相关场景，就能把需要的功能导入进来。 @SpringBootApplication: Spring Boot 应用标注在某个类上说明这个类似SpringBoot的主配置类,springBoot就是运行这个类的main方法来启动SpringBoot应用:@SpringBootApplication里面的注解 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class} ), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class} )} ) @ConfigurationPropertiesScan @SpringBootConfiguration:Spring Boot配置类标注在某个类上，表示这是一个SpringBoot的配置类: @SpringBootConfiguration:Spring里面的注解有 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Configuration( proxyBeanMethods = false ) Configuration：使用这个注解表示这个类是一个配置类（配置类也是一个组件）EnableAutoConfiguration：开启自动配置(以前手写SSM框架整合的时候需要我们手写配置，现在SpringBoot通过这个注解开启自动配置，这样自动配置才能生效)@EnableAutoConfiguration这个注解里面的注解有: @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @AutoConfigurationPackage @Import({AutoConfigurationImportSelector.class}) @AutoConfigurationPackage：自动配置包@AutoConfigurationPackage里面的注解 @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @Import({Registrar.class}) ​ @import：给容器导入组件 最后，由SpringBootApplication标注的类，的所在包和下面的子包里面所有组件扫描到Spring容器中; 配置文件SpringBoot默认会使用两个全局配置文件 application.properties application.yml或者application.yaml yaml和properties配置文件同时存在，properties配置文件的内容会覆盖yaml配置文件的内容 yml简介 YAML (YAML Aint Markup Language)是一种标记语言，通常以.yml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C/C++, Ruby, Python, Perl, C#, PHP等。 yml的优点 YAML易于人们阅读。 YAML数据在编程语言之间是可移植的。 YAML匹配敏捷语言的本机数据结构。 YAML具有一致的模型来支持通用工具。 YAML支持单程处理。 YAML具有表现力和可扩展性。 YAML易于实现和使用。 yml的语法1.约定 k: v表示键值对关系，（注意冒号后面必须有一个空格) 使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是一个层级的 大小写敏感 使用缩进时不允许使用tab键，只能使用空格 松散的表示，java中对于驼峰命名法，可以用原名或者使用-代替驼峰（bean的lastName属性，可以使用lastName或者last-name） 在yml语法中，空值可以使用null表示 键值对关系 字符串默认不用加单引号或者双引号 “”双引号；会转义字符串里面的特殊字符， ‘’单引号不会转义里面的字符 list数组类型行内写法使用[]，展开使用- map类型行内写法使用{}，展开使用k: v 日期使用 2019/01/01 文档块使用—-隔开，可以把不同的配置文件写入一个yml配置文件中 字面量：普通的值（数字，字符串，布尔 k: v 字符串默认不用加上单引号或者双引号； &quot;&quot;：双引号；会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 eg： name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi &#39;&#39;：单引号；不会转义特殊字符，特殊字符最终只是一个普通的字符串数据 eg： name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi 对象、Map（属性和值） k: v在下一行来写对象的属性和值的关系；注意缩进 person: name: 张三 gender: 男 age: 22Copy to clipboardErrorCopied 行内写法 person: {name: 张三,gender: 男,age: 22}Copy to clipboardErrorCopied 数组（List、Set） fruits: - 苹果 - 桃子 - 香蕉Copy to clipboardErrorCopied 行内写法 fruits: [苹果,桃子,香蕉]Copy to clipboardErrorCopied配置文件值注入 &lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-configuration-processor&lt;/artifactId> &lt;optional>true&lt;/optional> &lt;/dependency>Copy to clipboardErrorCopied 配置文件： person: name: 张三 gender: 男 age: 36 boss: true birth: 1982/10/1 maps: {k1: v1,k2: v2} lists: - apple - peach - banana pet: name: 小狗 age: 12 Copy to clipboardErrorCopied 测试 package cn.clboy.helloworldquickstart; import cn.clboy.helloworldquickstart.model.Person; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; @SpringBootTest class HelloworldquickstartApplicationTests { @Autowired private Person person; @Test void contextLoads() { System.out.println(person); } } Copy to clipboardErrorCopied properties 上面yaml对应的properties配置文件写法 person.name=李四 person.age=34 person.birth=1986/09/12 person.boss=true person.gender=女 person.lists=cat,dog,pig person.maps.k1=v1 person.maps.k2=v2 person.pet.name="小黑" person.pet.age=10 演示ren: #普通的int类型 id: 10 #String类型 name: 100 #list类型，里面是String类型 list: ["我是双引号我换行码？\n换行",'我是单引号我换行码?\n不换行'] #string类型,使用null string: null #运行结果: #Person{id=10, name='100', list=[我是双引号我换行码？ #换行, 我是单引号我换行码?\n不换行], string=''} @Value和@ConfigurationProperties注解的区别 @ConfigurationProperties @Value 功能 批量注入文件中的属性 一个一个指定 松散绑定（松散语法） 支持 不支持 spel 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 总结 @Value只能获取基本数据类型 @ConfigurationProperties可以获取map,list等封装类型的值 配置文件yaml和properties都可以获取到值 如果只是需要在业务逻辑中获取一下配置文件中的某个值，使用@Value 如果要是把javabean和配置文件进行11映射，使用@ConfigurationProperties @ConfigurationProperties默认是从全局配置文件中获取值的 @PropertySource @PropertySource注解的作用是加载指定的配置文件，值可以是数组，也就是可以加载多个配置文件 springboot默认加载的配置文件名是`application`，如果配置文件名不是这个是不会被容器加载的. @ImportResource 如果要想加载xml等配置文件需要使用该注解 注意！这个注解是放在主入口函数的类上. @PropertySource与@ImportResource的区别@PropertySource 用于引入*.Properties或者 .yml (yml不能直接支持)用于给javabean注入值@ImportResource 用于引入.xml 类型的配置文件 在spring boot中已经被配置类替代@PropertySource 一般用在javabean的类名上@ImportResource一般用于启动类上 PropertySource自定义配置文件，多用于配置文件与实体属性映射 在从配置文件里面获取值，与javaBean做映射时存在一个问题，我们从主配置文件（application.yml）里面读取会导致主配置文件特别臃肿，为了按照不同模块自定义不同的配置文件引入了@PropertySource 演示： person.properties person.lastName=李四 person.age=25 person.birth=2017/12/15 person.boss=true person.maps.key1=value1 person.maps.key2=value2 person.lists=a,b,c person.dog.name=dog person.dog.age=2 javabean @PropertySource(value = {"classpath:person.properties"})//通过类路径修改默认配置文件 @ConfigurationProperties(prefix = "person")//加载配置文件 @Component public class Person { private String lastName; private Integer age; private boolean isBoss; private Date birth; @ImplementResources 一般情况下我们自定义的xml配置文件默认情况下这个bean是不会加载到Spring容器中来的，于是乎我们需要@ImportResoure注解将这个配置文件加载进来 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;bean id="helloService" class="com.chentongwei.springboot.service.HelloService">&lt;/bean> &lt;/beans> 总结： @PropertySource 用于引入.Properties或者 *.yml 用于给javabean注入值 @ImportResource 用于引入.xml 类型的配置文件 在spring boot中已经被配置类替代 @PropertySource 一般用在javabean的类名上 @ImportResource一般用于启动类上 SpringBoot配置文件占位符前言: 在springboot的配置文件中，我们可以使用springboot提供的一些随机数或者使用我们在配置文件中定义的值 随机数person.properties person.lastName=${person.properties} person.age=25 person.birth=2017/12/15 person.boss=true person.maps.key1=${random.int[1024,65536]} person.maps.key2=value2 person.lists=a,b,c person.dog.name=dog person.dog.age=2 ${random.value} - 类似uuid的随机数，没有”-“连接 ${random.int} - 随机取整型范围内的一个值 ${random.long} - 随机取长整型范围内的一个值 ${random.long(100,200)} - 随机生成长整型100-200范围内的一个值 ${random.uuid} - 生成一个uuid，有短杠连接 ${random.int(10)} - 随机生成一个10以内的数 ${random.int(100,200)} - 随机生成一个100-200 范围以内的数 占位符person.properties person.lastName=${person.properties}#引用person.properties的值 SpringBoot配置Profile多环境支持1.多Profile文件​ 我们在主配置文件编写的时候，文件名可以是 application-{profile}.yml或者application-{profile}.properties ,都行，以下用yml为主。以下主配置文件表示 application.yml 编写一个名为 application-dev.yml文件： server: port: 8081 #编写一个名为application-prod.yml文件： server: port: 8082 先启动springboot项目，发现启动的端口为 81(application.yml中指定的端口为 81) ，也就是说默认启动的是application.yml的环境。 2.yml多文档块支持配置文件中也支持使用多文档块的方式创建多环境，是用 — (三个-)表示一个文档块 ，如果不指定启动别的文档块，默认启动第一个文档块，可以通过 spring.profiles.actice=dev 来指定启动别的文档块。 server: port: 8081 spring: profiles: #指定启动的环境 active: dev --- server: port: 8083 spring: profiles: dev --- server: port: 8084 spring: profiles: prod 这样启动的时候就会使用dev这个环境 3.使用命令指定环境在idea里面有一个run configurations中指定参数 –spring.profiles.active=dev也可以指定环境 SpringBoot静态资源目录1、classpath 类目录 (src/mian/resource)classpath 即 WEB-INF 下面的 classes 目录 ，在 SpringBoot 项目中是 src/main/resource 目录。 2、ServletContext 根目录下( src/main/webapp )一、SpringBoot 访问web中的静态资源SpringBoot默认指定了一些固定的目录结构，静态资源放到这些目录中的某一个，系统运行后浏览器就可以访问到 1、SpringBoot 默认指定的可以存放静态资源的目录有哪些？ classpath:/META-INF/resources/ 需创建/META-INF/resources/ 目录 classpath:/resources/ 需创建/resources/目录 classpath:/static/ 工具自动生成的static目录，也是用的最多的目录 classpath:/public/ 需创建/public/ 目录 src/main/webapp/ 需创建/webapp/ 目录 这些目录下的文件可以直接访问不需要在url上面添加文件名 3、SpringBoot 默认的首页是放在任一个静态资源目录下的index.html 4、SpringBoot 默认的web页面图标是放在任一静态资源目录下的favicon.ico 配置文件加载顺序 外部配置加载顺序SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 命令行参数 所有的配置都可以在命令行上进行指定 java -jar xxx.jar --server.port=8087 --server.context-path=/abcCopy to clipboardErrorCopied 多个配置用空格分开； –配置项=值 来自java:comp/env的JNDI属性 Java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 由jar包外向jar包内进行寻找； 再来加载不带profile jar包外部的application.properties或application.yml(不带spring.profile)配置文件 **jar包内部的application.properties或application.yml(不带spring.profile)配置文件 优先加载带profile **jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件 ⤴️ **jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件 @Configuration注解类上的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 自动配置原理SpringBoot启动的时候加载主配置类，开启了自动配置功能 @SpringBootApplication @EnableAutoConfiguration @EnableAutoConfiguration 利用EnableAutoConfigurationImportSelector给容器中导入一些组件 getAutoConfigurationEntry方法中 //获取候选的配置 List&lt;String> configurations = getCandidateConfigurations(annotationMetadata,attributes) getCandidateConfigurations方法中，SpringFactoriesLoader.loadFactoryNames()，扫描所有jar包类路径下 META-INF/spring.factories，把扫描到的这些文件的内容包装成properties对象，从properties中获取到EnableAutoConfiguration.class（类名）对应的值，然后把它们添加在容器中 每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 每一个自动配置类进行自动配置功能； 演示自动配置以HttpEncodingAutoConfiguration为例package org.springframework.boot.autoconfigure.web.servlet; ...... //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件 @Configuration( proxyBeanMethods = false ) /** * 启动指定类的ConfigurationProperties功能； * 将配置文件中对应的值和HttpProperties绑定起来； * 并把HttpProperties加入到ioc容器中 */ @EnableConfigurationProperties({HttpProperties.class}) /** * Spring底层@Conditional注解 * 根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； * 判断当前应用是否是web应用，如果是，当前配置类生效 */ @ConditionalOnWebApplication( type = Type.SERVLET ) //判断当前项目有没有这个类 @ConditionalOnClass({CharacterEncodingFilter.class}) /** * 判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的 * 即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； */ @ConditionalOnProperty( prefix = "spring.http.encoding", value = {"enabled"}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { //它已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } @Bean //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @ConditionalOnMissingBean //判断容器有没有这个组件？（容器中没有才会添加这个组件） public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; } ...... 总结 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类 再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） 给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值 xxxxAutoConfigurartion：自动配置类； xxxxProperties:封装配置文件中相关属性； @Conditional派生注解作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean； @ConditionalOnMissingBean 容器中不存在指定Bean； @ConditionalOnExpression 满足SpEL表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean，或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 如何查看哪些配置类生效了自动配置类必须在一定的条件下才能生效； 我们怎么知道哪些自动配置类生效了； 我们可以通过配置文件启用 debug=true属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效； Positive matches ：（自动配置类启用的） Negative matches：（没有启动，没有匹配成功的自动配置类）]]></content>
  </entry>
  <entry>
    <title><![CDATA[pageHelper入门]]></title>
    <url>%2F2019%2F10%2F20%2Fpagehelper-ru-men%2F</url>
    <content type="text"><![CDATA[pageHelper入门前言 之前写web网页的时候使用的是SQL语句中的limit进行分页，无意间发现这种分页写法特别傻屌（╮(╯▽╰)╭），假如你每页有100条数据，你要查询第100页的数据，那么这个SQL语句做的事情就是获取前100100大概这个范围的数据，然后把前100000条数据丢弃，这样是非常浪费性能的，所有我就学习了pageHelper这个分页插件 快速入门步骤 1.使用maven导入依赖 &lt;dependency> &lt;groupId>com.github.pagehelper&lt;/groupId> &lt;artifactId>pagehelper&lt;/artifactId> &lt;version>5.1.2&lt;/version> &lt;/dependency> 2.在配置文件中配置拦截器插件 第一种：使用spring的属性配置 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"> &lt;!-- 注意其他配置 --> &lt;property name="plugins"> &lt;array> &lt;bean class="com.github.pagehelper.PageInterceptor"> &lt;property name="properties"> &lt;!--使用下面的方式配置参数，一行配置一个 --> &lt;value> params=value1 &lt;/value> &lt;/property> &lt;/bean> &lt;/array> &lt;/property> &lt;/bean> 第二种使用mybatis配置 &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"> &lt;!-- 注意其他配置 --> &lt;property name="plugins"> &lt;array> &lt;bean class="com.github.pagehelper.PageInterceptor"> &lt;property name="properties"> &lt;!--使用下面的方式配置参数，一行配置一个 --> &lt;value> params=value1 &lt;/value> &lt;/property> &lt;/bean> &lt;/array> &lt;/property> &lt;/bean> 3.编写需要分页的controller //获取第1页，10条内容，默认查询总数count PageHelper.startPage(1, 10); List&lt;Country> list = countryMapper.selectAll(); //用PageInfo对结果进行包装 PageInfo page = new PageInfo(list); //测试PageInfo全部属性 //PageInfo包含了非常全面的分页属性 assertEquals(1, page.getPageNum()); assertEquals(10, page.getPageSize()); assertEquals(1, page.getStartRow()); assertEquals(10, page.getEndRow()); assertEquals(183, page.getTotal()); assertEquals(19, page.getPages()); assertEquals(1, page.getFirstPage()); assertEquals(8, page.getLastPage()); assertEquals(true, page.isFirstPage()); assertEquals(false, page.isLastPage()); assertEquals(false, page.isHasPreviousPage()); assertEquals(true, page.isHasNextPage()); 导航栏演示 &lt;div class="row"> &lt;div class="col-md-6">当前是第${pageInfo.pageNum},页一共有${pageInfo.pages}页,共有${pageInfo.total}条数据&lt;/div> &lt;div class="col-md-6"> &lt;nav aria-label="Page navigation"> &lt;ul class="pagination"> &lt;c:if test="${pageInfo.pageNum!=1}"> &lt;li> &lt;a href="${pageContext.request.contextPath}/?pn=${pageInfo.prePage}" aria-label="Previous"> &lt;span aria-hidden="true">&amp;laquo;&lt;/span> &lt;/a> &lt;/li> &lt;/c:if> &lt;li class="${pageInfo.pageNum==1?"disabled":""}">&lt;a href="${pageContext.request.contextPath}/?pn=${pageInfo.firstPage}">首页&lt;/a>&lt;/li> &lt;c:forEach items="${pageInfo.navigatepageNums}" var="pageNum"> &lt;li class="${pageInfo.pageNum==pageNum?"disabled":""}">&lt;a href="${pageContext.request.contextPath}/?pn=${pageNum}">${pageNum}&lt;/a>&lt;/li> &lt;/c:forEach> &lt;li class="${pageInfo.pageNum==pageInfo.pages?"disabled":""}">&lt;a href="${pageContext.request.contextPath}/?pn=${pageInfo.lastPage}">末页&lt;/a>&lt;/li> &lt;c:if test="${pageInfo.pageNum!=pageInfo.navigateLastPage}"> &lt;li> &lt;a href="${pageContext.request.contextPath}/?pn=${pageInfo.nextPage}#" aria-label="Next"> &lt;span aria-hidden="true">&amp;raquo;&lt;/span> &lt;/a> &lt;/li> &lt;/c:if> &lt;/ul> &lt;/nav> &lt;/div> &lt;/div> 参数介绍 3. 分页插件参数介绍分页插件提供了多个可选参数，这些参数使用时，按照上面两种配置方式中的示例配置即可。 分页插件可选参数如下： dialect：默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 下面几个参数都是针对默认 dialect 情况下的参数。使用自定义 dialect 实现时，下面的参数没有任何作用。 helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页。你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 重要提示： 当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 pageHelper属性//当前页 private int pageNum; //每页的数量 private int pageSize; //当前页的数量 private int size; //由于startRow 和endRow 不常用，这里说个具体的用法 //可以在页面中"显示startRow 到endRow 共size 条数据" //当前页面第一个元素在数据库中的行号 private int startRow; //当前页面最后一个元素在数据库中的行号 private int endRow; //总记录数 private long total; //总页数 private int pages; //结果集 private List&lt;T> list; //前一页 private int prePage; //下一页 private int nextPage; //是否为第一页 private boolean isFirstPage = false; //是否为最后一页 private boolean isLastPage = false; //是否有前一页 private boolean hasPreviousPage = false; //是否有下一页 private boolean hasNextPage = false; //导航页码数 private int navigatePages; //所有导航页号 private int[] navigatepageNums; //导航条上的第一页 private int navigateFirstPage; //导航条上的最后一页 private int navigateLastPage;]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>分页</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery入门教程]]></title>
    <url>%2F2019%2F10%2F17%2Fjquery-ru-men-jiao-cheng%2F</url>
    <content type="text"><![CDATA[jQuery入门教程 jQuery就是一个js库，它极大地简化了js的编程，因此jQuery也很容易学习和使用。 入门演示这个隐藏了body标签下div这个长200px和宽200px粉色的盒子，并且打印一行话 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class="css">&lt;/div> &lt;script> $(function(){ $("div").hide(); alert("asfda"); }); &lt;/script> &lt;/body> &lt;/html> jQuery顶级对象$ $是jQuery的一个别称，在代码中可以使用$符号代替jQuery，通常目的都是为了简化操作。 $是jQuery的顶级对象，相当于原生javaScript中的window 演示&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class="css">&lt;/div> &lt;script> $(function(){ $("div").hide(); alert("asfda"); }); //下面的和上面的效果完全一致 jQuery(function(){ jQuery("div").hide(); alert("asfda"); }); &lt;/script> &lt;/body> &lt;/html> jQuery对象和DOM对象 使用原生js获取的对象就是DOM对象 使用JQuery中的$获取的对象就是jQuery对象 他们之间可以相互转化，但是不相互转化之前不能使用对方的属性和方法 演示&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class="css">&lt;/div> &lt;script> $(function(){ //获取原生的DOM对象 console.dir(document.querySelector('div')); //获取jQuery对象 console.dir($('div')); }) &lt;/script> &lt;/body> &lt;/html> jQuery和DOM对象相互转化DOM对象转化为JQuery对象 $(&lt;DOM对象>) jQuery对象转化DOM对象 $(&lt;jQuer对象>)[&lt;index>]//下标访问的方式 $(&lt;jQuer对象>).get(&lt;index>) 演示&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class="css">&lt;/div> &lt;script> $(function(){ //1.获取原生的DOM对象 var DOMClass=document.querySelector('div'); //转化jQuery对象 var parseJquery=$(DOMClass); //2.获取jQuery对象 var jQueryClass=$('div'); //转化为DOM对象,因为这个代码里面只有一个div所有通过下标访问0下标就可以得到 var parseDOM=jQueryClass[0]; }) &lt;/script> &lt;/body> &lt;/html> jQuery选择器1.基础选择器 名称 用法 描述 ID选择器 $(“#id”) 获取指定的ID元素 全选选择器 $(“*”) 获取所有元素 类选择器 $(“.class”) 获取同一类class的元素 标签选择器 $(“div”) 获取同一标签的所有元素 并集选择器 $(“div,p,li”) 获取多个元素 交集选择器 $(“li,current”) 交集选择器 演示&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class="css">&lt;/div> &lt;script> $(function(){ //通过类选择器获取类为css的div盒子 console.dir($(".css")); }) &lt;/script> &lt;/body> &lt;/html> jQuery隐式迭代 在jQuery中会对jQuery对象进行隐式迭代 也就是说jQuery会对获取到的所有对象迭代执行相同的操作，这样可以极大的简化我们编写的代码 演示&lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; border: 1px solid red; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class="css">1&lt;/div> &lt;div class="css">2&lt;/div> &lt;div class="css">3&lt;/div> &lt;div class="css">4&lt;/div> &lt;script> $(function(){ //利用jQuery的隐式迭代修改全部div的背景颜色 $('div').css("background-color","blue"); }) &lt;/script> &lt;/body> &lt;/html> jQuery筛选选择器 可以在获取的jQuery对象伪数组中筛选 语法 用法 描述 :first $(“li:first”) 获取li后面第一个li元素 :last $(“li:last”) 获取li伪数组中的最后一个元素 :eq(&lt; index &gt;) $(“li:eq(2)”) 获取li伪数组中的2下标元素 :odd $(“li:odd”) 获取到li元素中,选择索引号为奇数的元素 :even $(“li:even”) 获取到li元素中,选择索引号为偶数的元素 演示修改指定位置div的颜色 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; border: 1px solid red; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class="css">1&lt;/div> &lt;div class="css">2&lt;/div> &lt;div class="css">3&lt;/div> &lt;div class="css">4&lt;/div> &lt;script> $(function(){ //利用jQuery的隐式迭代修改全部div的背景颜色 $('div:eq(2)').css("background-color","blue"); }) &lt;/script> &lt;/body> &lt;/html> jQuery筛选方法 语法 用法 说明 parent() $(“li”).parent() 查找li的父亲节点 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，最近一级的（亲儿子） find(selector) $(“ul”).find(“li”) 相当于$(“ul li”)，后代选择器 siblings(selector) $(“.first”).siblings(‘li’) 查找兄弟节点不包括本身 nextAll([expr]) $(“.first”).nextAll() 查找当前元素之后所有同辈元素 prevtAll([expr]) $(“.last”).prevAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(‘div’).hasClass（”protected”) 检查当前的元素是否有包含特定的类，如果有返回true eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”) 演示让2下标的div盒子后面的div盒子变色 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; border: 1px solid red; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;div class="css">1&lt;/div> &lt;div class="css">2&lt;/div> &lt;div class="css">3&lt;/div> &lt;div class="css">4&lt;/div> &lt;script> $(function(){ //利用jQuery的隐式迭代修改全部div的背景颜色 $('div:eq(2)').nextAll().css("background-color","blue"); }) &lt;/script> &lt;/body> &lt;/html> jQuery排他思想 所谓排他是想也就是实现多选一的效果，设置当前元素的样式，清除兄弟元素的样式 核心函数就是$(“button”).siblings(“button”); 演示点击按钮变色，其余按钮清除原来颜色 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; border: 1px solid red; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;script> $(function(){ //隐式迭代 $("button").click(function(event) { //当前元素添加效果 $(this).css("background","blue"); //清除兄弟节点的效果 $(this).siblings('button').css("background",""); }); }) &lt;/script> &lt;/body> &lt;/html> jQuery链式编程 实际上链式操作仅仅是通过对象上的方法最后 return this 把对象再返回回来，对象当然可以继续调用方法啦，所以就可以链式操作了 演示将上面那个按钮排他变色案例改编 &lt;!DOCTYPE html> &lt;html lang="en"> &lt;head> &lt;meta charset="UTF-8"> &lt;title>Document&lt;/title> &lt;script src="jquery.min.js">&lt;/script> &lt;style> div{ height: 200px; width: 200px; border: 1px solid red; background-color: red; } &lt;/style> &lt;/head> &lt;body> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;button>哈哈哈&lt;/button> &lt;script> $(function(){ //隐式迭代 $("button").click(function(event) { //链式编程 $(this).css("background","blue").siblings('button').css("background",""); }); }) &lt;/script> &lt;/body> &lt;/html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>jQuery</tag>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis逆向工程--MybatisGenerator]]></title>
    <url>%2F2019%2F10%2F14%2Fmybatis-ni-xiang-gong-cheng-mybatisgenerator%2F</url>
    <content type="text"><![CDATA[Mybatis逆向工程 mybatis需要手动编写mapper和接口，以及pojo对象，这对于一个大型工程来说特别消耗时间，所有也就有了自动生成的工具就是MybatisGenerator 使用步骤1.导入maven坐标 &lt;dependency> &lt;groupId>org.mybatis.generator&lt;/groupId> &lt;artifactId>mybatis-generator-core&lt;/artifactId> &lt;version>1.3.5&lt;/version> &lt;/dependency> 2.配置Generator配置文件 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"> &lt;generatorConfiguration> &lt;!-- 配置数据库连接--> &lt;context id="DB2Tables" targetRuntime="MyBatis3"> &lt;commentGenerator> &lt;property name="suppressDate" value="true"/> &lt;property name="suppressAllComments" value="true"/> &lt;/commentGenerator> &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/dirver" userId="root" password="123456"> &lt;/jdbcConnection> &lt;!-- java类型解析不需要动--> &lt;javaTypeResolver > &lt;property name="forceBigDecimals" value="false" /> &lt;/javaTypeResolver> &lt;!-- 指定javabean生成位置--> &lt;javaModelGenerator targetPackage="com.qs304.skydrive.entity" targetProject=".\src\main\java"> &lt;property name="enableSubPackages" value="true" /> &lt;property name="trimStrings" value="true" /> &lt;/javaModelGenerator> &lt;!-- 映射文件生成位置--> &lt;sqlMapGenerator targetPackage="mapper" targetProject=".\src\main\resources"> &lt;property name="enableSubPackages" value="true" /> &lt;/sqlMapGenerator> &lt;!-- 指定dao接口生成位置--> &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.qs304.skydrive.mapper" targetProject=".\src\main\java"> &lt;property name="enableSubPackages" value="true" /> &lt;/javaClientGenerator> &lt;!-- 指定每个表的生成策略--> &lt;table tableName="user" domainObjectName="User"/> &lt;/context> &lt;/generatorConfiguration> 3.然后新建一个java文件读取配置文件开始自动生成pojo对象和接口文件和mybatis配置文件 import org.junit.Test; import org.mybatis.generator.api.MyBatisGenerator; import org.mybatis.generator.config.Configuration; import org.mybatis.generator.config.xml.ConfigurationParser; import org.mybatis.generator.exception.InvalidConfigurationException; import org.mybatis.generator.exception.XMLParserException; import org.mybatis.generator.internal.DefaultShellCallback; import java.io.File; import java.io.IOException; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class Generator { @Test public void mybatisGenerator() throws InterruptedException, SQLException, IOException, XMLParserException, InvalidConfigurationException { List&lt;String> warnings = new ArrayList&lt;String>(); boolean overwrite = true; File configFile = new File("D:\\code\\SSMCRUD\\src\\test\\mybatisGenerator.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); } }]]></content>
      <categories>
        <category>数据库</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速搭建java项目配置文件模板]]></title>
    <url>%2F2019%2F10%2F10%2Fkuai-su-da-jian-java-xiang-mu-pei-zhi-wen-jian-mo-ban%2F</url>
    <content type="text"><![CDATA[web.xml(包含Spring和SpringMVC)&lt;?xml version="1.0" encoding="UTF-8"?> &lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"> &lt;!-- 中文乱码处理 --> &lt;filter> &lt;filter-name>CharacterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;init-param> &lt;param-name>forceEncoding&lt;/param-name> &lt;param-value>true&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>CharacterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;filter> &lt;filter-name>HiddenHttpMethodFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class> &lt;/filter> &lt;filter-mapping> &lt;filter-name>HiddenHttpMethodFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;!-- Spring配置文件信息 --> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:config/spring/applicationContext.xml&lt;/param-value> &lt;/context-param> &lt;!-- ContextLoaderListener监听器 --> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;!-- 日志配置 --> &lt;context-param> &lt;param-name>log4jConfigLocation&lt;/param-name> &lt;param-value>classpath:config/log4j.properties&lt;/param-value> &lt;/context-param> &lt;listener> &lt;listener-class>org.springframework.web.util.Log4jConfigListener&lt;/listener-class> &lt;/listener> &lt;!-- 配置前端控制器 --> &lt;servlet> &lt;servlet-name>DispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:config/springmvc/springmvc.xml&lt;/param-value> &lt;/init-param> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>DispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;error-page> &lt;error-code>404&lt;/error-code> &lt;location>/WEB-INF/errors/404.jsp&lt;/location> &lt;/error-page> &lt;error-page> &lt;error-code>500&lt;/error-code> &lt;location>/WEB-INF/errors/500.jsp&lt;/location> &lt;/error-page> &lt;welcome-file-list> &lt;welcome-file>index.jsp&lt;/welcome-file> &lt;/welcome-file-list> &lt;/web-app> applicationContext.xml(含C3P0配置和mybatis配置文件整合)&lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"> &lt;!-- 配置扫描范围--> &lt;context:component-scan base-package="com.qs304"> &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/> &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Component"/> &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/> &lt;/context:component-scan> &lt;!--加载数据源配置文件--> &lt;context:property-placeholder location="classpath:config/db.properties"/> &lt;!-- 配置C3P0数据源--> &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close" > &lt;property name="driverClass" value="${jdbc.driver">&lt;/property> &lt;property name="jdbcUrl" value="${jdbc.url">&lt;/property> &lt;property name="user" value="${jdbc.username">&lt;/property> &lt;property name="password" value="${jdbc.password">&lt;/property> &lt;/bean> &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"> &lt;property name="dataSource" ref="dataSource">&lt;/property> &lt;!-- 扫描 po 包，使用别名 --> &lt;property name="typeAliases" value="com.qs304.entity">&lt;/property> &lt;!-- 扫描映射文件 --> &lt;property name="mapperLocations" value="classpath:config/mapper/*.xml">&lt;/property> &lt;/bean> &lt;!-- 配置扫描 dao 包，动态实现 dao 接口，注入到 spring 容器中 --> &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"> &lt;property name="basePackage" value="com.ischoolbar.programmer.dao" /> &lt;/bean> &lt;!-- 事务管理器 （JDBC） --> &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"> &lt;property name="dataSource" ref="dataSource">&lt;/property> &lt;/bean> &lt;aop:config> &lt;!-- 切入点表达式--> &lt;aop:pointcut id="txPointcut" expression="execution(* com.qs304.servlet..*(..))"/> &lt;!-- 配置事务增强--> &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/> &lt;/aop:config> &lt;!-- 配置事务增强事务如何切入--> &lt;tx:advice id="txAdvice"> &lt;tx:attributes> &lt;!-- 所有的方法都是事务方法--> &lt;tx:method name="*"/> &lt;!-- get开头的方法认为是查询进行调优--> &lt;tx:method name="get*" read-only="true"/> &lt;/tx:attributes> &lt;/tx:advice> &lt;!-- 启动声明式事务驱动 --> &lt;tx:annotation-driven transaction-manager="transactionManager" /> &lt;/beans> springmvc.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd"> &lt;!-- 只需要扫描包中的 Controller 注解 --> &lt;context:component-scan base-package="com.ischoolbar.programmer.controller"> &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /> &lt;/context:component-scan> &lt;!-- 启动 mvc 注解驱动 --> &lt;mvc:annotation-driven>&lt;/mvc:annotation-driven> &lt;!-- 启动定时任务 --> &lt;task:annotation-driven/> &lt;!-- 静态资源处理 --> &lt;mvc:default-servlet-handler/> &lt;!-- 配置视图解析器 --> &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"> &lt;property name="prefix" value="/WEB-INF/views/">&lt;/property> &lt;property name="suffix" value=".jsp">&lt;/property> &lt;/bean> &lt;!-- 文件上传 --> &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"> &lt;!-- 上传文件大小限制 --> &lt;property name="maxUploadSize"> &lt;value>10485760&lt;/value> &lt;/property> &lt;!-- 请求的编码格式, 和 jsp 页面一致 --> &lt;property name="defaultEncoding"> &lt;value>UTF-8&lt;/value> &lt;/property> &lt;/bean> &lt;!-- 后台访问拦截器 --> &lt;mvc:interceptors> &lt;mvc:interceptor> &lt;mvc:mapping path="/**"/> &lt;!--&lt;mvc:mapping path="/grade/*"/>--> &lt;mvc:exclude-mapping path="/system/login"/> &lt;mvc:exclude-mapping path="/system/get_cpacha"/> &lt;mvc:exclude-mapping path="/h-ui/**"/> &lt;mvc:exclude-mapping path="/easyui/**"/> &lt;mvc:exclude-mapping path="/home-resources/**"/> &lt;mvc:exclude-mapping path="/home/**"/> &lt;bean class="com.ischoolbar.programmer.interceptor.LoginInterceptor">&lt;/bean> &lt;/mvc:interceptor> &lt;/mvc:interceptors> &lt;/beans>]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合教程和步骤]]></title>
    <url>%2F2019%2F10%2F02%2Fssm-zheng-he-jiao-cheng-he-bu-zou%2F</url>
    <content type="text"><![CDATA[SSM整合教程和步骤步骤1.配置spring和springmvc以及mybatis配置文件 2.配置web.xml文件先整合spring与springmvc 3.测试spring与springmvc整合情况 4.整合spring与springmvc与mybatis 教程1.配置spring和springmvc以及mybatis配置文件spring.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> &lt;!--开启注解扫描但是不扫描Controller注解包含的类--> &lt;context:component-scan base-package="com.qs304"> &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/> &lt;/context:component-scan> &lt;/beans> springmvc.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> &lt;!--开启注解扫描但是只扫描Controller注解包含的类--> &lt;context:component-scan base-package="com.qs304.controller"> &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/> &lt;/context:component-scan> &lt;!--因为一会要使用注解，所有开启注解扫描,注解只扫描Controller--> &lt;!--配置视图解析器--> &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"> &lt;property name="prefix" value="/WEB-INF/pages/">&lt;/property> &lt;property name="suffix" value=".jsp">&lt;/property> &lt;/bean> &lt;/beans> 2.配置web.xml文件先整合spring与springmvc web.xml &lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" > &lt;web-app> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!--配置前端控制器--> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc.xml&lt;/param-value> &lt;/init-param> &lt;/servlet> &lt;!--配置监听器加载spring框架--> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener> &lt;!--配置springxml文档路径--> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:spring.xml&lt;/param-value> &lt;/context-param> &lt;!-- 解决中文乱码--> &lt;filter> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;filter-class>org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class> &lt;init-param> &lt;param-name>encoding&lt;/param-name> &lt;param-value>UTF-8&lt;/param-value> &lt;/init-param> &lt;/filter> &lt;filter-mapping> &lt;filter-name>characterEncodingFilter&lt;/filter-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/filter-mapping> &lt;!-- 前端控制器映射拦截说有路径下 &lt;url-pattern>/&lt;url-pattern/>匹配类似于/xxxx的URL，不会匹配到/xxx.xxx类型的URL &lt;url-pattern>/*&lt;url-pattern/>会匹配所有类型、所有后缀的URL，包括：/xxx、/xxx.xxx --> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 3.测试springmvc与spring整合情况4.整合spring与springmvc与mybatis首先单独写mybatis配置文件，例如名字叫做mybatis.xml mybatis.xml 然后测试mybatis能运行 之后吧mybatis配置文件整合到spring.xml配置文件中 spring.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> &lt;context:component-scan base-package="com.qs304"> &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/> &lt;/context:component-scan> &lt;!-- Spring整合mybatis框架--> &lt;!-- 配置连接池--> &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"> &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/> &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/demo"/> &lt;property name="user" value="root"/> &lt;property name="password" value="111"/> &lt;/bean> &lt;!-- 工厂注入来配置sqlsession--> &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"> &lt;property name="dataSource" ref="dataSource"/> &lt;/bean> &lt;!-- 配置接口所在的包--> &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"> &lt;property name="basePackage" value="com.qs304.dao"/> &lt;/bean> &lt;/beans> 之后就运行成功啦，完结散花、]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis深入理解XML配置文件]]></title>
    <url>%2F2019%2F09%2F28%2Fmybatis-shen-ru-li-jie-xml-pei-zhi-wen-jian%2F</url>
    <content type="text"><![CDATA[Mybatis体系结构SqlSessionFactory​ SqlSessionFactory是mybatis的关键对象，它是单个数据库映射关系经过编译后的内存镜像，SqlSessionFactor对象通过SqlSessionFactorBuilder对象创建获得。 SqlSessionFactorBuilder​ SqlSessionFactorBuilder可以从XML配置文件或者一个预先定制的Configguration的实例为核心构建，它是线程安全的。 SqlSession​ SqlSession也是mybatis的关键对象，它是执行持久化操作的对象，类似JDBC中的Connection对象，它是应用程序与持久化层之间执行交互操作的一个单线程对象， 每个线程都应该有他自己的SqlSession实例，SqlSession的实例不能共享，也是线程不安全的，所有绝对不能将SqlSession实例的引用放在一个类的静态字段中，也绝对不能放在任何类型的管理范围中，比如Serlvet中的HTTPSession对象中。 Mybatis的配置文件结构 configuration配置 propertes 属性 typeAliases 类型命名（别名） typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transationManager 事务管理器 dataSource 数据源 databaseIDProvider 数据库厂商标识 mapping 映射器 propertes 这些属性都是外部配置然后可以动态替换的演示:​ 在类路径下新建一个db.properties的java配置文件 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/mybatis username=admin password=123456 然后在Mybatis主配置文件中添加元素 &lt;properties resource="db.properties"/> 之后就可以使用EL表达式获取对应的值 &lt;dataSoure type="POOLED"> &lt;property name="driver" value="${dirver}" /> &lt;property name="url" value="${url}" /> &lt;property name="username" value="${username}" /> &lt;property name="password" value="${password}" /> &lt;/dataSoure> settings设置这是Mybatis中非常重要的调整设置，他会改变Mybatis的运行时行为 配置参考 &lt;settings> &lt;setting name="cacheEnabled" value="true"/> &lt;setting name="lazyLoadingEnabled" value="true"/> &lt;setting name="multipleResultSetsEnabled" value="true"/> &lt;setting name="useColumnLabel" value="true"/> &lt;setting name="useGeneratedKeys" value="false"/> &lt;setting name="autoMappingBehavior" value="PARTIAL"/> &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/> &lt;setting name="defaultExecutorType" value="SIMPLE"/> &lt;setting name="defaultStatementTimeout" value="30"/> &lt;setting name="defaultFetchSize" value="200"/> &lt;setting name="safeRowBoundsEnabled" value="false"/> &lt;setting name="mapUnderscoreToCamelCase" value="false"/> &lt;setting name="localCacheScope" value="SESSION"/> &lt;setting name="jdbcTypeForNull" value="OTHER"/> &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/> &lt;/settings> typeAliases类型命名​ 类型别名时为java类型设置的一个短名字，存在的意义在于减少冗余的全限定类名 方法一&lt;!--这样配置后任何使用到com.qs304.beans.User的地方都能使用user代替--> &lt;typeAliases> &lt;typeAlias alias="user" type="com.qs304.beans.User">&lt;/typeAlias> &lt;/typeAliases> 方法二&lt;!--别名默认为类名首字母小写，指定这个包名后，mybatis会在下面的包中搜索--> &lt;typeAliases> &lt;pakage name="com.qs304.bean"/> &lt;/typeAliases> 若使用了注解这别名为注解的值，没有使用就是类名首字母小写 Mybatis已经为许多常见的java类型内建了相应的类型别名他们都是大小写不敏感的 参考：https://blog.csdn.net/lyf_ldh/article/details/77949004 mapper映射器Mybatis需要开发者告诉它去哪寻找映射文件这也就有了mapper &lt;mappers> &lt;!--使用类路径查找资源文件--> &lt;mapper resource="com/qs304/dao/IStudent.xml"/> &lt;!--使用绝对路径查找--> &lt;mapper url="file:///C:/IStudent.xml"/> &lt;!--使用接口查找--> &lt;mapper class="com.qs304.dao.IStudent"/> &lt;!--使用包名查找--> &lt;package name="com.qs304.dao"/> &lt;/mappers> 深入理解Mapper XML映射文件SQL映射文件常用的元素 select 映射查询语句 insert 映射插入语句 update 映射删除语句 sql 可被其他语句引用的可重用语句块 cahe 给定命名空间的缓存配置 cache-ref 给其他命名空间缓存配置引用 resultMap 最复杂也是最强大的元素，用来描述如何从数据库结果集中加载对象 &lt;select&gt;&lt;select &lt;!-- 1. id（必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句 一个命名空间（namespace）对应一个dao接口 这个id也应该对应dao里面的某个方法（sql相当于方法的实现），因此id应该与方法名一致 --> id="selectUser" &lt;!-- 2. parapeterType（可选配置，默认由mybatis自动选择处理） 将要传入语句的参数的完全限定名或别名，如果不配置，mybatis会通过ParamterHandler根据参数类型默认选择合适的typeHandler进行处理 paramterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --> parapeterType="int" &lt;!-- 3. resultType（resultType 与 resultMap 二选一配置） 用来指定返回类型，指定的类型可以是基本类型，也可以是java容器，也可以是javabean --> resultType="hashmap" &lt;!-- 4. resultMap（resultType 与 resultMap 二选一配置） 用于引用我们通过 resultMap 标签定义的映射类型，这也是mybatis组件高级复杂映射的关键 --> resultMap="USER_RESULT_MAP" &lt;!-- 5. flushCache（可选配置） 将其设置为true，任何时候语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false --> flushCache="false" &lt;!-- 6. useCache（可选配置） 将其设置为true，会导致本条语句的结果被二级缓存，默认值：对select元素为true --> useCache="true" &lt;!-- 7. timeout（可选配置） 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数，默认值为：unset（依赖驱动） --> timeout="10000" &lt;!-- 8. fetchSize（可选配置） 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为：unset（依赖驱动） --> fetchSize="256" &lt;!-- 9. statementType（可选配置） STATEMENT, PREPARED或CALLABLE的一种，这会让MyBatis使用选择Statement, PrearedStatement或CallableStatement，默认值：PREPARED --> statementType="PREPARED" &lt;!-- 10. resultSetType（可选配置） FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为：unset（依赖驱动） --> resultSetType="FORWORD_ONLY" >&lt;/select>]]></content>
      <categories>
        <category>数据库</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对多和多对一以及多对多]]></title>
    <url>%2F2019%2F09%2F28%2Fmybatis-yi-dui-duo-he-duo-dui-yi-yi-ji-duo-dui-duo%2F</url>
    <content type="text"><![CDATA[ORM和MybatisORM​ ORM 全称为:object/relation mapping（对象\关系数据库映射），简单来说就是一种规范，它的出现就是为了解决面向对象编程语言与关系数据库发展不均衡的产物，允许开发者利用面向对象语言的简单易用性又能利用关系数据库的技术优势，于是把关系数据库包装成面向对象模型，这个工具就是ORM。 基本映射方式数据表映射类​ 持久化类被映射到一个数据表，即一个表对应一个Model类 数据表的行映射（即实例）​ 数据表的每行映射一个对象 数据库表列（字段）映射对象的属性​ 数据库表的每列映射一个对象 一对多和多对一查询一个班有多个学生，一个学生一个班 班级表CREATE TABLE `class` ( `id` int(11) NOT NULL AUTO_INCREMENT, `class_name` varchar(255) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4; 学生表CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `class_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `class_id` (`class_id`), CONSTRAINT `class_id` FOREIGN KEY (`class_id`) REFERENCES `class` (`id`) ON DELETE CASCADE ON UPDATE CASCADE ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4; 首先导入pom.xml&lt;?xml version="1.0" encoding="UTF-8"?> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>com.qs304&lt;/groupId> &lt;artifactId>MybatisQuery&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>jar&lt;/packaging> &lt;dependencies> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.6&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>1.2.12&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;resources> &lt;resource> &lt;directory>src/main/java&lt;/directory> &lt;includes> &lt;include>**/*.xml&lt;/include> &lt;/includes> &lt;/resource> &lt;/resources> &lt;/build> &lt;/project> pojo对象班级package com.qs304.beans; import java.io.Serializable; import java.util.List; public class Clazz implements Serializable { private Integer id; private String className; private List&lt;Student> students; @Override public String toString() { return "Clazz{" + "id=" + id + ", className='" + className + '\'' + ", students=" + students + '}'; } public List&lt;Student> getStudents() { return students; } public void setStudents(List&lt;Student> students) { this.students = students; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getClassName() { return className; } public void setClassName(String className) { this.className = className; } } 学生package com.qs304.beans; import java.io.Serializable; public class Student implements Serializable { private Integer id; private String name; private Clazz clazz; public Clazz getClazz() { return clazz; } public void setClazz(Clazz clazz) { this.clazz = clazz; } @Override public String toString() { return "Student{" + "id=" + id + ", name='" + name + '\'' + ", clazz=" + clazz + '}'; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } } utils包package com.qs304.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class SqlFactory { public static SqlSessionFactory getSqlFactory() throws IOException { InputStream in=Resources.getResourceAsStream("mybatisConfig.xml"); return new SqlSessionFactoryBuilder().build(in); } } dao包package com.qs304.dao; import com.qs304.beans.Clazz; import com.qs304.beans.Student; import java.util.List; public interface ImplDao { /** * 一对多查询 * 根据班级id获取班级所有的学生以及班级信息 * @param id 班级id * @return Clazz 班级对象 */ public Clazz findClazzById(int id); /** * 多对一查询 * 根据学生id获取对应学生所在班级以及个人信息 * @param id 学生id * @return Student 学生对象 */ public Student findStudentById(int id); } dao包xml文件&lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> &lt;mapper namespace="com.qs304.dao.ImplDao"> &lt;!--一对多映射配置--> &lt;resultMap id="clazzStudentMap" type="com.qs304.beans.Clazz"> &lt;id property="id" column="id">&lt;/id> &lt;result property="className" column="class_name">&lt;/result> &lt;collection property="students" ofType="student" > &lt;id property="id" column="sid">&lt;/id> &lt;result property="name" column="name">&lt;/result> &lt;/collection> &lt;/resultMap> &lt;resultMap id="studentClazzMap" type="com.qs304.beans.Student"> &lt;id property="id" column="id">&lt;/id> &lt;result property="name" column="name">&lt;/result> &lt;association property="clazz" column="class_id"> &lt;id property="id" column="sid">&lt;/id> &lt;result property="className" column="class_name">&lt;/result> &lt;/association> &lt;/resultMap> &lt;select id="findClazzById" parameterType="int" resultMap="clazzStudentMap"> select class.*, student.id as sid,student.name from class left outer join student on class.id=student.class_id where class.id=#{id}; &lt;/select> &lt;select id="findStudentById" parameterType="int" resultMap="studentClazzMap"> select student.*,class.id as sid,class.class_name from student,class where class.id=student.class_id and student.id=#{id}; &lt;/select> &lt;/mapper> resourcesdb.propertiesdriver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/test username=root password=111 mybatisConfig.xml文件&lt;?xml version="1.0" encoding="UTF-8"?> &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> &lt;configuration> &lt;properties resource="db.properties"/> &lt;typeAliases> &lt;package name="com.qs304.beans"/> &lt;/typeAliases> &lt;environments default="mysql"> &lt;environment id="mysql"> &lt;transactionManager type="JDBC">&lt;/transactionManager> &lt;dataSource type="POOLED"> &lt;property name="driver" value="${driver}"/> &lt;property name="url" value="${url}"/> &lt;property name="username" value="${username}"/> &lt;property name="password" value="${password}"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;mappers> &lt;package name="com.qs304.dao"/> &lt;/mappers> &lt;/configuration> lof4j配置文件log4j.properties log4j.rootLogger = WARN,stdout log4j.appender.stdout = org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target = System.out log4j.appender.stdout.layout = org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern = [%p][%d{yyyy-MM-dd HH:mm:ss} %l] %m%n log4j.appender.D = org.apache.log4j.RollingFileAppender log4j.appender.D.File = log/Wifi_sy/Wifi_sy_warn.log log4j.appender.D.Append = true log4j.appender.D.Threshold = WARN log4j.appender.D.MaxFileSize = 10240KB log4j.appender.D.MaxBackupIndex = 3 log4j.appender.D.layout = org.apache.log4j.PatternLayout log4j.appender.D.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss} [%c:%L:[%p]] %m%n 测试类import com.qs304.beans.Clazz; import com.qs304.beans.Student; import com.qs304.dao.ImplDao; import com.qs304.utils.SqlFactory; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.junit.After; import org.junit.Before; import org.junit.Test; import java.io.IOException; import java.util.logging.Logger; public class test { SqlSession sqlSession=null; SqlSessionFactory sqlSessionFactory=null; @Before public void befor() throws IOException { sqlSessionFactory= SqlFactory.getSqlFactory(); sqlSession=sqlSessionFactory.openSession(); } @Test public void test(){ ImplDao dao=sqlSession.getMapper(ImplDao.class); Clazz clazz=dao.findClazzById(1); System.out.printf(clazz.toString()); } @Test public void test1(){ ImplDao dao=sqlSession.getMapper(ImplDao.class); Student student=dao.findStudentById(1); System.out.printf(student.toString()); } @After public void after(){ sqlSession.commit(); sqlSession.close(); } }]]></content>
      <categories>
        <category>数据库</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis第二天（连接池，动态SQL语句）]]></title>
    <url>%2F2019%2F09%2F16%2Fmybatis-di-er-tian-lian-jie-chi%2F</url>
    <content type="text"><![CDATA[mybatis连接池连接池数据源分类 UNPOOLED 不使用连接池的数据源 POOLED 使用传统的javax.sql.DataSource连接池的数据源 JNDI 使用JNDI实现的数据源 mybatis动态SQL语句作用：为了解决手动拼接SQL的麻烦元素:（注意由于markedown语法问题标签有空格） 标签名 说明 &lt; if &gt; 判断语句，用于但条件分支判断 &lt; choose &gt;(&lt; when &gt;,&lt; otherwise &gt;) 相当于switch语句，用于多条件分支判断 &lt; where &gt;,&lt; trim &gt;,&lt; set &gt; 辅助元素，用于处理一些SQL拼接，特殊字符问题 &lt; bind &gt; 从OGNL表达式中创建一个变量，并将其绑定到上下文，常用于模糊查询的Sql语句 代码演示：​ 假设有下面这个类 public class Person{ private Integer id; private String name; private Integer age; ...//以下的get和set方法以及toString方法省略 } &lt;if&gt;标签&lt;select id="findPersonByidAndname" parameterType="com.qs304.domain.Person" resultType="com.qs304.domain.Person"> select * from persons where 1=1 &lt;if test="id != null"> and id = #{id} &lt;/if> &lt;if test="name"> and name = #{name} &lt;/if> &lt;/select> &lt;!--如果使用了where标签就可以不写where 1=1和and之类的--> &lt;select id="findPersonByidAndname" parameterType="com.qs304.domain.Person" resultType="com.qs304.domain.Person"> select * from persons &lt;where> &lt;if test="id != null"> id = #{id} &lt;/if> &lt;if test="name"> name = #{name} &lt;/if> &lt;/where> &lt;/select> &lt;foreach&gt; 元素&lt;!-- 判断id是否在这个集合里面 select * from pesrsons where id in(1,2,3,4); 类似这样 --> &lt;select id="findPersonByIds" parameterType="List" resultType="com.qs304.domain.Person"> select * from pesrsons where id in &lt;!-- 判断为空可以用 list.size>0--> &lt;foreach item="id" index="index" collection="list" open="(" separator="," close=")"> #{id} &lt;/foreach> &lt;/select> item：配置的是循环中当前的元素。 index：配置的是当前元素在集合的位置下标。 collection：配置的list是传递过来的参数类型（首字母小写），它可以是一个array、list（或collection）、Map集合的键、POJO包装类中数组或集合类型的属性名等。 open和close：配置的是以什么符号将这些集合元素包装起来。 separator：配置的是各个元素的间隔符。]]></content>
      <categories>
        <category>数据库</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis入门教程]]></title>
    <url>%2F2019%2F08%2F30%2Fmybatis%2F</url>
    <content type="text"><![CDATA[Mybatis1.Mybatis简介:​ ​ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。 持久层： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。 优点： 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价 缺点：慢（相对于内存而言） 2.为什么要使用mybatis​ 在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 3.mybatisDemomybatis的环境搭建​ 第一步：创建maven工程并导入坐标 ​ 第二步：创建实体类和dao接口（mybatis可以只有接口就能实现对数据库的增删改查，而且实体类就是要实体类的属性和数据库的表对应起来） ​ 第三步：创建mybatis的主配置文件 SqlMapConfig.xml（名字可以随意） ​ 第四步：创建映射配置文件 IUserDao.xml（名字可以随意） ​ 搭建注意事项: ​ 第一个:创建IUserDao.xml和IUserDao.java 在mybatis中 他把持久层的操作接口名称和映射文件叫做:Mapper ​ 第二个：在idea中创建目录的时候，他和包是不一样的， ​ 第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同 ​ 第四个：映射配置文件的操作配置（select）,id属性的取值必须是dao接口的方法名 ​ 第五个：映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定类名 maven坐标 &lt;dependencies> &lt;dependency> &lt;groupId>org.mybatis&lt;/groupId> &lt;artifactId>mybatis&lt;/artifactId> &lt;version>3.5.2&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>5.1.6&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.12&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>1.2.12&lt;/version> &lt;/dependency> &lt;/dependencies> 首先Bean包Account.java package cn.Bean; public class Account { private Integer id; private String name; private Double money; @Override public String toString() { return "Account{" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '}'; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Double getMoney() { return money; } public void setMoney(Double money) { this.money = money; } } 然后dao包下的IDao.java接口 package cn.dao; import cn.Bean.Account; import java.util.List; /** * 获取所有的Account信息 */ public interface IDao { public List&lt;Account> getAccountAll(); } 然后创建主配置文件MybatisConfig.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> &lt;configuration> &lt;!--配置环境--> &lt;environments default="mysql">&lt;!--defult填写的子类必须也有--> &lt;!--配置mysql的环境--> &lt;environment id="mysql"> &lt;!--配置事务的类型--> &lt;transactionManager type="JDBC">&lt;/transactionManager> &lt;!--配置数据源--> &lt;dataSource type="POOLED"> &lt;!--配置连接数据库--> &lt;property name="driver" value="com.mysql.jdbc.Driver"/> &lt;property name="url" value="jdbc:mysql://localhost:3306/ee"/> &lt;property name="username" value="root"/> &lt;property name="password" value="123456"/> &lt;/dataSource> &lt;/environment> &lt;/environments> &lt;!--配置映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--> &lt;mappers> &lt;mapper resource="cn/config/IDao.xml">&lt;/mapper> &lt;/mappers> &lt;/configuration> 然后穿件cn目录下config目录下的IDao.xml映射IDao.java的配置文件，注意xml文件和java文件必须是统一限定目录 &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> &lt;!--namespace填写IDao接口的全限定类名--> &lt;mapper namespace="cn.dao.IDao"> &lt;!--配置查询所有 id必须是IDao方法的名称,resultType必须是实体类 --> &lt;select id="getAccountAll" resultType="cn.Bean.Account"> select * from account; &lt;/select> &lt;/mapper> 最后是测试类 import cn.Bean.Account; import cn.dao.IDao; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.util.List; public class Test { @org.junit.Test public void getALl() throws IOException { //1.读取配置文件 InputStream in= Resources.getResourceAsStream("MybatisConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IDao dao=session.getMapper(IDao.class); //5.使用代理对象执行方法 List&lt;Account> users=dao.getAccountAll(); for (Account user : users) { System.out.println(user); } } } 打印信息为 Sat Jul 27 15:54:14 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. Account{id=1, name='aaa', money=600.0} Account{id=2, name='bbb', money=1200.0} Account{id=3, name='ccc', money=1000.0} Account{id=4, name='hhh', money=1000.0} Account{id=5, name='hhh', money=200.0} 如果需要保存数据则把IDao.xml改成以下 &lt;?xml version="1.0" encoding="UTF-8" ?> &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"> &lt;!--namespace填写IDao接口的全限定类名--> &lt;mapper namespace="cn.dao.IDao"> &lt;!--配置查询所有 id必须是IDao方法的名称,resultType必须是实体类--> &lt;select id="getAccountAll" resultType="cn.Bean.Account"> select * from account; &lt;/select> &lt;!--通过里面配置selectKey标签的方式可以获取插入数据后所对应的自增长id的值--> &lt;select id="addAccount" parameterType="cn.Bean.Account"> &lt;!--selectKey 会将 SELECT LAST_INSERT_ID()的结果放入到传入的model的主键里面， keyProperty 对应的model中的主键的属性名，这里是 user 中的id，因为它跟数据库的主键对应 order AFTER 表示 SELECT LAST_INSERT_ID() 在insert执行之后执行,多用与自增主键， BEFORE 表示 SELECT LAST_INSERT_ID() 在insert执行之前执行，这样的话就拿不到主键了， 这种适合那种主键不是自增的类型 resultType 主键类型 --> &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER">&lt;/selectKey> insert INTO account(name,money) values(#{name},#{money}) &lt;/select> &lt;/mapper> 值得一提的是：resultType属性可以类型有简单类型或者pojo对象，或者pojo对象的包装对象（pojo对象的列表）。pojo对象就是javabean或者说是实体类对象 ​ 然后上述xml文件配置中就是用了OGNL表达式 OGNL表达式中省略的get关键字，即user.getName()变成了user.name; 在mybatis中标签属性resultType中提供了user对象的包名，所以可以直接使用name来达到user.name相同的效果 测试类里面： import cn.Bean.Account; import cn.dao.IDao; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.File; import java.io.IOException; import java.io.InputStream; import java.util.List; public class Test { @org.junit.Test public void getALl() throws IOException { //1.读取配置文件 InputStream in= Resources.getResourceAsStream("MybatisConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IDao dao=session.getMapper(IDao.class); //5.使用代理对象执行方法 Account ac=new Account(); ac.setName("hha"); ac.setMoney(99999.0); dao.addAccount(ac); List&lt;Account> users=dao.getAccountAll(); for (Account user : users) { System.out.println(user); } //如果没有正确提交到数据库需要手动提交事务 //session.commit(); } } 注解配置​ 首先可以把IDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句，同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名 实体类对象的属性名称与mysql数据库里面的列名不同解决方案：原因：​ mysql数据库里面的列不能和实体类对象的属性进行对应，说以要解决这个问题必须从解决对应关系下手 使用mysql的别名进行对应 使用mybatis里面的resultMap标签进行对应匹配（然后标签里面的resultType属性换成resultMap属性来使用配置的resultMap标签里面的内容）]]></content>
      <categories>
        <category>数据库</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键操作]]></title>
    <url>%2F2019%2F06%2F27%2Fidea-kuai-jie-jian-cao-zuo%2F</url>
    <content type="text"><![CDATA[IDEA 快捷键操作1.搜索跳转 作用 快捷键 备注 多个窗口之间跳转 ctrl+alt+[或者] [跳转到上一个窗口,]跳转到下一个窗口 导航栏跳转 alt+数字键 侧边栏上面标注数字 万能搜索键 按两次shift键 可以打开万能的搜索窗口 跳转到上次编辑的地方 ctrl+shift+backspace 可以定位到上次编辑的地方 跳转到上次浏览的地方 ctrl+alt+左箭头 跳转到上次浏览的地方 跳转到上次浏览的地方返回 ctrl+alt+右箭头 跳转到上次浏览的地方返回 打开最近文件浏览列表 ctrl+E 方便快速的多文件跳转 文件标签 ctrl+F11 给文件添加标签 文件标签跳转 ctrl+标签名称 方便阅读别源代码 添加到喜爱代码库 alt+shift+f 放到类上面添加类到列表里面，放到方法上面添加方法到列表里面 搜索字符串 ctrl+shift+f 搜素所有的字符串 2.代码小助手注意定义 live Template动态模板还有postfix点模板 对选中的大小写进行转换 ctrl+shift+u 对选中的大小写进行转换 选中当前选中的元素进行多行处理 ctrl+shift+alt+j 选中当前选中的元素进行多行处理 格式化代码 ctrl+alt+L 格式化代码 重构变量 shift+f6 重构变量 重构方法 ctrl+f6 重构方法 抽取变量 ctrl+alt+v 抽取变量 将选中的代码块抽取成为函数 ctrl+alt+m 将选中的代码块抽取成为函数 查看选中的类或者接口的继承关系 Ctrl+shift+u 查看选中的类或者接口的继承关系]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>IDEA</tag>
        <tag>IDE</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法树状数组]]></title>
    <url>%2F2019%2F05%2F27%2Fsuan-fa-shu-zhuang-shu-zu%2F</url>
    <content type="text"><![CDATA[算法:树状数组1.适用场景​ 可以解决大部分基于区间上的更新以及求和问题 2.介绍1.单点查询 我们先从数组讲起(这个就不需要普及了吧)； A数组是我们传入数据的数组 C数组使我们建立起来的树状数组 然后就能显而易见的发现一个规律 C1 = A1 C2 = A1+A2 C3 = A3 C4 = A1+A2+A3+A4 C5 = A5 C6 = A5+A6 C7 = A7 C8 = A1+A2+A3+A4+A5+A6+A7+A8接下来我们引入lowbit这个概念：(这个地方有一点需要注意：lowbit(0)会陷入死循环 ) inline int lowbit(int x) { return x &amp; (-x); } 这返回的是这个数字最高位的1; 在这之前，又要引入一个补码的概念： 补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 请注意，这里的第一位是指的是符号位，而不是数字位(这是1，因此数字位只有1) 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 因此，&amp;是求与的一个符号，意思是 a 和 b 同时为 1 的时候返回这个最高位(不包括符号位) 在刚刚的找规律过程中，我们通过规律总结出了以下性质(lowbit是为了帮助程序代码的实现) 我们可以得到树状数组的一些性质：对于c[i]，他的儿子节点取决于i的所有因子中最多有2^j次幂，则向前取2^j个数作为儿子，即[i-2^j+1,i]。(这个时候就需要lowbit来帮助实现) 举一个栗子： 6的最大2次方因子为2，即2^1，则向前取2个数，则c[6]=a[5]+a[6]； 8的最大2次方因子为8，即2^3，则向前取8个数，则c[8]=a[1]+a[2]+…+a[8]。 2.单点修改 当我们要对最底层的值进行更新时，那么它相应的父亲节点存储的和也需要进行更新， 我们建立的树状数组结构是一个完整的结构，因此修改一个点也会需要所有相应的其父亲节点的点来修改，这样我们就实现了树状数组的修改。 代码如下： void modify(int x,int k) //将 x 增加 k { if(x &lt; 1) return ; while(x &lt;= n) { c[i] += k; x += lowbit(x); //去寻找它的父亲 } } 3.单点查询 单点查询由于我们向前统计，因此需要向前查找，这个就不需要讲了吧(没弄明白请看上面) int query(int pos) { int sum=0; for(int i=pos;i;i-=lowbit(i)) sum += c[pos]; /*两种写法 while(pos > 0) { sum += c[pos]; pos -= lowbit(pos); } */ return sum; } //这是完整的操作 void change(int p, int x) { //给位置p增加x while(p &lt;= n) { sum[p] += x; p += p &amp; -p; } } int ask(int p) { //求位置p的前缀和 int res = 0; while(p) { res += sum[p]; p -= p &amp; -p; } return res; } int query(int l, int r) { //区间求和 return ask(r) - ask(l - 1); }]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架教程]]></title>
    <url>%2F2019%2F03%2F10%2Fspringmvc-kuang-jia-jiao-cheng%2F</url>
    <content type="text"><![CDATA[SpringMVC框架教程前言为开发团队选择一款优秀的MVC框架是件难事儿，在众多可行的方案中决择需要很高的经验和水平。你的一个决定会影响团队未来的几年。要考虑方面太多： 1、简单易用，以提高开发效率。使小部分的精力在框架上，大部分的精力放在业务上。 2、性能优秀，这是一个最能吸引眼球的话题。 3、尽量使用大众的框架（避免使用小众的、私有的框架），新招聘来的开发人员有一些这方面技术积累，减低人员流动再适应的影响。 简介​ pring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架或集成其他MVC开发框架，如Struts]1(现在一般不用)，Struts 2(一般老项目使用)等。 SpringMVC框架优势1.清晰的角色划分：控制器(controller)、验证器(validator)、命令对象(command obect)、表单对象(form object)、模型对象(model object)、Servlet分发器(DispatcherServlet)、处理器映射(handler mapping)、试图解析器(view resoler)等等。每一个角色都可以由一个专门的对象来实现。 2.强大而直接的配置方式：将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在web控制器中对业务对象和验证器validator)的引用。 3.可适配、非侵入：可以根据不同的应用场景，选择何事的控制器子类(simple型、command型、from型、wizard型、multi-action型或者自定义)，而不是一个单一控制器(比如Action/ActionForm)继承。 4.可重用的业务代码：可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类。 5.可定制的绑定(binding)和验证(validation)：比如将类型不匹配作为应用级的验证错误，这可以保证错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象，需要手动解析它并转换到业务对象。 6.可定制的handler mapping和view resolution：Spring提供从最简单的URL映射，到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活。 7.灵活的model转换：在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成。 8.可定制的本地化和主题(theme)解析：支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity(不需要额外的中间层)等等。 9.简单而强大的JSP标签库(Spring Tag Library)：支持包括诸如数据绑定和主题(theme)之类的许多功能。他提供在标记方面的最大灵活性。 10.JSP表单标签库：在Spring2.0中引入的表单标签库，使用在JSP编写表单更加容易。 11.Spring Bean的生命周期：可以被限制在当前的HTTp Request或者HTTp Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。 SpringMVC与Struts2框架的对比拦截机制1、Struts2 a、Struts2框架是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype（否则会出现线程并发问题），然后通过setter，getter吧request数据注入到属性。b、Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。c、Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了2、SpringMVCa、SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。b、在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。 性能方面 SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。 四、拦截机制Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 配置方面spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。SpringMVC可以认为已经100%零配置。 设计思想Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。 集成方面SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 注解详解RequestMapping介绍你可以使用@RequestMapping来映射URL，比如/test到某个Controller类，或者是某个具体的方法。通常类上的注解@RequestMapping用来标记请求的路径，方法上的@RequestMapping注解的作用将是映射到特定的URL到某个具体的处理方法。 作用被添加注解的方法参数就是发起请求的参数，返回值就是通过跳转的页面名字 参数： value,请求的URL路径，支持URL模板，正则表达式。这也是我们最常用的一种映射方 method(多个)，指定接收请求的方法，有GET,POST,PUT等，RequestMethod枚举类，如果没有按规则会抛405 Method Not Allowed params(多个) 指定请求的参数，例如parame=”user” ，那么请求中必须携带user参数的key，如果是parame=”user=123” ，那么参数就key必须是user,value必须是123,否则不能正常执行而且抛出400 错误的请求 headers(多个) 指定请求的头 consumes,允许的媒体类型Media Types ），如consumes ＝ ”application/ison ”， 对应于请求的HTTP 的Content-Type 。 @RequestParam作用：在SpringMVC中如果方法上被添加了·RequestMappring注解且方法有参数，那么必须传入与方法参数同名的的参数名，当使用了这个就可以实现传入产生非同名范围:参数内示例 @RequestMapping("/list") /** *传入的参数必须与user同名，而非必须和username同名 */ public String test(@RequestParam("user") String username ){ return null; } @RequestBady作用：获取请求体的内容，其格式是key:value的格式，其中get请求不适用（get请求没有请求体，它把的参数在url中）,该注解经常使用在异步的方式中范围：参数内注意:方法的名字不能与请求的任何参数同名，因为在Springmvc框架中，任何同名的都被看成同名封装.示例 @RequestMapping("/list") /** *注意，方法的名字不能与请求的任何参数同名，因为在Springmvc框架中，任何同名的都被看成同名封装， */ public String test(@RequestBady String bady){ System.out.println(bady);//打印结果将会是key：value的形式 return null; } @PathVariable(REST编程风格)作用: 带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 主要是根据请求方法进行类的区别 范围：参数内 示例: /** *通过使用PathVariable注解实现占位符上数据的获取 *参数发送格式应该是请求的url例如xxx/list/12 */ @RequestMapping("/list/{sid}") public String test(@PathVariable(name="sid") String id){ System.out.println(id);//结果因该为12 return null; } @ModelAttribute作用： ​ 来处理传入的参数少的问题 ​ 添加在方法上面时候，该方法会优先执行 ​ 添加在参数上面的时候，需要一个map集合来处理传入的参数少的问题 范围：方法上和参数上 示例： 假设有个user的javaBean对象 ​ 第一种，注解添加在方法上 @RequestMapping("/list/modelAttribute") public String test(User user){ System.out.println(user); return null; } @ModelAttribute public User modelAttribute(User user){//返回值必须三user类型才能保证接下来的方法接收到参数,参数时user类本方法才能获取到传入的参数 System.out.println("先执行,同时可以做一些其他操作，比如补全user对象不全的信息"); } 第二种,注解添加在参数内 @RequestMapping("/list/modelAttribute") public String test(@ModelAttribute("abc") User user){//获取abc的对象存入user System.out.println(user); return null; } public void modelAttribute(User user,Map&lt;String,User> map){//返回值就不是必须的，但是参数必须有个map，,map&lt;String,User> System.out.println("先执行,同时可以做一些其他操作，比如补全user对象不全的信息"); map.put("abc",user);//进行一些操作 } SessionAttributes作用:​ 向Session对象存入值，于在多个请求之间传递参数，类似于Session的Attribute，但不完全一样，一般来说@SessionAttributes设置的参数只用于暂时的传递，而不是长期的保存，长期保存的数据还是要放到Session中。（向Requests域存入对象需要使用Model接口的实现类） 范围：类spring 请求参数绑定绑定简述​ 在SpringMVC中，被添加@RequestMapping的方法的参数就是请求的参数 简要介绍首先javabean类对象 package com.qs304; import java.util.List; import java.util.Map; public class Beans { private Integer account; private String password; private Person person; private Map&lt;String,String> map; private List&lt;String> list; } class Person{ private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return "Person{" + "name='" + name + '\'' + '}'; } } 参数绑定接收方法 @Controller @RequestMapping("parme") public class HelloController { @RequestMapping(value = "/hello",method = RequestMethod.POST) public String helloSpringMVC(Beans beans){//返回值表示要跳转的jsp页面的名字 System.out.println(beans); return "success"; } } jsp页面的提交 &lt;form action="parme/hello" method="post"> account&lt;input type="text" name="account">&lt;br/> password&lt;input type="text" name="password">&lt;br/> pseron.name&lt;input type="text" name="person.name">&lt;br/> mapkey&lt;input type="text" name="map[key]">&lt;br/> list&lt;input type="text" name="list[0]">&lt;br/> &lt;input type="submit" value="提交"> &lt;/form> SpringMVC获取Servlet原生API在方法的上面的参数添加requests或者response的全限定类名即可 Spring MVC 自定义类型转换介绍​ 在SpringMVC框架中，视图层传递过来的参数都是String类型，但是在参数绑定的时候Spring框架会自动帮我们进行类型转换，但是当遇到无法转换的类型时，就需要我们自定义类型转换器 步骤：1.定义一个类，实现Converter接口，该接口有两个泛型，key表示接受类型，value表示转换后的类型 public interface Converter&lt;S, T> {//S:表示接受的类型，T：表示目标类型 /** * 实现类型转换的方法 */ @Nullable T convert(S source); } /** * 自定义类型转换器 */ public class StringToDateConverter implements Converter&lt;String, Date> { /* 用于把 String 类型转成日期类型 */ public Date convert(String source) { DateFormat format = null; try { if(StringUtils.isEmpty(source)) { throw new NullPointerException("请输入要转换的日期"); } format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(source); return date; } catch (Exception e) { throw new RuntimeException("输入日期有误"); } } } 2.在配置文件中，注册该组件并使他生效 &lt;!-- 配置类型转换器工厂 --> &lt;bean id="converterService" class="org.springframework.context.support.ConversionServiceFactoryBean"> &lt;!-- 给工厂注入一个新的类型转换器 --> &lt;property name="converters"> &lt;array> &lt;!-- 配置自定义类型转换器 --> &lt;bean class="com.study.web.converter.StringToDateConverter">&lt;/bean> &lt;/array> &lt;/property> &lt;/bean> &lt;!-- 引用自定义类型转换器 --> &lt;mvc:annotation-driven conversion-service="converterService">&lt;/mvc:annotation-driven> SpringMVC五大组件DispatcherServlet:前端控制器​ 用户请求到达前端控制器，是整个流程控制的中心，当使用了静态文件，如js文件css文件，如果请求不到，要注意放弃前端控制器的请求拦截 HandlerMapping:处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 ViewResolver:视图解析器ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 Handler:处理器Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 View:视图SpringMVC框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 SpringMVC 框架快速搭建演示首先使用maven创建web项目 然后导入坐标 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>qs.304&lt;/groupId> &lt;artifactId>SpringMVCDemo&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>war&lt;/packaging> &lt;name>SpringMVCDemo Maven Webapp&lt;/name> &lt;!-- FIXME change it to the project's website --> &lt;url>http://www.example.com&lt;/url> &lt;properties> &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding> &lt;maven.compiler.source>1.8&lt;/maven.compiler.source> &lt;maven.compiler.target>1.8&lt;/maven.compiler.target> &lt;spring.version>5.0.2.RELEASE&lt;/spring.version> &lt;/properties> &lt;dependencies> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>4.11&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-web&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-webmvc&lt;/artifactId> &lt;version>${spring.version}&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>servlet-api&lt;/artifactId> &lt;version>2.5&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>javax.servlet&lt;/groupId> &lt;artifactId>jsp-api&lt;/artifactId> &lt;version>2.0&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;build> &lt;finalName>SpringMVCDemo&lt;/finalName> &lt;pluginManagement>&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --> &lt;plugins> &lt;plugin> &lt;artifactId>maven-clean-plugin&lt;/artifactId> &lt;version>3.1.0&lt;/version> &lt;/plugin> &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --> &lt;plugin> &lt;artifactId>maven-resources-plugin&lt;/artifactId> &lt;version>3.0.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-compiler-plugin&lt;/artifactId> &lt;version>3.8.0&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-surefire-plugin&lt;/artifactId> &lt;version>2.22.1&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-war-plugin&lt;/artifactId> &lt;version>3.2.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-install-plugin&lt;/artifactId> &lt;version>2.5.2&lt;/version> &lt;/plugin> &lt;plugin> &lt;artifactId>maven-deploy-plugin&lt;/artifactId> &lt;version>2.8.2&lt;/version> &lt;/plugin> &lt;/plugins> &lt;/pluginManagement> &lt;/build> &lt;/project> 然后在web.xml配置前端控制器并且设置为第一次加载的时候加载spring容器 &lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" > &lt;web-app> &lt;display-name>Archetype Created Web Application&lt;/display-name> &lt;!--配置spring前端控制器--> &lt;servlet> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;!--加载spring容器--> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>classpath:springmvc.xml&lt;/param-value> &lt;/init-param> &lt;!--设置启动项目就加载spring容器--> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcherServlet&lt;/servlet-name> &lt;url-pattern>/&lt;/url-pattern> &lt;/servlet-mapping> &lt;/web-app> 之后创建springmvc.xml文件配置视图解析器，并且指定视图解析器扫描的包和文件后缀 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> &lt;context:component-scan base-package="com.qs304"/> &lt;!--配置视图解析器--> &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"> &lt;!--配置参数--> &lt;property name="prefix" value="/WEB-INF/pages/">&lt;/property> &lt;property name="suffix" value=".jsp">&lt;/property> &lt;/bean> &lt;!--开启springmvc注解支持--> &lt;mvc:annotation-driven/> &lt;/beans> 之后配置控制器controller package com.qs304.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HelloController { @RequestMapping("/hello") public String helloSpringMVC(){//返回值表示要跳转的jsp页面的名字 System.out.println("哈哈哈"); return "success"; } } 这是目录结构 springmvc框架运行流程 ModelAndVIew简介​ ModelAndView从这个名字我们不难看出，他的作用就是模型与视图之间进行交互。 而model,只能向request域进行存对象，所有就出现了，使用ModelAndView类用来存储处理完后的结果数据，以及显示该数据的视图。 用法 public class testModelAndView{ @RequestMapping("/testModelAndView") public void testModelAndView(){ ModelAndView mv=new ModelAndView(); mv.addObject("asd","asd");//往request域存取数据 mv.setViewName("123");//使用前端控制器跳转到123页面 } } 使用关键字进行转发或者重定向在返回值前写forward:路径这样会进行转发功能，使用redirect进行重定向注意，这种方法使用较少，而且使用后不能使用前端控制器]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA动态代理]]></title>
    <url>%2F2019%2F02%2F27%2Fjava-dong-tai-dai-li%2F</url>
    <content type="text"><![CDATA[JAVA动态代理前言：​ 最近在学习spring框架，但是在学习（切面编程）aop的时候老师讲到了一个动态代理，这个东西听着很晕乎，听说在学习javaweb的时候讲filter过滤器也是这个原理，╮(╯▽╰)╭无奈当时没有注意底层也就没有学会，现在正好有机会就把这个动态代理好好学习一下吧。 1.什么是代理代理模式的定义：​ 代理模式给某一个对象提供一个代理对象，并有代理对象控制原对象的引用（╮(╯▽╰)╭，定义都是这么的晦涩难懂） 例子：​ 假如你现在想购买一个笔记本，于是乎当然只关心价格和性能售后啊，而且购买渠道要方便啊，当然厂家生产笔记本后不可能把货物分发到全球各地因为地球太大了，但是消费者想要购买的方便啊，对于消费者来说他要购买方便也就是买电脑的地方离自己比较近，并不关心厂家怎么把电脑弄过来，而且对于厂家来说他只要把电脑做出来做好售后就行了，为什么费这么大劲在各地建立销售网点呢，好钢当然是用在刀刃上面啦。于是乎电脑城这个奸商聚集地就出来了（带着有色眼镜看待的这个问题，不要喷我），奸商正好把厂家和消费者连接起来。而且消费者想维修之类的必须经过代理商也就是电脑城的奸商才能和厂家联系，于是乎这个代理商就起到了代理的作用。 2. 要想知道动态代理首先要知道代理模式的应用场景### 需求和分析：​ 假设有个需求，需要你不修改原有代码的基础上对一个类（Person）的功能进行增强，这下怎么办呢？ ​ 其实可以这样，首先写一个用来增强那个Person那个类的类并且继承Person类实现的那个接口，就叫他Proxy类吧，然后在Proxy类创建的时候可以吧Person这个类当做参数传进去，然后在Proxy类中调用同名的方法（哒哒哒，这就完成啦），其实这个过程就是静态代理模式。也就是说代理对象 = 增强代码 + 目标对象（原对象） 大概就是这样样子，画图比较丑，而且不会用xmind（╮(╯▽╰)╭） 静态代理模式的缺点：​ 这样有什么缺点呢，假设我们有很多个类需要被增强，那么我们要给每一个类都写一个对应的代理类，那么这样也忒麻烦了，代理类你这么麻烦搞的大家都不想和你玩了。 3.动态代理前言​ 动态代理之前要说其实还有一个class类，这个东西比较复杂，（先埋个坑，以后在填坑），class这个类可以获取任意类的构造方法，属性等等等之类的，也就是说我们可以用来复制一个类，代理类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。也就是说接口拥有代理类对象和目标对象共同的类信息，但是类信息不能创建对象。于是乎jdk提供了java.lang.reflect.InvocationHandler接口和java.lan.reflect.Proxy类。 Proxy类​ Proxy有个静态方法：getProxyClass(ClassLoader,interfaces),只要你给他传入类加载器和一组接口，他就会给你返回代理Class对象。 ​ 通俗点说就是，你给他传入接口的Class中，复制类结构到新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。 所以Proxy.getProxyClass()这个方法的本质就是用Class造Class 动态代理的作用：​ Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大； ​ 可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用； ​ 解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。 ### 代码演示电脑生产厂家类（被代理对象） 电脑城坑人类（代理对象） 销售接口: Main类]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven入门教程]]></title>
    <url>%2F2019%2F02%2F20%2Fmaven-ru-men-jiao-cheng%2F</url>
    <content type="text"><![CDATA[maven教程简介​ Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。 Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。（这是我百度复制过来的，╮(╯▽╰)╭，算是毛病吧） 特性跨平台：是指跨OS平台，跨IDE平台 标准化：项目构建标准化，和项目结构标准化 maven目录结构 命令4. 编译源代码： mvn compile5. 编译测试代码： mvn test-compile6. 运行测试: mvn test7. 产生site： mvn site8. 打包： mvn package9. 在本地Repository中安装jar： mvn install 例：installing D:\xxx\xx.jar to D:\xx\xxxx10. 清除产生的项目： mvn clean11. 生成eclipse项目： mvn eclipse:eclipse12. 生成idea项目： mvn idea:idea13. 组合使用goal命令，如只打包不测试： mvn -Dtest package14. 编译测试的内容： mvn test-compile15. 只打jar包: mvn jar:jar16. 只测试而不编译，也不测试编译： mvn test -skipping compile -skipping test-compile ( -skipping 的灵活运用，当然也可以用于其他组合命令) 17. 清除eclipse的一些系统设置: mvn eclipse:clean 18.查看当前项目已被解析的依赖： mvn dependency:list19.上传到私服： mvn deploy20. 强制检查更新，由于快照版本的更新策略(一天更新几次、隔段时间更新一次)存在，如果想强制更新就会用到此命令: mvn clean install-U21. 源码打包： mvn source:jar 或 mvn source:jar-no-fork]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>习惯</tag>
        <tag>maven</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码注意细节]]></title>
    <url>%2F2019%2F02%2F20%2Fdai-ma-zhu-yi-xi-jie%2F</url>
    <content type="text"><![CDATA[代码注意细节1.设计细节springspring配置类中父子关系的配置类更好 mysqlmysql中要严格遵守三大范式才能设计比较好的数据库 mysql中使用外键约束要注意进行级联操作，否则必须先修改依赖表 2.编码细节]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpEL表达式详解]]></title>
    <url>%2F2019%2F01%2F18%2Fspel-biao-da-shi-xiang-jie%2F</url>
    <content type="text"><![CDATA[前言SpEL（Spring Expression Language），即Spring表达式语言，是比JSP的EL更强大的一种表达式语言。为什么要总结SpEL，因为它可以在运行时查询和操作数据，尤其是数组列表型数据，因此可以缩减代码量，优化代码结构。 位置SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。 一. 用法 SpEL有三种用法，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。 关于无法使用@Value来获取问题解决 @Value("#{123}") private int age; @Value("#{123}") private static int age;//不允许 @Value("#{123}") private final int age;//不允许 被注入变量不能私有，也不能被final修饰 是不是使用了ClassPathXmlApplicationContext这个容器类，忘记了开启包扫描 &lt;context:component-scan base-package="config">&lt;/context:component-scan> @Value //@Value能修饰成员变量和方法形参 //#{}内就是表达式的内容 @Value("#{表达式}") public String arg; 关于无法使用@Value来获取问题解决 @Value("#{123}") private int age; @Value("#{123}") private static int age;//不允许 @Value("#{123}") private final int age;//不允许 被注入变量不能私有，也不能被final修饰 是不是使用了ClassPathXmlApplicationContext这个容器类，忘记了开启包扫描 &lt;context:component-scan base-package="config">&lt;/context:component-scan> 不能使用final和static修饰的原因 spring的注入是一般是发生在调用构造方法后进行注入，除非使用的是构造方法注入。其实也就是set方法注入，也就是说@Value的注入也是发生在构造方法调用后进行注入的。 也就是说spring的注入是针对对象进行的注入，静态方法不属于对象是属于类的 为什么private也可以注入，就算没有set方法？我们在使用反射技术的时候可以关闭语言访问检查来强制注入私有属性的，所以@Autowired和@Value是属于这种注入。 但是使用xml文件property是一栏set方法注入的。 @Value&lt; bean &gt;配置&lt;bean id="xxx" class="com.java.XXXXX.xx"> &lt;!-- 同@Value,#{}内是表达式的值，可放在property或constructor-arg内 --> &lt;property name="arg" value="#{表达式}"> &lt;/bean> Expressionimport org.springframework.expression.Expression; import org.springframework.expression.ExpressionParser; import org.springframework.expression.spel.standard.SpelExpressionParser; import org.springframework.expression.spel.support.StandardEvaluationContext; public class SpELTest { public static void main(String[] args) { //创建ExpressionParser解析表达式 ExpressionParser parser = new SpelExpressionParser(); //表达式放置 Expression exp = parser.parseExpression("表达式"); //执行表达式，默认容器是spring本身的容器：ApplicationContext Object value = exp.getValue(); /**如果使用其他的容器，则用下面的方法*/ //创建一个虚拟的容器EvaluationContext StandardEvaluationContext ctx = new StandardEvaluationContext(); //向容器内添加bean BeanA beanA = new BeanA(); ctx.setVariable("bean_id", beanA); //setRootObject并非必须；一个EvaluationContext只能有一个RootObject，引用它的属性时，可以不加前缀 ctx.setRootObject(XXX); //getValue有参数ctx，从新的容器中根据SpEL表达式获取所需的值 Object value = exp.getValue(ctx); } } 字面量语法&lt;!-- 整数 --> &lt;property name="intger" value="#{5}" /> &lt;!-- 小数 --> &lt;property name="double" value="#{13.2}" /> &lt;!-- 科学计数法 --> &lt;property name="capacity" value="#{1e4}" /> &lt;!-- 字符串 #{"字符串"} 或 #{'字符串'} --> &lt;property name="str" value="#{'我是字符串'}" /> &lt;!-- Boolean --> &lt;property name="bool" value="#{false}" /> 字面量赋值必须要和对应的属性类型兼容，否则会报异常。 一般情况下我们不会使用 SpEL字面量赋值，因为我们可以直接赋值。 引用Bean、属性和方法（必须是public修饰的）&lt;property name="car" value="#{car}" /> &lt;!-- 引用其他对象的属性 --> &lt;property name="carName" value="#{car.name}" /> &lt;!-- 引用其他对象的方法 --> &lt;property name="carPrint" value="#{car.print()}" /> 运算符算术运算符：+,-,*,/,%,^&lt;!-- 3 --> &lt;property name="num" value="#{2+1}" /> &lt;!-- 1 --> &lt;property name="num" value="#{2-1}" /> &lt;!-- 4 --> &lt;property name="num" value="#{2*2}" /> &lt;!-- 3 --> &lt;property name="num" value="#{9/3}" /> &lt;!-- 1 --> &lt;property name="num" value="#{10%3}" /> &lt;!-- 1000 --> &lt;property name="num" value="#{10^3}" /> 字符串连接符：+&lt;!-- 10年3个月 --> &lt;property name="numStr" value="#{10+'年'+3+'个月'}" /> 比较运算符：&lt;(&lt;),&gt;(&gt;),==,&lt;=,&gt;=,lt,gt,eq,le,ge&lt;!-- false --> &lt;property name="numBool" value="#{10&amp;lt;0}" /> &lt;!-- false --> &lt;property name="numBool" value="#{10 lt 0}" /> &lt;!-- true --> &lt;property name="numBool" value="#{10&amp;gt;0}" /> &lt;!-- true --> &lt;property name="numBool" value="#{10 gt 0}" /> &lt;!-- true --> &lt;property name="numBool" value="#{10==10}" /> &lt;!-- true --> &lt;property name="numBool" value="#{10 eq 10}" /> &lt;!-- false --> &lt;property name="numBool" value="#{10&amp;lt;=0}" /> &lt;!-- false --> &lt;property name="numBool" value="#{10 le 0}" /> &lt;!-- true --> &lt;property name="numBool" value="#{10&amp;gt;=0}" /> &lt;!-- true --> &lt;property name="numBool" value="#{10 ge 0}" /> 逻辑运算符：and,or,not,&amp;&amp;(&amp;&amp;),||,!&lt;!-- false --> &lt;property name="numBool" value="#{true and false}" /> &lt;!-- false --> &lt;property name="numBool" value="#{true&amp;amp;&amp;amp;false}" /> &lt;!-- true --> &lt;property name="numBool" value="#{true or false}" /> &lt;!-- true --> &lt;property name="numBool" value="#{true||false}" /> &lt;!-- false --> &lt;property name="numBool" value="#{not true}" /> &lt;!-- false --> &lt;property name="numBool" value="#{!true}" /> 条件运算符：?true:false&lt;!-- 真 --> &lt;property name="numStr" value="#{(10>3)?'真':'假'}" /> 正则表达式：matches&lt;!-- true --> &lt;property name="numBool" value="#{user.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,4}'}" /> 调用静态方法或静态属性 通过 T() 调用一个类的静态方法，它将返回一个 Class Object，然后再调用相应的方法或属性： &lt;!-- 3.141592653589793 --> &lt;property name="PI" value="#{T(java.lang.Math).PI}" /> 获取容器内的变量，可以使用“#bean_id”来获取。有两个特殊的变量，可以直接使用。this 使用当前正在计算的上下文root 引用容器的root对象 String result2 = parser.parseExpression("#root").getValue(ctx, String.class); String s = new String("abcdef"); ctx.setVariable("abc",s); //取id为abc的bean，然后调用其中的substring方法 parser.parseExpression("#abc.substring(0,1)").getValue(ctx, String.class); 方法调用 与Java代码没有什么区别，可见上面的例子 可以自定义方法，如下： Method parseInt = Integer.class.getDeclaredMethod("parseInt", String.class); ctx.registerFunction("parseInt", parseInt); ctx.setVariable("parseInt2", parseInt); “registerFunction”和“setVariable”都可以注册自定义函数，但是两个方法的含义不一样，推荐使用“registerFunction”方法注册自定义函数。 Elvis运算符 是三目运算符的特殊写法，可以避免null报错的情况 name != null? name : "other" //简写为： name?:"other" 安全保证 为了避免操作对象本身可能为null，取属性时报错，定义语法 语法： “对象?.变量|方法” list?.length 直接使用java代码new/instance of 此方法只能是java.lang 下的类才可以省略包名 Expression exp = parser.parseExpression("new Spring('Hello World')"); 集合定义 使用“{表达式，……}”定义List，如“{1,2,3}” 对于字面量表达式列表，SpEL会使用java.util.Collections.unmodifiableList 方法将列表设置为不可修改。 对于列表中只要有一个不是字面量表达式，将只返回原始List， //不会进行不可修改处理，也就是可以修改 List&lt;list> result3 = parser.parseExpression(expression3).getValue(List.class); result3.get(0).set(0, 1); List result1 = parser.parseExpression(“{1,2,3}”).getValue(List.class); 集合访问SpEL目前支持所有集合类型和字典类型的元素访问 语法：“集合[索引]”、“map[key]” EvaluationContext context = new StandardEvaluationContext(); //即list.get(0) int result1 = parser.parseExpression("{1,2,3}[0]").getValue(int.class); //list获取某一项 Collection&lt;Integer> collection = new HashSet&lt;Integer>(); collection.add(1); collection.add(2); context.setVariable("collection", collection); int result2 = parser.parseExpression("#collection[1]").getValue(context, int.class); //map获取 Map&lt;String, Integer> map = new HashMap&lt;String, Integer>(); map.put("a", 1); context.setVariable("map", map); int result3 = parser.parseExpression("#map['a']").getValue(context, int.class); 集合修改可以使用赋值表达式或Expression接口的setValue方法修改； //赋值语句 int result = parser.parseExpression("#array[1] = 3").getValue(context, int.class); //serValue方法 parser.parseExpression("#array[2]").setValue(context, 4); 集合选择 通过一定的规则对及格进行筛选，构造出另一个集合 语法：“(list|map).?[选择表达式]” 选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中 parser.parseExpression("#collection.?[#this>2]").getValue(context, Collection.class); 上面的例子从数字的collection集合中选出数字大于2的值，重新组装成了一个新的集合 上面的例子从数字的collection集合中选出数字大于2的值，重新组装成了一个新的集合 根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素 语法：“SpEL使用“（list|map）.![投影表达式]” public class Book { public String name; //书名 public String author; //作者 public String publisher; //出版社 public double price; //售价 public boolean favorite; //是否喜欢 } public class BookList { @Autowired protected ArrayList list = new ArrayList() ; protected int num = 0; } 将BookList的实例映射为bean：readList，在另一个bean中注入时，进行投影 //从readList的list下筛选出favorite为true的子集合，再将他们的name字段投为新的list @Value("#{list.?[favorite eq true].![name]}") private ArrayList&lt;String> favoriteBookName; Bean引用：SpEL支持使用“@”符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现； @Test public void testBeanExpression() { ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(); ctx.refresh(); ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new BeanFactoryResolver(ctx)); Properties result1 = parser.parseExpression("@systemProperties").getValue(context, Properties.class); Assert.assertEquals(System.getProperties(), result1); }]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架]]></title>
    <url>%2F2019%2F01%2F15%2Fspring-kuang-jia%2F</url>
    <content type="text"><![CDATA[Spring框架1.Spring简介: 为从大小与开销两方面而言Spring都是轻量的 通过控制反转（IoC）的技术达到松耦合的目的 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发 包含并管理应用对象的配置和生命周期，所以spring是一种容器 将简单的组件配置、组合成为复杂的应用，这个意义上是框架 2.spring的核心 控制反转（IoC）和面向切面编程（AOP） 1.什么事控制反转呢？​ 控制反转loC主要是用来解决耦合的问题的，一个类直接依赖另一个类，这样耦合性是很高的，但是我们可以通过创建一个工厂模式，对象创建另一个对象的时候通过查找map容器，如果map容器不存在，就在本地配置文件中查找类的类名来获取类。这样就把类与类之间的关系转化为了类与工厂与类的关系，从而解决了耦合性的问题。 控制反转loC演示首先创建两个类 Main类是主方法类用来调用Demo方法类里面的toString方法，通过loC控制反转调用 在resources包下面创建一个xml配置文件 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;!-- id表示调用这个类的时候写的类名，class表示类的包名加类名,其中Java目录下的表示根目录 使用注解@Component 类型首字母要小写 --> &lt;bean id="Demo" class="Demo"> &lt;!-- collaborators and configuration for this bean go here --> &lt;/bean> &lt;/beans> //ApplicationContext接口的实现对象ClassPathXmlApplicationContext来获取容器 ApplicationContext ac= new ClassPathXmlApplicationContext("bean.xml"); //通过反射机制获取Bean对象 Demo de=ac.getBean("Demo",Demo.class); de.toString(); ApplicationContext接口的继承关系 ApplicationContext:读取配置文件的时候立即加载对象（单例对象适用，经常使用）BeanFatory:遇见getBean的时候才加载对象（多例对象适用）ApplicationConxt接口常用的实现类ClassPathXmlAppliationContext:加载类路径下的配置文件，要求配置文件必须在类路径下FileSystemXmlApplicationContext:加载磁盘任意路径下的配置文件AnnotationConfigAppliationContext:读取注解创建容器3.spring的核心容器Beans(管理bean)Core(核心)Context(上下文（配置文件）)Expresslon Language(SpEl表达式)3.SpringBeanSpringBean创建的三种方式&lt;!--第一种创建方式id表示调用这个类的时候写的类名，class表示类的包名加类名,其中Java目录下的表示根目录--> &lt;!--使用默认无参构造方法创建--> &lt;bean id="Demo" class="Demo">&lt;/bean> &lt;!--第二种，使用普通工厂中的方法创建对象,并存入spring容器--> &lt;!--创建Fatory工厂类--> &lt;bean id="Fatory" class="DeFatorymo"> &lt;/bean> &lt;!--获得Service类通过Fatory工厂里面的getService方法--> &lt;bean id="Service" fatory-bean="Fatory" fatory-method="getService">&lt;/bean> &lt;!--第三种，使用工厂中静态方法创建对象，并存入spring容器--> &lt;bean id="Service" class="Service" facctory-method="getService">&lt;/bean> SpringBean的作用范围和生存周期Bean标签的scope属性可以指定对象的作用范围 singleton单例对象（默认）解析xml出生，也就是和容器一样 prototype多例对象 ，使用时出生，当对象长时间不使用，而且没有对象引用 的时候被垃圾回收器销毁 request作用于web应用的请求范围 session作用于web的应用的会话范围 global-session:作用于集群环境的会话范围，全局的会话范围 4.Spring注入概述（经常变化的数据不适合注入）​ 平常的Java开发中，程序员在某个类中需要依赖其它类的方法。 ​ 通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理。 ​ Spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过Spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。 ​ 依赖注入的另一种说法是”控制反转”。通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员。 ​ 而控制反转是指new实例工作不由我们程序员来做而是交给Spring容器来做。 详解如果使用注解的方式首先要在xml约束中添加 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"> &lt;!--然后告诉spring创建容器时时要扫描的包--> &lt;context:component-scan base-package="&lt;包名>">&lt;/context:component-scan> ​ 基本数据类型包装类型和String ​ 其他Bean类型（在配置文件中或者注解配置过的Bean） ​ 其他类型/集合类型 注入的方式使用构造函数​ 首先创建一个类,通过构造方法给成员变量进行赋值 import java.util.Date; public class Bean { private int age; private String name; private Date newDate; @Override public String toString() { return "Bean{" + "age=" + age + ", name='" + name + '\'' + ", newDate=" + newDate + '}'; } private Bean(int age, String name, Date newDate){ this.age=age; this.name=name; this.newDate=newDate; } } XML里面这样配置 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;!-- constructor-arg标签属性详解 ------------------------------------------------- 查找构造方法属性： type通过指定数据类型进行查找 index通过指定下标进行查找，下标从0开始 name通过名字进行查找（最常用的方式） --------------------------------------------------- 赋值： value给对象进行赋值，非String类型能自动转换，特殊类型需要使用rel rel指定其他Ioc核心容器里面的bean对象进行赋值 --------------------------------------------------- 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功 弊端：改变了bean实例化的方式，使我们在创建对象时，如果用不大这些数据，也必须提供 --> &lt;bean id="Bean" class="Bean"> &lt;constructor-arg name="age" value="12">&lt;/constructor-arg> &lt;constructor-arg name="name" value="哈哈哈哈">&lt;/constructor-arg> &lt;constructor-arg name="newDate" ref="newDate">&lt;/constructor-arg> &lt;/bean> &lt;bean id="newDate" class="java.util.Date">&lt;/bean> &lt;/beans> 使用set方法（更常用）首先创建如下Bean对象 给里面的成员属性进行赋值 import java.util.Date; public class Bean { private int age; private String name; private Date newDate; public void setAge(int age) { this.age = age; } public void setName(String name) { this.name = name; } public void setNewDate(Date newDate) { this.newDate = newDate; } @Override public String toString() { return "Bean{" + "age=" + age + ", name='" + name + '\'' + ", newDate=" + newDate + '}'; } } 然后XML配置文件写 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;bean id="Bean" class="Bean"> &lt;!-- constructor-arg标签属性详解 ------------------------------------------------- 查找构造方法属性： name通过set方法名字进行查找 --------------------------------------------------- 赋值： value给对象进行赋值，非String类型能自动转换，特殊类型需要使用rel rel指定其他Ioc核心容器里面的bean对象进行赋值 --------------------------------------------------- 优势：创建对象的时候没有明显的限制，可以直接使用默认的无参构造方法进行构建 弊端：如果某个成员变量必须被赋值，则获取对象是有可能set方法没有被执行 --> &lt;property name="age" value="12">&lt;/property> &lt;property name="name" value="哈哈哈哈">&lt;/property> &lt;property name="newDate" ref="newDate">&lt;/property> &lt;/bean> &lt;bean id="newDate" class="java.util.Date">&lt;/bean> &lt;/beans> 针对复杂的集合数据类型进行set注入Bean类 import java.util.Arrays; import java.util.Date; import java.util.List; import java.util.Map; public class Bean { private String[] strs; private List&lt;String> list; private Map&lt;String, String> map; @Override public String toString() { return "Bean{" + "strs=" + Arrays.toString(strs) + ", list=" + list + ", map=" + map + '}'; } public void setMap(Map&lt;String, String> map) { this.map = map; } public void setStrs(String[] strs) { this.strs = strs; } public void setList(List&lt;String> list) { this.list = list; } } XML配置 &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"> &lt;bean id="Bean" class="Bean"> &lt;property name="strs"> &lt;array> &lt;value>aaa&lt;/value> &lt;value>BBB&lt;/value> &lt;value>CCC&lt;/value> &lt;/array> &lt;/property> &lt;property name="list"> &lt;list> &lt;value>aaa&lt;/value> &lt;value>BBB&lt;/value> &lt;value>CCC&lt;/value> &lt;/list> &lt;/property> &lt;property name="map"> &lt;map> &lt;entry key="123" value="aaa">&lt;/entry> &lt;/map> &lt;/property> &lt;/bean> &lt;/beans> 使用注解代替xml配置的注解@Configuration：说明当前类是一个配置类​ @ComponentScan:指定spring在创建容器时要扫描的包 ​ 属性 value和basePackages作用一样 ​ 等同于在xml中的: &lt;context:component-scan base-package="&lt;类路径>">&lt;/context:component-scan> 当使用了AnnotationConfigApplicationContext();这个类的时候可以不使用这个标签，但是如果有多个配置类，需要在ComponentScan注解中包含另一个配置类，并且另一个配置类必须使用Configuration注解来表示他是一个注解类，或者使用import来避免使用Configuration注解这个问题 演示 package com.cofing; import org.springframework.beans.factory.annotation.Configurable; import org.springframework.context.annotation.ComponentScan; //首先要声明当前类是一个注解类 @Configurable @ComponentScan("类路径") public class Config { } @import导入其他配置类 （有这个注解的配置类也被称为父配置类，那么被包含的配置类被称为子配置类）如果使用AnnotationConfigApplicationContext();导入了主配置类，那么可以通过在主配置类上面填写@import导入其他配置类，而且此时不能被@ComponentScan注解替代 创建对象的注解@Component 作用把当前类对象存入spring容器中​ 属性：value,用于指定bean的id，当我们不写的时候，默认值是当前类名的首字小写 和上面作用一样Controller:用在表现层 Service:用在业务层 Repository:用在持久层 注入数据的注解@Autowired:​ 作用：自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，或者和他的接口父类类型匹配，就注入成功，如果有多个匹配类型按照名字相同的进行匹配，否则匹配失败。 出现位置:可以是变量上，也可以是方法上细节：在使用注解注入时，set方法就不说必须的了。@Qualifier:在按照类型注入的基础之上再按照名称注入，给类成员注入时不能单独使用，给方法参数注入是可以单独使用​ 属性： value:要注入bean的id @Resource: 可以单独使用​ 属性为：name直接按照id进行注入 上面的三个注入都只能对其他bean类型进行注入，不能对基本类型和String类型进行注入，而且集合类型只能使用xml进行注入。 Autowired和Resource区别 Resource是jdk1.6提供的，Autowired是spring框架提供的 Resource因为是jdk提供的标准，所以可移植性更强，但是Autowired的功能更强大 @Value作用，用于注入基本类型和String类型的数据而且可以使用spEL表达式@Bean:作用把当前方法的返回值作为bean对象存入spring的ioc容器中​ 属性：name用于指定bean的id,当不写时，默认值是当前方法的名称 改变作用范围的注解@Scope :用于指定bean的作用范围 不声明默认是单例的​ 属性:value:指定范围的取值，常用取值:singleton prototype ​ 和生命周期相关的注解@PreDestroy​ 作用:用于指定销毁方法 @PostConstruct​ 作用:用于自定初始化方法 @PropertySource 作用:用来指定properties文件的位置（然后@Value标签就可以用spEL表达式去获取值）​ 属性value：指定文件的名称和路径 ​ 关键字classpath表示类路径下 JAVA的动态代理代理模式 （可以进一步增强代码的复用性）​ 代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。​ 按照代理的创建时期，代理类可以分为两种。 ​ 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。​ 动态代理：在程序运行时，运用反射机制动态创建而成。 接下来代码演示 Main.java import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class Main { public static void main(String[] args) { final Factory fatory=new Factory(); //消费者通过动态代理购买商品 //ClassLoader:类加载器，加载代理对象的字节码，和被代理对象相同的类加载器 //Class[] 让代理对象和被代理对象有相同方法，固定写法 //InvoactionHandler 用于代理的方法 IProxy proxy=(IProxy) Proxy.newProxyInstance(fatory.getClass().getClassLoader(), fatory.getClass().getInterfaces(), new InvocationHandler() { /** * 执行被代理对象的热河接口和方法都会经过该方法 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行方法所需要的参数 * @return 和配代理对象具有相同的返回值 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(method.getName().equals("salfMoney")==true){ System.out.print("代理商坑人了"); } return method.invoke(fatory,args); } }); proxy.salfMoney(5000); } } Factory.java /** * 生产厂家,被代理类 * 要想使用动态代理模式必须要继承一个接口 */ public class Factory implements IProxy{ public void salfMoney(float money) { System.out.print("卖了"+money+"元"); } } Iproxy.java /** * 代理接口 */ public interface IProxy { //销售商品接口 public void salfMoney(float money); } AOP编程实例Spring中的AOP，就是通过配置的方式实现的 相关术语： Joinpoin（连接点）：所谓连接点就是值那些被拦截到的点。在spring中，这些点指的是方法，因为spring只支持方法类型的连接点。所有的方法都是连接点 Pointcut（切入点）：所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。只有被增强的方法才是切入点 Advice（通知/增强）：所谓通知是指拦截到Joinpoint之后要做的事情就是通知 通知类型：前置通知、后置通知、异常通知、最终通知、环绕通知 Introduction（引介）：引介是一种特殊情况下的通知，在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或Field Target（目标对象）：代理的目标对象 Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程 spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入 Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类 Aspect（切面）：是切入点和通知（引介）的结合 ​ 使用spring Aop编程除了要加入Spring的spring-aop jar包，还要加入aspectjrt.jar，aspectjweaver.jar，以及aopalliance_1.0.jar 以下两个是与aspectj相关的包,用来支持切面编程的 aspectjrt包是aspectj的runtime包 aspectjweaver是aspectj的织入包 Cglib包是用来动态代理用的,基于类的代理 1.切入点表达式​ 例如：dao包下public void addAccount(int i);和dao包下的public int reAccount(); ​ 手写访问修饰符可以省略不写 //匹配public void addAccount(int i)可以写成 void addAccount(int) 1.返回值类型可以使用通配符* 表示任意返回值2.包名必须用·进行分割 比如 * . * . *形式3.或者使用* .. 匹配多级目录4.方法名称也可以使用通配符 *5.参数列表可以使用float之类的基本数据类型，如果是复杂数据类型需要些包名加类名如果参数列表使用 * 进行通配符匹配只能匹配有参数的方法，要想匹配所有参数列表的需要使用 ..进行匹配2. 4种通知类型&lt;aop:before method="通知的方法名" pointcut="execution(包名.类名.方法名)">&lt;/aop:before>&lt;!--前置通知--> &lt;aop:after-returning method="通知的方法名" pointcut="execution(包名.类名.方法名)">&lt;/aop:after-returning>&lt;!--后置通知--> &lt;aop:after-throwing method="通知的方法名" pointcut="execution(包名.类名.方法名)">&lt;/aop:after-throwing>&lt;!--异常通知--> &lt;aop:after method="通知的方法名" pointcut="execution(包名.类名.方法名)">&lt;/aop:after>&lt;!--最终通知--> 环绕通知是spring框架为我们提供的一种可以做在代码中手动控制增强方法合适执行的一种方式如果觉得配置execution比较麻烦可以使用切入点表达式解决通知方法的执行顺序前置通知 切入方法 后置通知 最终通知 项目目录通过xml的方式实现AOP开发步骤​ 1.把通知bean交给spring来管理（LogMessage类） ​ 2.使用aop:config标签表明开始配置切面 ​ 3.使用aop:aspet标签表明配置切面 ​ id属性，是给切面提供一个唯一标识 ​ ref属性：是指定通知类bean的id ​ 4.在aop:aspet标签的内部使用对应标签来配置通知的类型 ​ aop:before标识前置通知 ​ method属性，用于指定Logger类中那个方法是前置通知 pom.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"> &lt;modelVersion>4.0.0&lt;/modelVersion> &lt;groupId>AOPDmo&lt;/groupId> &lt;artifactId>AOPDmo&lt;/artifactId> &lt;version>1.0-SNAPSHOT&lt;/version> &lt;packaging>jar&lt;/packaging> &lt;dependencies> &lt;dependency> &lt;groupId>org.springframework&lt;/groupId> &lt;artifactId>spring-context&lt;/artifactId> &lt;version>5.0.2.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.aspectj&lt;/groupId> &lt;artifactId>aspectjweaver&lt;/artifactId> &lt;version>1.8.7&lt;/version> &lt;/dependency> &lt;/dependencies> &lt;/project> LogMessage.java 用于增强service类的前置 package log; /** * 打印日志类 * 用来增强其他类 */ public class LogMessage { public void logMessage(){ System.out.print("执行了争抢方法的内容"); } } Iservice接口 package service; /** * service接口 */ public interface Iservice { public void addAccout(); public void deletAccount(int i); } Service类 package service; public class Service implements Iservice{ public void addAccout() { System.out.print("添加了账户"); } public void deletAccount(int i) { System.out.print("删除了账户信息"); } } springconfig.xml &lt;?xml version="1.0" encoding="UTF-8"?> &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"> &lt;bean id="logmessage" class="log.LogMessage">&lt;/bean> &lt;bean id="service" class="service.Service">&lt;/bean> &lt;!--开始aop配置--> &lt;aop:config> &lt;!--开始配置切面--> &lt;aop:aspect id="aoplog" ref="logmessage"> &lt;!--进行前置切面配置--> &lt;aop:before method="logMessage" pointcut="execution(public void service.Service.addAccout())">&lt;/aop:before> &lt;/aop:aspect> &lt;/aop:config> &lt;/beans> main.java import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext; import service.Iservice; import service.Service; public class Main { public static void main(String[] args) { ApplicationContext ac=new ClassPathXmlApplicationContext("springconfig.xml"); //注意--必须是service的接口类型， Iservice ser= (Iservice) ac.getBean("service"); ser.addAccout(); } }]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql基础]]></title>
    <url>%2F2018%2F10%2F01%2Fmysql-ji-chu-ru-men%2F</url>
    <content type="text"><![CDATA[一、语法select 查询列表from 表名; 二、特点1、查询列表可以是字段、常量、表达式、函数，也可以是多个2、查询结果是一个虚拟表 三、示例1、查询单个字段select 字段名 from 表名; 2、查询多个字段select 字段名，字段名 from 表名; 3、查询所有字段select * from 表名 4、查询常量select 常量值;注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要 5、查询函数select 函数名(实参列表);6、查询表达式select 100/1234; 7、起别名①as②空格 8、去重select distinct 字段名 from 表名; 9、+作用：做加法运算select 数值+数值; 直接运算select 字符+数值;先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算select null+值;结果都为null 10、【补充】concat函数功能：拼接字符select concat(字符1，字符2，字符3,…); 11、【补充】ifnull函数功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值select ifnull(commission_pct,0) from employees; 12、【补充】isnull函数功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0 一、语法select 查询列表from 表名where 筛选条件 二、筛选条件的分类1、简单条件运算符 &lt; = &lt;&gt; != &gt;= &lt;= &lt;=&gt;安全等于2、逻辑运算符&amp;&amp; and|| or! not3、模糊查询like:一般搭配通配符使用，可以判断字符型或数值型通配符：%任意多个字符，_任意单个字符 between andinis null /is not null：用于判断null值 is null PK &lt;=&gt; 普通类型的数值 null值 可读性is null × √ √&lt;=&gt; √ √ × 一、语法select 查询列表from 表where 筛选条件order by 排序列表 【asc}desc】 二、特点1、asc ：升序，如果不写默认升序 desc：降序 2、排序列表 支持 单个字段、多个字段、函数、表达式、别名 3、order by的位置一般放在查询语句的最后（除limit语句之外） 一、概述功能：类似于java中的方法好处：提高重用性和隐藏实现细节调用：select 函数名(实参列表); 二、单行函数1、字符函数concat:连接substr:截取子串upper:变大写lower：变小写replace：替换length：获取字节长度trim:去前后空格lpad：左填充rpad：右填充instr:获取子串第一次出现的索引 2、数学函数ceil:向上取整round：四舍五入mod:取模floor：向下取整truncate:截断rand:获取随机数，返回0-1之间的小数 3、日期函数now：返回当前日期+时间year:返回年month：返回月day:返回日date_format:将日期转换成字符curdate:返回当前日期str_to_date:将字符转换成日期curtime：返回当前时间hour:小时minute:分钟second：秒datediff:返回两个日期相差的天数monthname:以英文形式返回月 4、其他函数version 当前数据库服务器的版本database 当前打开的数据库user当前用户password(‘字符’)：返回该字符的密码形式md5(‘字符’):返回该字符的md5加密形式 5、流程控制函数①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2②case情况1case 变量或表达式或字段when 常量1 then 值1when 常量2 then 值2…else 值nend ③case情况2casewhen 条件1 then 值1when 条件2 then 值2…else 值nend 三、分组函数1、分类max 最大值min 最小值sum 和avg 平均值count 计算个数 2、特点①语法select max(字段) from 表名; ②支持的类型sum和avg一般用于处理数值型max、min、count可以处理任何数据类型 ③以上分组函数都忽略null④都可以搭配distinct使用，实现去重的统计select sum(distinct 字段) from 表;⑤count函数count(字段)：统计该字段非空值的个数count(*):统计结果集的行数案例：查询每个部门的员工个数1 xx 102 dd 203 mm 204 aa 405 hh 40 count(1):统计结果集的行数 效率上：MyISAM存储引擎，count()最高InnoDB存储引擎，count()和count(1)效率&gt;count(字段) ⑥ 和分组函数一同查询的字段，要求是group by后出现的字段 一、语法select 分组函数，分组后的字段from 表【where 筛选条件】group by 分组的字段【having 分组后的筛选】【order by 排序列表】 二、特点 使用关键字 筛选的表 位置分组前筛选 where 原始表 group by的前面分组后筛选 having 分组后的结果 group by 的后面 一、含义当查询中涉及到了多个表的字段，需要使用多表连接select 字段1，字段2from 表1，表2,…; 笛卡尔乘积：当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接如何解决：添加有效的连接条件 二、分类按年代分类： sql92： 等值 非等值 自连接 也支持一部分外连接（用于oracle、sqlserver，mysql不支持） sql99【推荐使用】 内连接 等值 非等值 自连接 外连接 左外 右外 全外（mysql不支持） 交叉连接三、SQL92语法1、等值连接语法： select 查询列表 from 表1 别名,表2 别名 where 表1.key=表2.key 【and 筛选条件】 【group by 分组字段】 【having 分组后的筛选】 【order by 排序字段】 特点： ① 一般为表起别名 ②多表的顺序可以调换 ③n表连接至少需要n-1个连接条件 ④等值连接的结果是多表的交集部分 2、非等值连接语法：​ select 查询列表​ from 表1 别名,表2 别名​ where 非等值的连接条件​ 【and 筛选条件】​ 【group by 分组字段】​ 【having 分组后的筛选】​ 【order by 排序字段】 3、自连接语法：​ select 查询列表​ from 表 别名1,表 别名2​ where 等值的连接条件​ 【and 筛选条件】​ 【group by 分组字段】​ 【having 分组后的筛选】​ 【order by 排序字段】 四、SQL99语法1、内连接语法：select 查询列表from 表1 别名【inner】 join 表2 别名 on 连接条件where 筛选条件group by 分组列表having 分组后的筛选order by 排序列表limit 子句; 特点：①表的顺序可以调换②内连接的结果=多表的交集③n表连接至少需要n-1个连接条件 分类：等值连接非等值连接自连接 2、外连接语法：select 查询列表from 表1 别名left|right|full【outer】 join 表2 别名 on 连接条件where 筛选条件group by 分组列表having 分组后的筛选order by 排序列表limit 子句; 特点：①查询的结果=主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null②left join 左边的就是主表，right join 右边的就是主表 full join 两边都是主表③一般用于查询除了交集部分的剩余的不匹配的行 3、交叉连接语法：select 查询列表from 表1 别名cross join 表2 别名; 特点：类似于笛卡尔乘积 一、含义嵌套在其他语句内部的select语句称为子查询或内查询，外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多外面如果为select语句，则此语句称为外查询或主查询 二、分类1、按出现位置select后面： 仅仅支持标量子查询from后面： 表子查询where或having后面： 标量子查询 列子查询 行子查询exists后面： 标量子查询 列子查询 行子查询 表子查询 2、按结果集的行列标量子查询（单行子查询）：结果集为一行一列列子查询（多行子查询）：结果集为多行一列行子查询：结果集为多行多列表子查询：结果集为多行多列 三、示例where或having后面1、标量子查询案例：查询最低工资的员工姓名和工资①最低工资select min(salary) from employees ②查询员工的姓名和工资，要求工资=①select last_name,salaryfrom employeeswhere salary=( select min(salary) from employees); 2、列子查询案例：查询所有是领导的员工姓名①查询所有员工的 manager_idselect manager_idfrom employees ②查询姓名，employee_id属于①列表的一个select last_namefrom employeeswhere employee_id in( select manager_id from employees); 一、应用场景当要查询的条目数太多，一页显示不全 二、语法select 查询列表from 表limit 【offset，】size; 注意：offset代表的是起始的条目索引，默认从0卡死size代表的是显示的条目数 公式：假如要显示的页数为page，每一页条目数为sizeselect 查询列表from 表limit (page-1)*size,size; 一、含义union：合并、联合，将多次查询结果合并成一个结果 二、语法查询语句1union 【all】查询语句2union 【all】… 三、意义1、将一条比较复杂的查询语句拆分成多条语句2、适用于查询多个表的时候，查询的列基本是一致 四、特点1、要求多条查询语句的查询列数必须一致2、要求多条查询语句的查询的各列类型、顺序最好一致3、union 去重，union all包含重复项 语法：select 查询列表 ⑦from 表1 别名 ①连接类型 join 表2 ②on 连接条件 ③where 筛选 ④group by 分组列表 ⑤having 筛选 ⑥order by排序列表 ⑧limit 起始条目索引，条目数; ⑨]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++语言位运算基本用法和骚操作]]></title>
    <url>%2F2018%2F08%2F27%2Fcc-yu-yan-wei-yun-suan-ji-ben-yong-fa-he-sao-cao-zuo%2F</url>
    <content type="text"><![CDATA[C/C++语言位运算基本用法和骚操作前言:​ 前几天打了徐州ACM的网络模拟赛，其中有个题觉得很容易做出来，但是死活都是卡时间和卡内存，于是乎就百度了一下题解（╮(╯▽╰)╭手动狗头），结果学到了一个新的算法，叫做区间数组，然后就学了学，结果学的云里雾里的，其中区间数组核心的一个确定区间的函数 lowbit(int x){ return x&amp;(-x); } 更是云里雾里。然后就结束今天的新的吧。 位运算基本用法 操作符 作用 解释 &amp; 位AND 如果 x 和 y 都为 1，则得到 1；如果 x 或 y 任何一个为 0，或都为0，则得到 0 | 位OR 如果 x 或 y 为 1，或都为 1，则得到 1；如果 x 和 y 都为 0，则得到 0 ^ 位 XOR 如果 x 或 y 的值不同，则得到 1；如果两个值相同，则得到 0 ~ 位 NOT（I的补码） 如果 x 为 0，则得到 1，如果 x 是 1，则得到 0 运算符 意义 示例 结果 &lt;&lt; 向左移位 x&lt;&lt;y x 的每个位向左移动 y 个位 &gt;&gt; 向右移位 x&gt;&gt;y x 的每个位向右移动 y 个位 骚操作判断一个整形最后一位是否是1(用来判断奇偶数)if(n&amp;1){ printf("是奇数"); } ### 演示​ 将输入的一个n（int类型整数）转换成二进制小数（n&gt;=0） #include&lt;iostream&gt; #include&lt;stack&gt; using namespace std; int main(void) { int n; while(true) { cin&gt;&gt;n; stack&lt;int&gt; sta; while(n&gt;0)//输出二进制末尾小数打印出并且进行移位 { if(n&amp;1) sta.push(1); else sta.push(0); n&gt;&gt;=1; } while(!sta.empty()) { cout&lt;&lt;sta.top(); sta.pop(); } cout&lt;&lt;endl; } return 0; }实现两个数互换int num1=10; int num2=10; num1=num1^num2; num2=num1^num2; num1=num1^num2;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow入门教程]]></title>
    <url>%2F2018%2F05%2F27%2F1.tensorflow-ji-ben-jie-shao%2F</url>
    <content type="text"><![CDATA[1.tensorflow基本介绍1.TensorFlow 简介​ TensorFlow是一个基于数据流编程的符号数学系统，被广泛应用于各类机器学习算法的编程实现，其前身是谷歌的神经网络算法库 2.TensorFlow基本术语张量（tensor）：​ 张量就是基于向量和矩阵的推广，通俗点理解就是可以将标量看成零阶张量，向量看成一阶张量，矩阵就是二阶张量。 图（graph）​ 代表着一段内存地址，也可以理解成所有的节点和张量的集合 节点（op）​ 每个运算和张量都是一个节点，每个节点就是一个op 会话(Session)​ 会话的作用就是执行图的计算，众所周知在TensorFlow中会话之前的都是图的定义或者是op的定义，只能表示关系不参与计算，所以需要用会话让图真正的执行起来 2.张量（tensor）的使用以及注意事项1.张量的基本概念​ 张量就是基于向量和矩阵的推广，通俗点理解就是可以将标量看成零阶张量，向量看成一阶张量，矩阵就是二阶张量。 2.张量的数据类型 数据类型 Python类型 描述 DT_FLOAT tf.float32 32位浮点数 DT_DOUBLE tf.float64 64位浮点数（精度和float32精度一致） DT_INT64 tf.int64 64位有符号整数 DT_INT32 tf.int32 32位有符号整数（精度和int32精度一致） DT_INT13 tf.int16 16位有符号整数 DT_INT8 tf.int8 8位有符号整数 DT_STRING tf.string 可变长度的字节数组，每一个张量元素都是一个字节数组。 DT_BOOL tf.bool 布尔型 DT_COMPLEX64 tf.compiex64 由两个32位浮点数组组成的复数：实数和虚数 DT_QINT32 tf.qint32 用于量化Ops的8位有符号整数 DT.QINT8 tf.qint8 用于量化Ops的8位有符号整形 DT_QUINT8 tf.quint8 用于量化Ops的8位无符号整形 3.张量的代码#导入tensorflow包，简写为tf import tensorflow as tf #定义一个3.0的常量的张量 tensor=tf.constant(3.0) #显示tensor的结果 print(tensor) #结果将会是：Tensor("Const:0", shape=(), dtype=float32) 其中Const表示进行的op操作名字shape表示张量的维度,()表示标量，（1）表示向量，（2，3）表示2行3列的张量dtype表示张量的数据类型4.生成张量创建一个常数张量tf.constant(value,dtype=None,shape=None,name=”Const”) 创建一个dtype类型的维度为shape的常数张量 固定值初始化tf.zeros([n,m],tf.dtype)获取一个n行m列的零元素tf.dtype类型的张量 tf.ones([n,m],tf.dtype)获取一个n行m列的1元素tf.dtype类型的张量 随机值初始化tf.random_normal([n,m],mean=2.0,stddev=4,seed=12)创建一个n行m列的正态分布（高斯分布）平均值为2.0，方差为4,随机种子为12张量 5.占位符tf.placeholder(dtype,shape,name) dtype张量的数据类型 shape张量的维度 [2,3]生成一个2行3列的占位符,[None,3]表示生成一个不确定行和3列的占位符 6.张量的维度调整区别如果调整的过程中生成了新的张量，这种调整称作动态调整 静态调整语法: 张量名字.set_shape([n,m]) 调整张量为n行m列 注意 静态张量只能调整之前不确定维度的张量，比如shape=[None,3]的张量 动态调整语法: tf.reshape(tensor,shape,name=None)动态张量会生成新的张量而且可以跨维度修改，也就是二阶张量可以向n阶张量改变，但是改变前和改变后其总个数必须一致，如果不知道具体维度，需要填写成-1 7.改变张量的类型tf.cast(x,dtype,name="None") 将x张量转换为dtype类型的张量 tf.cast([[1,2,3],[4,5,6],[7,8,9]],tf.float32) 将列表从整形转换成float32类型 8.张量的切片和扩展tf.concat(value,axis,name="concat") 可以将连个张量拼接起来 value 可以是个列表 axis 表示按行合并还是按列合并 0表示按行合并，1表示按列合并 import tensorflow as tf #定义两个列表 a=[[1,2,3],[4,5,6]] b=[[7,8,9],[10,11,12]] #合并两个列表 hangCat=tf.concat([a,b],axis=0) lieCat=tf.concat([a,b],axis=1) #由于上面只是搭建了个图结果并没有实际运行,接下来进行实际运行。 with tf.Session() as sess: print("行合并") print(sess.run(hangCat)) print("列合并") print(sess.run(lieCat)) #运行结果为： 行合并 [[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]] 列合并 [[ 1 2 3 7 8 9] [ 4 5 6 10 11 12]] 3.会话（Session）​ 会话的作用就是执行图的计算，众所周知在TensorFlow中会话之前的都是图的定义或者是op的定义，只能表示关系不参与计算，所以需要用会话让图真正的运行起来 基本写法with tf.Session() as sess: sess.run(fetches,feed_dict=None,options=None,run_metadata=None) 1.run方法fetches 运行ops和计算tensorfeed_dict 可选项（字典类型），提取使用占位符之后给图提供数据4.变量（Variable）​ 变量是一种特殊的张量，也是一种op,它能够被存储持久化，他们的值就是张量，默认被训练 1.变量的定义tf.Variable(initial_balue=None,name=None,trainable=True) initial_value 值 可以用正态分布或者固定生成张量的值 注意：使用变量的时候必须先运行全局初始化初始化 tf.global_variables_initializer() 例子： import tensorflow as tf #使用正态分布分配变量的值 var=tf.Variable(tf.random_normal([2,3],mean=2.0,stddev=1.0)) #开启会话并运行初始化 with tf.Session() as sess: #运行初始化(运行全局初始化变量前变量var并未被真正赋值) sess.run(tf.global_variables_initializer()) print(sess.run(var)) 4.TensorBoard 的使用和用法1.TensorBoard的简介​ TensorBoard是Tensorflow的可视化工具，它可以通过Tensorflow程序运行过程中输出的日志文件可视化Tensorflow程序的运行状态。TensorBoard和Tensorflow程序跑在不同的进程中，TensorBoard会自动读取最新的TensorFlow日志文件，并呈现当前TensorFlow程序运行的最新状态。 2.TensorBoard代码写入事务文件需要找到TensorFlow包里面的事务包summary里面的FileWriter方法 tf.summary.FileWriter(logdir,graph=None) logdir事务文件的绝对路径graph写出事务文件的图#收集变量 tf.summary.scalar(name="",tensor)#收集损失函数和准确率 tf.summary.histogram(name="",tensor)#收集高纬度的变量参数 tf.summary.image(name="",tensor)#收集输入的图片张量，能显示图片 name 表示TensorBoard里面显示的名称tensor表示要收集的张量mergin=tf.summary.merge_all()#收集所有的张量 summary=sess.run(mergin)#每次迭代都要运行的合并 FileWriter.add_summary(summary,i)#每次迭代都要添加到事务文件 3.TensorBoard的演示​ 首先代码 #通过两个变量的相加演示tensorboard的用法 import tensorflow as tf #定义两个正态分布的随机变量 var1=tf.Variable(tf.random_normal([2,3],mean=2.0,stddev=1.0)) var2=tf.Variable(tf.random_normal([2,3],mean=3.0,stddev=2.0)) #定义加法op add=tf.add(var1,var2) init_variable=tf.global_variables_initializer() #开启会话 with tf.Session() as sess: #初始化变量 sess.run(init_variable) #导出事务文件 tf.summary.FileWriter("./board",graph=sess.graph) print(sess.run(add)) ​ 然后启动命令行，打出下列命令 tensorboard --logdir="D:\code\python\tensortflow\board" ​ 之后显示命令行下面显示如下信息 TensorBoard 1.5.1 at http://By:6006 (Press CTRL+C to quit) 这就表示TensorBoard正常启动了，在浏览器输入（http://By:6006）就能正常访问tensorboard了 5.损失函数1.均方误差​ 计算方法是求预测值与真实值之间距离的平方和 ​ 公式如图所示： 6.梯度下降算法1.基本思想 梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。2.代码tf.tarin.GradientDescentOptimizer(learning_rate) learning_rate 学习率 通常填写0.0到1.0之间的浮点数6.简单的线性回归案例#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢? import tensorflow as tf #1.生成100组x的 xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist") #生成目标值y的结果 y_true=tf.matmul(xDist,[[0.7]])+0.2 #2.建立线性回归模型 #因为权重和偏置是需要不断训练改变的，所有需要定义成变量 w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w") b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b") y=tf.matmul(xDist,w)+b #损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1 loss=tf.reduce_mean(tf.square(y_true-y)) train_op=tf.train.GradientDescentOptimizer(0.1).minimize(loss) #4.定义全局变量全局初始化 init_var=tf.global_variables_initializer() #4.开启会话开始训练 with tf.Session() as sess: #运行初始化变量 sess.run(init_var) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): sess.run(train_op) print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) 7.梯度爆炸#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢? import tensorflow as tf #1.生成100组x的 xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist") #生成目标值y的结果 y_true=tf.matmul(xDist,[[0.7]])+0.2 #2.建立线性回归模型 #因为权重和偏置是需要不断训练改变的，所有需要定义成变量 w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w") b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b") y=tf.matmul(xDist,w)+b #损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1 loss=tf.reduce_mean(tf.square(y_true-y)) train_op=tf.train.GradientDescentOptimizer(1).minimize(loss) #4.定义全局变量全局初始化 init_var=tf.global_variables_initializer() #4.开启会话开始训练 with tf.Session() as sess: #运行初始化变量 sess.run(init_var) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): sess.run(train_op) print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) 1.简述​ 上述代码学习率是1，运行后就会发现权重和偏置变成了NAV，这就是梯度爆炸，也就是说学习率过大或者神经网络模型的某些原因就会导致梯度爆炸，但是学习率也不能过小，过小会得不到好的效果。 2.解决方法 重新设计神经网络 调整学习率 使用梯度阶段（在训练过程中检查和限制梯度的大小） 使用激活函数 8.模型的保存和加载1.代码saver=tf.train.Saver(var_list=None,max_to_keep=5) #在会话里面 saver.restpre(sess,"")#读取模型 saver.save(sess,"")#保存模型 var_list:自定要保持和还原的变量。他可以作为一个dict或者一个列表传进去max_to_keep:制定要保留的最近检查点文件的最大数量，创建新的文件的时候会删除比较旧的文件，默认值5“” 这个路径包含路径和文件名#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢 import tensorflow as tf import os #1.生成100组x的 xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist") #生成目标值y的结果 y_true=tf.matmul(xDist,[[0.7]])+0.2 #2.建立线性回归模型 #因为权重和偏置是需要不断训练改变的，所有需要定义成变量 w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w") b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b") y=tf.matmul(xDist,w)+b #损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1 loss=tf.reduce_mean(tf.square(y_true-y)) train_op=tf.train.GradientDescentOptimizer(0.1).minimize(loss) #收集张量 tf.summary.scalar("loss",loss) tf.summary.histogram("W",w) #合并所有的收集到的张量 margin=tf.summary.merge_all() #4.定义全局变量全局初始化 init_var=tf.global_variables_initializer() #定义保存 saver=tf.train.Saver() #4.开启会话开始训练 with tf.Session() as sess: #运行初始化变量 sess.run(init_var) # 读取模型 if os.path.exists("./model/checkpoint"): saver.restore(sess, "./model/123") #写出事务文件 fileWiter=tf.summary.FileWriter("./board",graph=sess.graph) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): summary = sess.run(margin) sess.run(train_op) fileWiter.add_summary(summary,i) # 运行变量的合并 print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) saver.save(sess,"./model/123") 2.保存的文件格式​ .data-00000-of-00001和.index文件 ​ checkpoint文件：checkpoint_dir目录下还有checkpoint文件，该文件是个文本文件，里面记录了保存的最新的checkpoint文件以及其它checkpoint文件列表。在inference时，可以通过修改这个文件，指定使用哪个model。加载restore时的文件路径名是以checkpoint文件中的“model_checkpoint_path”值决定的。 ​ 保存模型时，只会保存变量的值，placeholder里面的值不会被保存。 9.队列机制1.简述​ TensorFlow提供了专门的队列机制,专门用来处理文件读取的问题 2.代码queue=tf.FIFOQueue(capatity,dtype)#定义一个队列 capatity 队列的容量dtype队列存储的数据类型queue.dequeue()#出队列并且移除 queue.enqueue()#入队列 int=queue.enqueue_many(list)#入队一个列表元素 演示:#定义一个队列，不断出队列和入队列 import tensorflow as tf #定义一个队列 queue=tf.FIFOQueue() #添加队列元素 int=queue.enqueue_many([[1.0,2.0,3.0],]) #定义图结构 item=queue.dequeue() data=item+1 en=queue.enqueue(data) #开始执行图结构 with tf.Session() as sess: #运行添加元素结构 sess.run(int) for i in range(20): sess.run(en) for i in range(queue.size().eval()): print(queue.dequeue().eval()) 10.文件读取1.文件读取的过程1.构造文件队列2.构造阅读器3.对于每个样本进行解码4.批处理文件2.文件读取的API介绍构造文件队列tf.tarin.string_inpput_producer(string_tensor,shuffle=True) string_tensor 含有文件名的一阶张量（包含路径以及文件名的列表）shuffle 是否乱序 默认乱序num_epochs 过几遍数据，默认无限过数据构造文件阅读器 所有阅读器解码出来形状都是不固定的，注意后边进行形状固定 要根据文件类型选择对应的文件阅读区 每个read方法返回key，和value参数，其中key表示文件名称，value表示每个样本 文本文件和CSV文件: class reader=tf.TextLineReader()#构造文件阅读器 reader.read(file_queue)#读取一个样本 文本文件阅读器，默认按行读取，（因为对于csv文件和文本文件来说，一行就是一个样本）return 返回阅读器实例read(file_queue)file_queue 从队列里面读取内容二进制文件阅读器class reader=tf.FixedLengthRecordReader(record_bytes)#构造文件阅读器 reader.read(file_queue)#读取一个样本文件 读取每个样本是按固定数量的字节读取的二进制文件record_bytes:整形，指定每次读取的字节数return 返回阅读器实例图片文件阅读器class reader=tf.WholeFileReader()#构造图片文件阅读器 reader.read(file_queue)#读取一个图片样本 每个样本进行解码CSV文件解码tf.decode_csv(value,record_defaults=None) value表示待解码的内容record_defaults 表示每个样本如何解码，并且缺失的时候的默认值 [[1]]表示一个样本按整形解码，缺失的时候为1，[[“None”],[1.0]] 表示样本有两个第一个按string类型解码，缺失的时候是None,第二个按float类型解码，丢失按1.0处理图片文件解码tf.image.decode_jpeg(contents) #将JPEG编码的图像解码为uint8的张亮 #return:uint8张量3-D形状[height,width,hannels] tf.image.decode_png(contents) #将PNG图片的图像解码为uint8或者uint16的张量 #return:张量类型，3-D形状[height,width,hannels] 图片文件缩放 tf.image.resize_images(images,size) images:4-D形状[batch,height,width,channels]或者3-D的形状的张量[height,width,channels] size图片的新尺寸，new_height,new_width 管道批处理文件#批处理 batch_size表示每批的数量，num_threads进行的线程数量，capacity批处理管道的容量 ones,twos=tf.train.batch([one,two],batch_size=6,num_threads=1,capacity=9) 3.文件读取的简单演示#1.构造文件队列（路径加文件名） #2.构造文件阅读器 #3.按每个样本解码（转化为张量 ） #4.构造批处理 ###在同目录下有个data文件夹，里面的csv文件里面都有两行且都是string类型 import tensorflow as tf import os #找到对应的文件目录获取文件路径加列表 def fileRead(path): fileName=os.listdir(path) filePath=[os.path.join(path,file) for file in fileName] return filePath def csvRead(fileList): #构造文件队列 fileQueue=tf.train.string_input_producer(fileList) #构造阅读器 reader=tf.TextLineReader() key,value=reader.read(fileQueue) #对文件进行解码 #设定每行的类型以及每行的默认值 cord=[["None"],["None"]] one,two=tf.decode_csv(value,record_defaults=cord) #批处理 batch_size表示每批的数量，num_threads进行的线程数量，capacity批处理管道的容量 ones,twos=tf.train.batch([one,two],batch_size=6,num_threads=1,capacity=9) return ones,twos if __name__ == "__main__": fileList=fileRead("./data") one,two=csvRead(fileList) with tf.Session() as sess: #定义一个线程协调器 coord=tf.train.Coordinator() #开启一个线程 thread=tf.train.start_queue_runners(sess,coord=coord) print(sess.run([one,two])) #回收子线程 coord.request_stop() coord.join(thread) 图片文件的读取简单演示#读取当前文件夹下面的data目录下面所有的jpg格式图片的信息 #步骤 # 1.获取path文件下面的所有图片的全路径列表 # 2.构造文件队列 # 3.构造图片阅读器 # 4.图片解码 # 5.图片缩放 # 6.图片调整维度 # 7.批处理 import tensorflow as tf import os #读取path目录下所有的图片信息 def getPath(path): fileNames=os.listdir(path) filePath=[os.path.join(path,fileName) for fileName in fileNames] return filePath #读取图片并进行批处理 def readImg(filePathList): #1.构造文件队列 fileQueue=tf.train.string_input_producer(filePathList) #1.构造图片阅读器 reader=tf.WholeFileReader() key,value=reader.read(fileQueue) print("构造完阅读器",value) #3.图片解码 image=tf.image.decode_jpeg(value) print("解码",image) #4.图片缩放 reImage=tf.image.resize_images(image,[200,200]) print("图片放缩后",reImage) #5.图片定型 静态调整 reImage.set_shape([200,200,3]) print("图片静态调整后",reImage) #文件批处理 jpg=tf.train.batch([reImage],batch_size=5,num_threads=2,capacity=5) return reImage if __name__ == "__main__": filePathList=getPath("./data") jpg=readImg(filePathList) #开启会话 with tf.Session() as sess: #定义一个线程协调器 coord=tf.train.Coordinator() #定义一个线程 thread=tf.train.start_queue_runners(sess,coord=coord) print(sess.run(jpg)) #回收子线程 coord.request_stop() coord.join(thread) 注意打印结果: 构造完阅读器 Tensor(“ReaderReadV2:1”, shape=(), dtype=string)解码 Tensor(“DecodeJpeg:0”, shape=(?, ?, ?), dtype=uint8)图片放缩后 Tensor(“Squeeze:0”, shape=(200, 200, ?), dtype=float32)图片静态调整后 Tensor(“Squeeze:0”, shape=(200, 200, 3), dtype=float32) 11.交叉熵损失计算和softMax计算1.softMax计算​ 假设我们有一个数组，V，Vi表示V中的第i个元素，那么这个元素的Softmax值就是 ​ 可以计算n个结果之间发生的概率 2.交叉熵损失​ 可以和onehost编码与softMax计算损失 #SoftMax和交叉熵损失计算 tf.nn.softmax_cross_entropy_with_logits(babels=None,logits=None,name) #计算logits和labels之间的交叉熵损失 #labels:真实值 #logits:预测值 #return:返回所有样本的损失值列表 3.演示def argmax(input, axis=None, name=None, dimension=None, output_type=dtypes.int64) numpy.argmax(a, axis=None, out=None) 返回沿轴axis最大值的索引。 Parameters: input: array_like，数组 axis : int, 可选，默认情况下，索引的是平铺的数组，否则沿指定的轴。 out : array, 可选 如果提供，结果以合适的形状和类型被插入到此数组中。 Returns: index_array : ndarray of ints 索引数组。它具有与a.shape相同的形状，其中axis被移除。 #简单的神经网络识别手写数字 #1.定义占位符 #2.搭建神经网络 #3.计算损失 #4.反向传播优化损失 #5.计算准确率 #6.开启会话训练 import tensorflow as tf from tensorflow.examples.tutorials.mnist import input_data mnist = input_data.read_data_sets("./MNIST_data", one_hot=True) def imgNn(): #1.定义占位符 xDist=tf.placeholder(tf.float32,[None,784]) yTrue=tf.placeholder(tf.float32,[None,10]) #2.初始化变量搭建神经网络 w=tf.Variable(tf.random_normal([784,10],mean=0.0,stddev=1.0)) b=tf.Variable(tf.random_normal([10],mean=0.0,stddev=1.0)) y=tf.matmul(xDist,w)+b #3.计算平均交叉熵损失率 loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=yTrue,logits=y)) #4.反向传播最小优化学习率0.1 trainOp=tf.train.GradientDescentOptimizer(0.1).minimize(loss) #5.计算准确率 arg_max会反正正确结果的下标 1表示按同行比较 0表示同列 equal_list=tf.equal(tf.arg_max(yTrue,1),tf.arg_max(y,1)) acuracy=tf.reduce_mean(tf.cast(equal_list,tf.float32)) initOp=tf.global_variables_initializer() #6.开启会话开始训练 with tf.Session() as sess: sess.run(initOp) for i in range(3000): #取出特征值和目标值 minstX,minstY=mnist.train.next_batch(50) sess.run(trainOp,feed_dict={xDist:minstX,yTrue:minstY}) print("%d步准确率%f" % (i,sess.run(acuracy,feed_dict={xDist:minstX,yTrue:minstY}))) if __name__ =="__main__": imgNn() 12.卷积神经网络1.概述​ 卷积神经网络（Convolutional Neural Networks / CNNs / ConvNets）与普通神经网络非常相似，它们都由具有可学习的权重和偏置常量(biases)的神经元组成。每个神经元都接收一些输入，并做一些点积计算，输出是每个分类的分数，普通神经网络里的一些计算技巧到这里依旧适用。 具有三维体积的神经元(3D volumes of neurons) ​ 卷积神经网络利用输入是图片的特点，把神经元设计成三个维度 ： width, height, depth(注意这个depth不是神经网络的深度，而是用来描述神经元的) 。比如输入的图片大小是 32 × 32 × 3 (rgb)，那么输入神经元就也具有 32×32×3 的维度。 2.卷积神经网络分层卷积层—&gt;激活层—&gt;池化层—&gt;全连接层##### 卷积层：​ 卷积神经网路中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过反向传播算法优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网络能从低级特征中迭代提取更复杂的特征。 激活层：​ 通过Relu激活函数可以增加网络的非线性分割能力 池化层：​ 用来减少数据量 3.填充算法SAME：​ 当filter过滤到边缘的时候自动填充0 - 越过边缘取样，取样的面积和输入的图像像素长度和宽度相同VALID： 当filter过滤到边缘的时候跳过，所有会丢失部分特征，取样的面积和输入的图像像素长度和宽度会略小 计算公式为：输入体积大小h1 * w1 * d1 ，filter数量为k,filter大小为f,步长为s,填充大小为p 那么 h2=(h1-f+2p)/s+1 w2=(w1-f+2p)/s+1 d2=k 4.API介绍#卷积层 tf.nn.conv2d(input,filter,strides=,padding=,name=None) input: 输入的4-D张量，具有[batch,height,width,channel],类型为float32，或者float64([每批数,图片长度，图片宽度，图片通道数])filter:指定过滤器4-D随机初始化的张量：,类型为float32或者float64([过滤器长度，过滤器宽度，输入的通道数，输出的通道数])，——- 注意需要传入4-D张量，而不是简单的填入维度strides:strides=[1,stride,stride,1],步长（[1，长上步长，宽上步长，1]）padding=:”SAME”，“VALID”，使用的填充算法类型.#relu激活函数 tf.nn.relu(feacutes,name=None) features:卷积后加上偏置的结果return :结果#池化 tf.nn.max_pool(value,ksize=,strides=,padding=,name=None) value:4-D tensor形状[batch,height,width,channels]，也就是激活函数处理后的结果ksize池化窗口大小，[1,ksize,ksize,1]步长大小,[1,strides,strides,1]padding :”SAME”,”VALID”填充算法5.演示两层卷积神经网络识别手写数字​ 1.输入数据形状[None,784] ##### 第一层卷积神经网络卷积层​ 2.因为卷积API的input即输入为4-D张量，所以动态改变形状改为[None,28,28,1],使用32个filter的5*5大小，步长为1，SAME填充算法的过滤器且卷积后输出的形状为[None,28,28,32]，有多少个filter就有多少个偏置所以为32，权重就是每个filter的值. ###### 激活层​ 3.不改变数据大小，所以输出还是[None,28,28,32] ###### 池化​ 4.大小为2 *2，步长为2，填充算法为“SAME”(这里SAME后的大小比原来小)将[None,28,28,32]的图像池化为[None,14,14,32] 第一层卷积神经网络卷积层​ 2.因为卷积API的input即输入为4-D张量，输入为[None,14,14,32],使用64个filter的5*5大小，步长为1，SAME填充算法的过滤器且卷积后输出的形状为[None,14,14,64]，有多少个filter就有多少个偏置所以为64,权重就是每个filter的值. 激活层​ 3.不改变数据大小，所以输出还是[None,14,14,64] 池化​ 4.大小为2*2，步长为2，填充算法为“SAME”(这里SAME后的大小比原来小)将[None,14,14,64]的图像池化为[None,7,7,64] 全连接层​ 因为池化后数据为[None,7,7,64],而且矩阵乘法只能处理二维数据，所以动态调整形状为[None,7 * 7 *64],又因为输出是10种结果，所以全连接层为[7 * 7 *64,10],所以权重[7 * 7 *64,10]偏置有10个 ##### 两层卷积神经网络识别手写数字 import tensorflow as tf from tensorflow.examples.tutorials.mnist import input_data def getVarRandom_normal(shape): return tf.Variable(tf.random_normal(shape=shape,mean=0.0,stddev=1.0)) #搭建神经网络 def conV(): #1.定义占位符 xDist=tf.placeholder(tf.float32,[None,784]) yTrue=tf.placeholder(tf.float32,[None,10]) #2.搭建第一层卷积网络 filter 有32个 大小为5*5，步长为1， with tf.name_scope("con1"): xshape=tf.reshape(xDist,[-1,28,28,1]) filterW=getVarRandom_normal([5,5,1,32]) b=getVarRandom_normal([32]) #卷积层 con1=tf.nn.conv2d(xshape,filterW,strides=[1,1,1,1],padding="SAME")+b #激活层 relu=tf.nn.relu(con1) #池化层 大小为2*2 步长为2 [None,28,28,32]---->[None,14,14,32] pool=tf.nn.max_pool(relu,ksize=[1,2,2,1],strides=[1,2,2,1],padding="SAME") #3.搭建第二层卷积网络 filter有64个，大小为5*5，步长为1 with tf.name_scope("con2"): filterW2=getVarRandom_normal([5,5,32,64]) b1=getVarRandom_normal([64]) #卷积层 con2=tf.nn.conv2d(pool,filterW2,strides=[1,1,1,1],padding="SAME")+b1 #激活层 relu2=tf.nn.relu(con2) #池化层 pool2=tf.nn.max_pool(relu2,ksize=[1,2,2,1],strides=[1,2,2,1],padding="SAME") #全连接层 w3=getVarRandom_normal([7*7*64,10]) b3=getVarRandom_normal([10]) shape = tf.reshape(pool2, [-1, 7*7*64]) grop=tf.matmul(shape,w3)+b3 return xDist,yTrue,grop if __name__ == "__main__": xDist,yTrue,opInt=conV() mnist = input_data.read_data_sets("./MNIST_data", one_hot=True) #计算平均交叉熵损失 loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=yTrue,logits=opInt)) #反向传播 trainOp=tf.train.GradientDescentOptimizer(0.00001).minimize(loss) #计算准确率 equal_list = tf.equal(tf.argmax(yTrue, 1), tf.argmax(opInt, 1)) acuracy = tf.reduce_mean(tf.cast(equal_list, tf.float32)) initOp = tf.global_variables_initializer() # 6.开启会话开始训练 with tf.Session() as sess: sess.run(initOp) for i in range(3000000): # 取出特征值和目标值 minstX, minstY = mnist.train.next_batch(50) sess.run(trainOp, feed_dict={xDist: minstX, yTrue: minstY}) print("%d步准确率%f" % (i, sess.run(acuracy, feed_dict={xDist: minstX, yTrue: minstY})))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>语言</tag>
        <tag>Python</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用入门]]></title>
    <url>%2F2018%2F05%2F27%2Fgit-shi-yong-ru-men%2F</url>
    <content type="text"><![CDATA[Git使用入门前言​ 之前在网上接私活的时候使用了一下github,当时一下都惊艳到我了，（见识短╮(╯▽╰)╭），当时因为用的c#语言开发，使用的vs2017，他继承的那个git是中文的，特别好用，但是也导致了我啥也没学会，正好今天有空，就填补一下这个大坑吧 简介​ 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。（百度粘贴过来的，╮(╯▽╰)╭） 概念介绍​ git可以将工作区（Working Directory）的代码放到暂存区，最后统一把暂存区的代码合并到我们的git仓库中（这个仓库其实还是本地的仓库）。（╮(╯▽╰)╭我觉得解释的很不清楚） st=>start: git仓库 e=>end: 工作空间 item=>subroutine: 暂存区 e->item->st 使用git工具要先进行初始化git config --global user.name "yang295513"//这个name一定要填写github上面的名称 git config --global user.email "15993343299@163.com"//对应的邮箱 //这个不是必须的但是新建git仓库就要进去进行这个命令，然后git工具会生成一个隐藏文件.git git init 就这样，之后就可以愉快的玩耍了 指令介绍 指令名 作用 注释 git status 显示当前文件的状态 用来确定文件在三个区的位置 git add 文件名.文件类型 将文件添加到暂存区 把工作空间的文件添加到暂存区 git commit -m “提交描述” 把暂存区所有的文件提交到仓库 提交描述用来标识文件的改动，也就是说本次提交的注释 git push 将本地代码提交到git远程 仓库中 将本地代码提交到git远程仓库中 git clone 仓库地址 将远程git的代码下载下来 案例演示首先这里新建了一个演示项目 然后我们通过git clone命令把这个项目下载下来，其中项目的链接在这里： 然后我们使用git工具克隆下来 这是本地生成的文件 其中那个.git的隐藏文件就隐藏着配置信息 githubTest就是咱们的测试信息 githubTest文件里面的信息可以看到和我们的远端github仓库中的一模一样 接下来我们在本地创建一个Test.java的类，来模拟我们的项目 然后使用git add命令和git commit -m和git push命令依次提交到git远端仓库中 然后去github来查看是否已经被提交了 完美,收场，学习新东西去不不不，还有一些使用细节得介绍一下 你提交了那些文件那些文件才会被替换，也就是说你同时修改了A和B文件，那三连 都是针对B文件的，那么你提交到远端git仓库在只会修改你提交的B文件，没有B文件进行创建,有B文件更新 如果提交到远端失败的话，要注意是否是name和Email书写错误，或者说该仓库是priavte（私有的）如果是私有的去对应配置文件下修改账号密码即可]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>git</tag>
      </tags>
  </entry>
</search>
