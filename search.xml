<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String table详解]]></title>
    <url>%2F2020%2F03%2F21%2FString-table%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[String table又称为String pool，字符串常量池，其存在于堆中(jdk1.8及其以后改的)。最重要的一点，String table中存储的并不是String类型的对象，存储的而是指向String对象的索引，真实对象还是存储在堆中。 String字节码直接使用双引号声明出来的String对象会直接存储在常量池中一定要先记住这句话 在学习之前首先先学习一下String的字节码 案例一12345678910/** * @author yang * @date 2020/3/20 下午 1:49 */public class EnuTest&#123; public static void main(String[] args)&#123; String a="a"; String b="b"; &#125;&#125; 对应字节码 123450 ldc #2 &lt;a&gt;//把符号引用变为字符串对象引用,且加入到StringTable中去2 astore_1//把字符串对象引用存入局部变量表1位置3 ldc #3 &lt;b&gt;//把符号引用变为字符串对象引用,且加入到StringTable中去5 astore_2//把字符串对象引用存入局部变量表1位置6 return 案例二12345678public class EnuTest&#123; public static void main(String[] args)&#123; String a="a"; String b="b"; String d=a+b;//新加入代码 &#125;&#125; 对应字节码 123456789101112131415 0 ldc #2 &lt;a&gt; 2 astore_1 3 ldc #3 &lt;b&gt; 5 astore_2 9 new #5 &lt;java/lang/StringBuilder&gt;//创建StringBuilder对象12 dup13 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;//调用无参数构造方法16 aload_117 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;//调用append方法追加20 aload_221 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;//调用append方法追加24 invokevirtual #8 &lt;java/lang/StringBuilder.toString&gt;//调用toString方法打印27 astore 429 return StringBuilder源码 12345@Overridepublic String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count);//可以发现String d=a+b;new 了一个新对象，并且这个新对象并没有加入到StringTable（字符串常量池中）&#125; 可以发现String d=a+b;new 了一个新对象，并且这个新对象并没有加入到StringTable（字符串常量池中） 究竟什么时候会存入字符串常量池呢? 经过反复实验发现 直接使用双引号声明出来的String对象会直接存储在常量池中。 演示12345public class EnuTest&#123; public static void main(String[] args)&#123; String a=new String("abc")+new String("bcd");//[abc,bcd]存入了常量池 &#125;&#125; 对应字节码文件 12345678910111213141516 0 new #2 &lt;java/lang/StringBuilder&gt; 3 dup 4 invokespecial #3 &lt;java/lang/StringBuilder.&lt;init&gt;&gt; 7 new #4 &lt;java/lang/String&gt;10 dup11 ldc #5 &lt;abc&gt;//第一次13 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;16 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;19 new #4 &lt;java/lang/String&gt;22 dup23 ldc #8 &lt;bcd&gt;//第二次25 invokespecial #6 &lt;java/lang/String.&lt;init&gt;&gt;28 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;34 astore_135 return 案例三12345678public class EnuTest&#123; public static void main(String[] args)&#123; String a="a"; String b="b"; String c="ab"; String d="a"+"b"; &#125;&#125; 对应字节码 123456789 0 ldc #2 &lt;a&gt; 2 astore_1 3 ldc #3 &lt;b&gt; 5 astore_2 6 ldc #4 &lt;ab&gt; 8 astore_3 9 ldc #4 &lt;ab&gt;11 astore 413 return 我们仔细阅读不难发现String c=”ab”和String d是相等的，因为他们指向的是同一个常量池。 接下来我们都明白了，我们就看一些题目吧 123456789101112public class EnuTest&#123; public static void main(String[] args)&#123; String a="a"; String b="b"; String c="ab"; String d="a"+"b"; String e=new String("a")+new String("b");//出现引号的只有a和b也就是说字符串常量池只有[a,b] System.out.println(c==d); System.out.println(c==e); &#125;&#125; 答案是 12truefalse 是不是现在就很清楚了。 要是不清楚还有终极大招12345678910public class EnuTest&#123; public static void main(String[] args)&#123; String abc=new String("abc"); System.out.println(abc.intern()==abc);//false原因是abc.intern虽然打算存入abc但是字符串常量池已经有了,所有返回了字符串常量池的引用,所以对象abc和常量池的引用一定不相等啊 System.out.println(abc.intern()=="abc");//true这个原因就不需要解释了吧 abc=abc.intern();//这次我们改变引，引用常量池中的 System.out.println(abc);//打印结果还是abc &#125;&#125; 是不是感觉明白点了，那么接下来我们在玩点骚气的 12345678910111213public class EnuTest&#123; public static void main(String[] args)&#123; String a="a"; String bc="bc"; String abc=new String("abc").intern();//此时常量池中只有[a,bc,abc] String bcd="abc";//他直接从常量池中取出了"abc"的引用 System.out.println(bcd==abc);//true &#125;&#125; intern解释3.String.intern() in JDK6 Jdk6中常量池位于PermGen（永久代）中，PermGen是一块主要用于存放已加载的类信息和字符串池的大小固定的区域。执行intern()方法时，若常量池中不存在等值的字符串，JVM就会在常量池中创建一个等值的字符串，然后返回该字符串的引用。除此以外，JVM 会自动在常量池中保存一份之前已使用过的字符串集合。Jdk6中使用intern()方法的主要问题就在于常量池被保存在PermGen中：首先，PermGen是一块大小固定的区域，一般不同的平台PermGen的默认大小也不相同，大致在32M到96M之间。所以不能对不受控制的运行时字符串（如用户输入信息等）使用intern()方法，否则很有可能会引发PermGen内存溢出；其次String对象保存在Java堆区，Java堆区与PermGen是物理隔离的，因此如果对多个不等值的字符串对象执行intern操作，则会导致内存中存在许多重复的字符串，会造成性能损失。 4.String.intern() in JDK7 Jdk7将常量池从PermGen区移到了Java堆区，执行intern操作时，如果常量池已经存在该字符串，则直接返回字符串引用，否则复制该字符串对象的引用到常量池中并返回。堆区的大小一般不受限，所以将常量池从PremGen区移到堆区使得常量池的使用不再受限于固定大小。除此之外，位于堆区的常量池中的对象可以被垃圾回收。当常量池中的字符串不再存在指向它的引用时，JVM就会回收该字符串。可以使用 -XX:StringTableSize 虚拟机参数设置字符串池的map大小。字符串池内部实现为一个HashMap，所以当能够确定程序中需要intern的字符串数目时，可以将该map的size设置为所需数目*2（减少hash冲突），这样就可以使得String.intern()每次都只需要常量时间和相当小的内存就能够将一个String存入字符串池中。 StringTable这个地方也是可以被垃圾回收的，当没有持有这个字符串常量池的引用时就会被垃圾回收掉 StringTable的底层实现是HashTable 调优方案一由于底层实现是HashTable，当字符串常量池特别大的时候可以使用参数-XX:StringTableSize=大小来增加桶容量 这样可以减少hash碰撞 方案二如果有一批字符串常量量也特别大，比如全国人民的地址信息，你会发现这些信息有好些是重复的，就可以利用这些重复信息来实现优化。 总结想把字符串加入常量池（StringTable）只有两种方法 常量池中没有的字符，通过intern加入 常量池没有字符是，双引号括起来的会被加入]]></content>
      <tags>
        <tag>字节码</tag>
        <tag>StringTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态内部类何时被加载]]></title>
    <url>%2F2020%2F03%2F21%2F%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%95%E6%97%B6%E8%A2%AB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[首先先看一段代码 1234567891011121314151617181920212223/** * @author yang * @date 2020/3/20 下午 1:49 */public class EnuTest&#123; public static void main(String[] args) &#123; Demo demo = new Demo(); &#125;&#125;class Demo &#123; static int a=0; static &#123; System.out.println("外部类被加载"); &#125; public static class Inner&#123; static &#123; System.out.println("内部类被加载"); &#125; public static void run()&#123; System.out.println("内部类方法被调用"); &#125; &#125;&#125; 1外部类被加载 也就说说初始化内部类的时候并没有初始化里面的静态内部类，也是被动调用 再来看第二段代码 1234567891011121314151617181920212223/** * @author yang * @date 2020/3/20 下午 1:49 */public class EnuTest&#123; public static void main(String[] args) &#123; Demo.Inner.run();//唯一改变的地方，直接调用静态内部类的静态方法 &#125;&#125;class Demo &#123; static int a=0; static &#123; System.out.println("外部类被加载"); &#125; public static class Inner&#123; static &#123; System.out.println("内部类被加载"); &#125; public static void run()&#123; System.out.println("内部类方法被调用"); &#125; &#125;&#125; 运行结果 12内部类被加载内部类方法被调用 也就说说这个静态内部类的初始化并不会触发外部类的初始化，即可以单独存在，也就是说这种调用方法是被动调用 接下来看第三段代码 1234567891011121314151617181920212223/** * @author yang * @date 2020/3/20 下午 1:49 */public class EnuTest&#123; public static void main(String[] args) &#123; Demo.Inner.run(); &#125;&#125;class Demo &#123; static int a=0;//因为内部类是静态的，内部要想访问除非静态，或者内部类创建外部对象 static &#123; System.out.println("外部类被加载"); &#125; public static class Inner&#123; static &#123; System.out.println("内部类被加载"); &#125; public static void run()&#123; System.out.println("内部类方法被调用"+a);//代码唯一改变的地方 &#125; &#125;&#125; 123内部类被加载外部类被加载内部类方法被调用0 也就是证实了内部类的存在并不依赖外部类的 结论外部类的初始化并不会触发内部类的初始化。 内部类的先初始化也不会导致外部类的初始化。 如果内部类的静态方法使用到了外部类，那么静态内部类会先初始化然后初始化外部类。 非静态内部类依赖外部类吗这个答案可想而知，我们无论如何，只要创建内部类，就一定要保证外部类的存在，答案是依赖]]></content>
      <tags>
        <tag>内部类</tag>
        <tag>被动调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Integer陷阱]]></title>
    <url>%2F2020%2F03%2F20%2FInteger%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[首先对象使用==比较的是是否为同一个对象 12345678910111213141516public class EnuTest &#123; public static void main(String[] args) &#123; Integer integer1=110; Integer integer2=110; System.out.println(integer2==integer1); Integer integer3=150; Integer integer4=150; System.out.println(integer3==integer4); &#125;&#125;//输出结果为truefalse 为什么会这样呢，是不是发现和String很像，当然我们这篇文章并不讨论String。 原因分析jdk1.5引入了装箱和拆箱的机制。 当我们打开Integer的源码就会发现,java.lang.Integer类里面有个成员静态内部类IntegerCache 123456789101112131415161718192021222324252627282930313233private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 我们仔细阅读这个源码不难发现他维护了一个缓存区，这个缓存区[-128, 127] 之间的数都会被缓存。是不是顿时感觉就明白了，别慌。 你仔细看看问题发生的代码 1234Integer integer5=new Integer(110);Integer integer6=new Integer(110);system.out.println(integer5==integer6);//结果是false 不是说凡是在[-128,127]之间的都会被缓存吗，(这里先不讨论new就是创建了一个新的对象) 我们打开Integer的构造函数 123456public Integer(int value) &#123; this.value = value;&#125;public Integer(String s) throws NumberFormatException &#123; this.value = parseInt(s, 10);&#125; 发现都没有和IntegerCache发生关系，所以不可能为true。 问题就来了，java是如何把[-128,127]存储到IntegerCache中的呢，似乎这个问题陷入了死角。 前面说过，在jdk1.5中引入了自动装箱和拆箱概念，问题就发生在这。 123456public static void run()&#123; int a=100; Integer integer=110;//自动装箱 integer=100;//自动装箱&#125; 接下来是反编译后的字节码 123456789101112 0 bipush 100//100入操作数栈 2 istore_0//100弹出操作数栈，并保存到局部变量表0位置上，0位置上就是a 3 bipush 110//100入操作数栈 5 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;//调用valueOf方法 8 astore_1//栈顶保存到局部变量表1位置上，1位置上就是integer 9 bipush 10011 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;//调用valueOf方法14 astore_1//栈顶保存到局部变量表1位置上，1位置上就是integer15 sipush 15018 invokestatic #2 &lt;java/lang/Integer.valueOf&gt;21 astore_2//栈顶保存到局部变量表1位置上，1位置上就是integer22 return 对比一下源代码我们发现 虚拟机居然调用了valueOf这个方法,而且我们发现基本数据类型是不会调用这个方法的,也就说说这个自动装箱和拆箱其实是编译器搞的，也就是当编译期发现了这个装箱就会增加一个调用方法valueOf(int i)这个方法。 那么我们就看一下valueOf的源代码吧 1234567891011public static Integer valueOf(int i) &#123;//编译期调用的正是这个方法 if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)//判断有没有超出缓冲区的范围 return IntegerCache.cache[i + (-IntegerCache.low)];//返回缓冲区中的结果 return new Integer(i);&#125;public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10));&#125;public static Integer valueOf(String s, int radix) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s,radix));&#125; 我们发现只有valueOf(int i)这个确实是这样的。 仔细看一下8个包装类型发现并不是所有的类型都有这个缓冲区的, 有缓存区的有的有Character，Byte,Short，Long. 猜想IntegerCache的设计思路 首先这个类的作用是维护一个缓冲区，也就说说所有的Integer类型都要共用的一个类，并且Integer是非静态的类，也就说说这个类一定是静态的，因为如果不是静态的，那么所有的Integer将无法共享这个静态成员内部类。 然后这个类肯定只能Integer访问和使用，不能让其他类使用，所有这个类一定是私有的成员内部类，。 如果这个类是私有的那么Intger想要访问，必须通过里面的静态非私有属性或者静态非私有方法来访问。 以上是我的猜想，那么接下来咱们验证一下吧. 1234567891011121314151617181920212223242526272829private static class IntegerCache &#123;//确实是私有的且静态的 static final int low = -128; static final int high; static final Integer cache[];//外部可以通过这个非私属性拿到这个属性，并且是default（包）权限 static &#123; int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125;]]></content>
      <tags>
        <tag>Integer</tag>
        <tag>陷阱</tag>
        <tag>源码</tag>
        <tag>字节码</tag>
        <tag>猜想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4操作系统进程同步和2.5经典进程的同步问题]]></title>
    <url>%2F2020%2F03%2F20%2F2-4%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[简介​ 进程同步是一个操作系统级别的概念,是在多道程序的环境下，存在着不同的制约关系，为了协调这种互相制约的关系，实现资源共享和进程协作，从而避免进程之间的冲突，引入了进程同步。 进程描述定义 进程是程序的一次执行。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 本教材定义进程为：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 临界资源​ 在操作系统中，进程是占有资源的最小单位（线程可以访问其所在进程内的所有资源，但线程本身并不占有资源或仅仅占有一点必须资源）。但对于某些资源来说，其在同一时间只能被一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。 ​ 对于临界资源的访问，必须是互诉进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。 ​ 对于临界区的访问过程分为四个部分： 进入区:查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞 临界区:在临界区做操作 退出区:清除临界区被占用的标志 剩余区：进程与临界区不相关部分的代码 临界资源使用规则：忙则等待、优先等待、空闲让进、让权等待（在临界区的进程，不能在临界区内长时间处于事件等待，必须在一定时间退出临界区）。 多个进程常常需要共同修改某些共享变量、表格、文件数据库等，协作完成一些功能。共享协作带来了进程的同步和互斥、死锁、饥饿等问题。 进程同步 ​ 进程同步也是进程之间直接的制约关系，是为完成某种任务而建立的两个或多个线程，这个线程需要在某些位置上协调他们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系来源于他们之间的合作。 ​ 比如说进程A需要从缓冲区读取进程B产生的信息，当缓冲区为空时，进程B因为读取不到信息而被阻塞。而当进程A产生信息放入缓冲区时，进程B才会被唤醒。 进程互斥 ​ 进程互斥是进程之间的间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待。只有当使用临界资源的进程退出临界区后，这个进程才会解除阻塞状态。 ​ 比如进程B需要访问打印机，但此时进程A占有了打印机，进程B会被阻塞，直到进程A释放了打印机资源,进程B才可以继续执行。 实现临界区互斥的基本方法硬件实现方法 ​ 通过硬件实现临界区最简单的办法就是关CPU的中断。从计算机原理我们知道，CPU进行进程切换是需要通过中断来进行。如果屏蔽了中断那么就可以保证当前进程顺利的将临界区代码执行完，从而实现了互斥。这个办法的步骤就是:屏蔽中断–执行临界区–开中断。但这样做并不好，这大大限制了处理器交替执行任务的能力。并且将关中断的权限交给用户代码，那么如果用户代码屏蔽了中断后不再开，那系统岂不是跪了？ 信号量实现方式 ​ 这也是我们比较熟悉P V操作。通过设置一个表示资源个数的信号量S，通过对信号量S的P和V操作来实现进程的的互斥。 ​ P和V操作分别表示占有和释放。P V操作是操作系统的原语，意味着具有原子性。 ​ P操作首先减少信号量，表示有一个进程将占用或等待资源，然后检测S是否小于0,如果小于0则阻塞，如果大于0则占有资源进行执行。 ​ V操作是和P操作相反的操作，首先增加信号量，表示占用或等待资源的进程减少了1个。然后检测S是否小于0，如果小于0则唤醒等待使用S资源的其它进程。 ​ 前面我们C#模拟进程的同步和互斥其实算是信号量进行实现的。 经典进程的同步问题生产者–消费者问题 ​ 问题描述:生产者-消费者问题是一个经典的进程同步问题，该问题最早由Dijkstra提出，用以演示他提出的信号量机制。本作业要求设计在同一个进程地址空间内执行的两个线程。生产者线程生产物品，然后将物品放置在一个空缓冲区中供消费者线程消费。消费者线程从缓冲区中获得物品，然后释放缓冲区。当生产者线程生产物品时，如果没有空缓冲区可用，那么生产者线程必须等待消费者线程释放出一个空缓冲区。当消费者线程消费物品时，如果没有满的缓冲区，那么消费者线程将被阻塞，直到新的物品被生产出来 ​ 这里生产者和消费者是既同步又互斥的关系，首先只有生产者生产了，消费着才能消费，这里是同步的关系。但他们对于临界区的访问又是互斥的关系。因此需要三个信号量empty和full用于同步缓冲区，而mut变量用于在访问缓冲区时是互斥的。 读者–写者问题 问题描述:​ 一个数据文件或记录，统称数据对象，可被多个进程共享，其中有些进程只要求读称为”读者”，而另一些进程要求写或修改称为”写者”。 ​ 规定:允许多个读者同时读一个共享对象，但禁止读者、写者同时访问一个共享对象，也禁止多个写者访问一个共享对象，否则将违反Bernstein并发执行条件。 问题分析​ 通过描述可以分析，这里的读者和写者是互斥的，而写者和写者也是互斥的，但读者之间并不互斥。 ​ 由此我们可以设置3个变量，一个用来统计读者的数量，另外两个分别用于对读者数量读写的互斥，读者和读者写者和写者的互斥。 哲学家进餐问题 问题描述:​ 有五个哲学家，他们的生活方式是交替地进行思考和进餐。哲学家们公用一张圆桌，周围放有五把椅子，每人坐一把。在圆桌上有五个碗和五根筷子，当一个哲学家思考时，他不与其他人交谈，饥饿时便试图取用其左、右最靠近他的筷子，但他可能一根都拿不到。只有在他拿到两根筷子时，方能进餐，进餐完后，放下筷子又继续思考。 根据问题描述,五个哲学家分别可以看作是五个进程。五只筷子分别看作是五个资源。只有当哲学家分别拥有左右的资源时，才得以进餐。如果不指定规则，当每个哲学家手中只拿了一只筷子时会造成死锁，从而五个哲学家都因为吃不到饭而饿死。因此我们的策略是让哲学家同时拿起两只筷子。因此我们需要对每个资源设置一个信号量，此外，还需要使得哲学家同时拿起两只筷子而设置一个互斥信号量，]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java零碎小细节]]></title>
    <url>%2F2020%2F03%2F19%2Fjava%E9%9B%B6%E7%A2%8E%E5%B0%8F%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[boolean大小问题问题引入今天在看java编程思想的时候发现8个基本类型变量基本上都有明确的大小，但是boolean并没有大小。 解决来源是《Java虚拟机规范》一书中的描述：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。 使用局部变量定义数组的时候数组会被初始化当使用局部变量的时候必须先初始化才能使用，但是使用局部变量定义数组的时候数组里面的所有元素都会被初始化为零值。 问题分析 成员变量的值存放于java堆中，在创建对象的时候JVM在分配内存时将整块区域置为零即完成了初始化，方便快捷。 而局部变量运行时被分配于虚拟机栈中，量大，生命周期短，如果由JVM完成初始化，将是一笔很大的性能开销。所以java规定局部变量手动必须初始化。 当一个对象使用关键字“new”创建时，会在堆上分配内存空间，然后返回对象的引用，这对数组来说也是一样的，因为数组也是一个对象,所以和成员变量一样在整块区域置为零即完成了初始化； JAVA何时加载静态语句块父类静态代码块 &gt; 子类静态代码块 Java虚拟机加载类时，就会执行该块代码。父类构造函数 &gt; 子类构造函数 （先有父亲，后有孩子）如果是多级继承关系的话，高层的父类首先执行，然后依次递减。总结：静态优先执行，父类优先于子类执行。 静态代码块是在JVM加载类的时候执行的，而且静态代码块执行且仅执行一次 静态代码块什么时候开始执行 静态代码块在初始化阶段才会被执行，也就说单纯的类加载是不会执行静态代码块的。 也就说有些情况是不会触发这个静态代码块的执行的。 主动加载和被动加载的区别在于，主动加载会触发类的初始化。 主动加载的情况 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类； 使用Jdk1.7动态语言支持的时候的一些情况。 当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化) 类不被加载情况举例12345678910111213141516171819package jvm;public class ClassLoaderTest &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //1. System.out.println(Demo.class);//不会执行初始化阶段 //2. Class.forName("jvm.Demo");//会执行初始化阶段也就说说会执行静态代码块 &#125;&#125;class Demo&#123; static &#123; System.out.println("被加载了"); hello(); &#125; public static void hello()&#123; System.out.println("hello方法被执行了!"); &#125;&#125; 当然不会触发静态代码块的方案还有很多. 非静态方法都隐藏一参数this非静态非方法都有一个隐藏参数this，也就说this只有非静态方法才能用 演示这是两个方法，一个静态方法，一个非静态方法 1234public static void f1()&#123;&#125;public void f2()&#123;&#125; 我们可以看到方法f1压根没有局部变量表，但是方法f2局部变量表有个this Java中创建子类实例时会创建父类实例？首先每个类的这些元数据，无论是在构建这个类的实例还是调用这个类某个对象的方法，都会访问方法区的这些元数据。构建一个对象时，JVM会在堆中给对象分配空间，这些空间用来存储当前对象实例属性以及其父类的实例属性（而这些属性信息都是从方法区获得） 注意，这里并不是仅仅为当前对象的实例属性分配空间，还需要给父类的实例属性分配。 总之，会为父类分配堆内存，但是这块内存属于子类的堆内存。 i++和++i的区别i++和++i都会变成两个字节码指令 iload 把局部变量表中的值加载到操作数栈中 iinc * by * 第一个占位符表示局部变量表的位置，第二个表示该位置自增的数，比如inc 1 by 1就表示 1位置自增1 注意只有这两条指令 区别i++是先iload后 inc，++i是先inc后iload 陷阱12345678public class EnuTest&#123; public static void main(String[] args)&#123; int a=0; for (int i = 0; i &lt; 10; i++) a=a++; System.out.println(a); &#125;&#125; 比如这行代码结果就是0，就是利用了这个坑，道理也很简单，每次a自增前都把当前值0加载到了操作数栈中，然后因为有个等于号对应指令就是把操作数栈中栈顶的值存入局部变量表中，也就是说a自增后又被重新覆盖为0了]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm学习第三天-类加载器]]></title>
    <url>%2F2020%2F03%2F19%2Fjvm%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E5%A4%A9-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[类加载器 虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 类与类加载器对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。 这段代码就演示了这种情况 123456789101112131415161718192021222324252627282930313233343536373839package jvm;import java.io.IOException;import java.io.InputStream;public class ClassLoaderTest &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; ClassLoader myLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; String fileName = name.substring(name.lastIndexOf(".") + 1) + ".class"; InputStream inputStream = getClass().getResourceAsStream(fileName); if (inputStream == null) &#123; return super.loadClass(name); &#125; try &#123; byte[] b = new byte[inputStream.available()]; inputStream.read(b); return defineClass(name, b, 0, b.length); &#125; catch (IOException e) &#123; throw new ClassNotFoundException(); &#125; &#125; &#125;; Object obj = myLoader.loadClass("jvm.ClassLoaderTest").newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof jvm.ClassLoaderTest); ClassLoaderTest classLoaderTest = new ClassLoaderTest(); System.out.println(classLoaderTest.getClass()); System.out.println(classLoaderTest instanceof jvm.ClassLoaderTest); &#125;&#125;//运行结果为class jvm.ClassLoaderTestfalseclass jvm.ClassLoaderTesttrue 双亲委派模型从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。 从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器： 启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。 扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。 应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。我们的应用程序都是由这三类加载器互相配合进行加载的。另外还有自定义类加载器。自定义类加载器(必须继承 ClassLoader)。 这些类加载器之间的关系 如上图所示的类加载器之间的这种层次关系，就称为类加载器的双亲委派模型（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。 双亲委派模型的工作过程为如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。 优点 保证了系统的安全性 保证了同一个类由各种类加载器加载都是同一个类 模型实现 123456789101112131415161718192021222324252627protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; &#123;//首先，检查请求的类是否已经被加载过了 Class c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123;//如果父类加载器抛出ClassNotFoundException//说明父类加载器无法完成加载请求 &#125; if (c == null) &#123;//在父类加载器无法加载的时候//再调用本身的findClass方法来进行类加载 c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125;]]></content>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql的zip安装方法]]></title>
    <url>%2F2020%2F03%2F18%2Fmysql%E7%9A%84zip%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[windows安装方法本文来自https://howwrite.github.io/ 下载文件先去清华大学镜像站下载文件 找到想要版本的mysql,进去下载对应的zip文件,我下载的是mysql8.0的64位版:mysql-8.0.11-winx64.zip 下载完成后解压到合适的位置,如：C:\mysql-8.0.11 配置 解压完后在根目录创建一个名为my.ini的文件,添加以下内容 1234567891011121314151617[mysqld]character-set-server=utf8port = 3306# 设置mysql的安装目录basedir=D:\\mysql-8.0.11# 设置mysql数据库的数据的存放目录datadir=D:\\mysql-8.0.11\\datadefault-storage-engine = INNODBcollation-server = utf8_general_ci[mysql]default-character-set=utf8[mysql.server]default-character-set=utf8[mysql_safe]default-character-set=utf8[client]default-character-set=utf8 basedir是解压目录,datadir是mysql存放数据的目录 然后打开电脑的环境变量 新建系统变量MYSQL_HOME=C:\mysql-8.0.11(解压路径) 在path中增加%MYSQL_HOME%\bin 在mysql的bin目录下运行初始化系统命令 1mysqld --initialize 初始化成功后，会在data文件夹下生成一些文件，其中xxx.err文件中说明了root账户的临时密码 如 1[Server] A temporary password is generated for root@localhost: JafC,2cE&lt;C# 那么JafC,2cE&lt;C#就是临时密码,一般在第二行就会看到 注册mysql服务 1mysqld -install MySQL 启动mysql服务 1net start MySQL 停止mysql服务 1net stop MySQL 先用root和临时密码登录数据库 ubuntu18安装mysql说明：此种方式完全参考官方提供的教程https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/。 注意：通过APT方式安装的版本都是现在最新的版本，现在我安装的是5.7.18。通过这种方式安装好之后开机自启动都已经配置好，和命令行上的环境变量，无需手动配置。 (可省略)下载官方提供的mysql-apt-config.deb包进行APT源设置，下载地址：https://dev.mysql.com/downloads/repo/apt/ 下载了,然后运行sudo dpkg -i xxx.deb 运行这个安装包 第一个确定进去选择5.7,然后选ok 然后运行sudo apt-get update 然后运行sudo apt-get install mysql-server 中间会让你输入密码 如果依赖不足,输入sudo apt-get install -f 打开etc\mysql\mysql.conf.d\mysql.cnf在下面加上 1character-set-server=utf8default-storage-engine = INNODBcollation-server = utf8_general_ci[mysql]default-character-set=utf8[mysql.server]default-character-set=utf8[mysql_safe]default-character-set=utf8[client]default-character-set=utf8 服务管理 1#启动sudo service mysql start#停止sudo service mysql stop#服务状态sudo service mysql status 通用 执行更改新密码 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;new_password&apos;; 刷新 1flush privileges; 退出重启服务器用新密码登录即可 改密码 1update user set authentication_string = password(&quot;new_password&quot;) where user=&apos;root&apos;;]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm学习第二天-虚拟机执行子系统]]></title>
    <url>%2F2020%2F03%2F18%2Fjvm%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E5%A4%A9-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[字节码简介Java字节码指令由一个字节长度的，代表某种特定操作含义的数字（操作码）以及其后的零至多个代表此操作所需参数（操作数）。此外字节码指令是面向操作数栈的，这里操作数栈在功能上对应实体机的寄存器但是结构上有所区别。 字节码与数据类型在字节码指令集中，大多数指令都对应的其操作所对应的数据类型信息，比如iload表示从局部变量表中加载int型的数据到操作栈中，fload从局部变量表中加载float型的数据到操作栈中…但是由于Java字节码的操作码只有一个字节（即0~255），这意味着指令集的操作码总数不可能超过256条。所以如果要求Java运行时所有的数据类型都有对应的与数据类型相关的指令去支持的话，操作码的总数将超过256条。所以JAVA字节码指令集被设计为Not Orthogonal（非完全独立）,即并非每种数据类型和每种操作都有对应的指令，有一些指令可以在必要的时候将一些不被支持的数据类型转换为被支持的数据类型。我们可以以数据类型为列，操作指令为行制作一张表，其中为空的项即说明虚拟机不支持对这种数据类型进行这项操作。 加载和存储指令加载和存储指令用于将数据在帧栈中的局部变量表和操作数栈之间传输。 将一个局部变量表加载到操作数栈：iload、iload_、lload、lload_、fload、fload_、dload、dload_、aload、aload_。将一个数值从操作数栈储存到局部变量表：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstore_,astore,astore_ 运算指令 运算指令用于对操作数栈上的值进行某种特定的运算。 加法运算：iadd,ladd,fadd,dadd。减法运算：isub,lsub,fsub,dsub。乘法运算：imul,lmul,fmul,dmul。除法运算：idiv,ldiv,fdiv,ddiv。求余指令：irem,lrem,frem,drem。取反指令：imeg,lmeg,fmeg,dmeg。位移指令：ishl,ishr,iushr,lshl,lshr,lushr。按位或指令：ior,lor。按位与指令：iand,land。按位异或指令：ixor,lxor。局部变量自增指令：iinc。比较指令：dcmpg,dcmpl,fcmpg,fcmpl,lcmp。注：只有在除法指令（idiv,ldiv)和求余指令（irem,lrem)当出现除数为零时会导致虚拟机抛出AirtmeticException异常，其余整形和浮点型运算场景都不会抛出异常 类型转换指令类型转换指令可以将两种不同数值类型进行相互转换。Java虚拟机天然支持基本数据类型的宽化类型转换，例如int到long、flost、double等。对于窄化数据类型转化则必须用显示的转换指令： i2b(int -&gt; boolean)i2c(int -&gt; char)i2s(int -&gt; short)l2i(long -&gt; int)f2i(float -&gt; int)f2l(float -&gt; long)d2i(double -&gt; int)d2l(double -&gt; long)d2f(double -&gt; float) 对象创建与访问指令创建类实例的指令：new创建数组的指令：newarray,anewarray,multianewarray访问类字段（static字段）和实例字段（非static字段）的指令：getfield,putfield,getstatic,putstatic将一个数组元素加载到操作数栈的指令:baload,caload,saload,iaload,faload,daload,aaload将一个操作数栈的值存储到数组元素中的指令：bastore,castore,iastore,sastore,fastore,fastore,dastore,aastore取数组长度的指令：arraylength检查类实例类型的指令：instanceof,checkcast 操作数栈管理指令将一个操作数栈的栈顶一个或两个元素出栈：pop、pop2。复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1,dup2_x1,dup_x2,dup2_x2。将栈顶端的两个数值交换：swap。控制转移指令 控制转移指令可以让Java虚拟机有条件或者无条件的从指定的位置而不是控制转移指令的下一条指令继续执行程序。 条件分支：ifeq,ifit,ifle,ifgt,ifnull,ifnonnull,if_icmpeq,if_icmpne,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne。复合条件分支：tableswitch,lookupswitch。无条件分支：gosto,goto_w,jsr,jsr_w,ret。 方法调用和返回指令invokevirtual:用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）。invokeinterface:用于调用接口方法，它在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。invokespecial:用于调用一些需要特殊处理的实例方法，包括实例的初始化方法，私有方法和父类方法。invokestatic:用于调用类方法（static方法）invokedynamic:用于运行时动态解析出调用点限定符所应用的方法，并执行该方法。（前面的分派逻辑都固化在虚拟机内部，而该指令的分派逻辑是由用户自定义）。方法返回指令：ireture(返回类型是int,short,byte,char,boolean时),lreturn,freturn,dreturn,areturn,另外还有一条return供void方法、实例/类/接口的初始化方法使用。 异常处理指令显式抛出异常指令：athrow 同步指令monitorenter,monitorexit 代码分析12345public void test()&#123; int a=10; int b=10; int c=a+b; &#125; 123456789 0 bipush 10//存入10到操作数栈 2 istore_1//弹出栈顶元素存入位置1的局部变量中,而且位置1对应的是a 3 bipush 10//存入10到操作数栈 5 istore_2//弹出栈顶元素存入位置2的局部变量中,而且位置2对应的是b 6 iload_1//取出局部变量表1位置的int型变量存放在栈顶 7 iload_2//取出局部变量表2位置的int型变量存放在栈顶 8 iadd//弹出操作数栈的两个元素求和并把结果存入操作数栈中 9 istore_3//弹出操作数栈顶元素存放在局部变量表3的位置，对应变量为c10 return 虚拟类的加载机制 类加载时机java语言中类型的加载连接以及初始化过程都是在程序运行期间完成的，这种策略虽然会使类加载时稍微增加一些性能开销，但是会为java应用程序提供高度的灵活性。java里天生就可以动态扩展语言特性就是依赖运行期间动态加载和动态连接这个特点实现的。比如，如果编写一个面向接口的程序，可以等到运行时再指定其具体实现类。（解析阶段则不一定:在某些情况下可以在初始化阶段之后开始，这是为了支持java语言的运行时绑定特性(也称为动态绑定或晚期绑定). 加载” 是 “类加载” 过程的一个阶段，切不可将二者混淆。 加载阶段由三个基本动作组成：1) 通过类型的完全限定名，产生一个代表该类型的二进制数据流（根本没有指明从哪里获取、怎样获取，可以说一个非常开放的平台了） 2) 解析这个二进制数据流为方法区内的运行时数据结构 3) 创建一个表示该类型的java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口。 主动加载和被动加载主动加载和被动加载的区别在于，主动加载会触发类的初始化。 类必须初始化的6种情况 使用new关键字实例化对象的时候、读取或设置一个类的静态字段的时候，已经调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。 当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类； 使用Jdk1.7动态语言支持的时候的一些情况。 当一个接口中定义了JDK8新加入的默认方法(被default关键字修饰的接口方法时，如果这个接口的实现类发生了初始化，那么该接口要在其之前被初始化) 加载加载”是“类加载”（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 相对于类加载过程的其他阶段，一个非数组类的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass（）方法）。 也就是说我们在加载的时候可以从很多地方加载，例如从压缩包加载，从网络加载，运行时计算生成等。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。 加载数组数组类本身不通过类加载器创建，它时有java虚拟机直接在内存中动态构造出来的，但数组类与类加载器仍然有很密切的关系，因为数组的元素类型（数组去掉所有维度的类型）最终还是要考类加载器来完成。 连接验证验证是链接阶段的第一步，这一步主要的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。 因为仅仅依靠java代码层面一些无法做到的事情java代码也可以表示出来，例如数组越界，所以jvm的编译期在字节码上看见这种事情会直接拒绝编译 验证阶段主要包括四个检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。 文件格式验证验证class文件格式规范，例如： class文件是否已魔术0xCAFEBABE开头 ， 主、次版本号是否在当前虚拟机处理范围之内等 元数据验证这个阶段是对字节码描述的信息进行语义分析，以保证起描述的信息符合java语言规范要求。验证点可能包括：这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)、这个类是否继承了不允许被继承的类(被final修饰的)、如果这个类的父类是抽象类，是否实现了起父类或接口中要求实现的所有方法。 字节码验证进行数据流和控制流分析，这个阶段对类的方法体进行校验分析，这个阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如：保证访法体中的类型转换有效，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但不能把一个父类对象赋值给子类数据类型、保证跳转命令不会跳转到方法体以外的字节码命令上。 符号引用验证准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区(方法区是一个逻辑上的区域，在JDK7之前，HoSpot使用永久代来实现方法区，这是符合这种逻辑概念的，但是在JDK8及其以后类变量会随着Class对象一起放在java堆中)中进行分配。这个阶段中有两个容易产生混淆的知识点，首先是这时候进行内存分配的仅包括类变量(static 修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为:**public static int value = 12; 那么变量value在准备阶段过后的初始值为0而不是12，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器()方法之中，所以把value赋值为12的动作将在初始化阶段才会被执行。 上面所说的“通常情况”下初始值是零值，那相对于一些特殊的情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，建设上面类变量value定义为：public static final int value = 123; 编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value设置为123 数据类型 零值 int 0 long 0L short (short)0 char ‘\u0000’ byte (byte)0 boolean false float 0.0f double 0.0d reference null 解析 解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。 直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。 虚拟机规范并没有规定解析阶段发生的具体时间，只要求了在执行anewarry、checkcast、getfield、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析，所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。 解析的动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。分别对应编译后常量池内的CONSTANT_Class_Info、CONSTANT_Fieldref_Info、CONSTANT_Methodef_Info、CONSTANT_InterfaceMethoder_Info四种常量类型。 类、接口的解析 字段解析 类方法解析 接口方法解析 初始化类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt; clinit &gt;()方法的过程。在以下四种情况下初始化过程会被触发执行： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化 jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类 在上面准备阶段 public static int value = 12; 在准备阶段完成后 value的值为0，而在初始化阶调用了类构造器&lt; clinit &gt;()方法，这个阶段完成后value的值为12。 类构造器&lt; clinit &gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句快可以赋值，但是不能访问。 类构造器&lt; clinit &gt;()方法与类的构造函数(实例构造函数&lt; init &gt;()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()方法已经执行完毕。因此在虚拟机中的第一个执行的&lt; clinit &gt;()方法的类肯定是java.lang.Object。 由于父类的&lt; clinit &gt;()方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。 &lt; clinit &gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，那么编译器可以不为这个类生成&lt; clinit &gt;()方法。 接口中不能使用静态语句块，但接口与类不太能够的是，执行接口的&lt; clinit &gt;()方法不需要先执行父接口的&lt; clinit &gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt; clinit &gt;()方法。 虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的&lt; clinit &gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit &gt;()方法完毕。如果一个类的&lt; clinit &gt;()方法中有耗时很长的操作，那就可能造成多个进程阻塞。]]></content>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA反射详解]]></title>
    <url>%2F2020%2F03%2F15%2FJAVA%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概述定义JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 用途最重要的用途就是解耦，许多框架配合java反射技术以及工厂模式进行解耦，也就是说通过配置文件的方式创建对象 获取字节码的方式 Class.forName(“全限定类名”);将字节码加载进内存，返回Class对象.(多用于配置文件中，读取配置文件加载类) 类名.Class：通过类名属性获取Class 对象.getClass():通过对象的父类Object定义的getClass()方法获取字节码 反射机制的相关类与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class类Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true Field类Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 Method类Method代表类的方法。 方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类Constructor代表类的构造方法。 方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 演示Person类 12345678public class Person &#123; private String name="默认值"; public int age; public String getName() &#123; return name; &#125;&#125; 获取Person的属性12345678910111213141516public static void main(String[] args) throws ClassNotFoundException &#123; Class personClass = Class.forName("Person");//这里要写全限定类名 //获取Person类的所有public属性 Field[] fields = personClass.getFields(); System.out.println("--------public属性--------"); for (Field field : fields) &#123; System.out.println(field.getName()); &#125; //获取Person类所有属性包括privice System.out.println("--------所有属性--------"); Field[] declaredFields = personClass.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(declaredField.getName()); &#125;&#125; 结果为 12345--------public属性--------age--------所有属性--------nameage 修改Person属性的值（甚至可以修改他的私有属性）12345678910111213public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class personClass = Class.forName("Person");//加载到内存 Person person = (Person) personClass.newInstance();//实例化对象 Field age = personClass.getField("age");//获取Public属性 age.setInt(person,12);//修改其属性值 //强行设置私有属性的值 Field name = personClass.getDeclaredField("name"); name.setAccessible(true);//取消 Java 语言访问检查，否则会报错 name.set(person,"当你在控制台看见我的时候,我已经修改了private的值啦!!!"); System.out.println("Public设置的值"+person.age+"\nprivate设置的值"+person.getName());&#125; 读取配置文件创建指定的类并执行指定的方法bean.Properties配置文件 12classpath=Personmethod=getName 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Properties;public class JVMTest&#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException, InstantiationException, IOException, NoSuchMethodException, InvocationTargetException &#123; //读取配置文件类似spring框架里面的配置文件 Properties properties=readProperties(); //实例化配置文件里面指定的类 Object ob=beanFactory((String) properties.get("classpath")); //运行实例化类的配置文件指定的方法并且接收返回值 Object rel=runMethod((String) properties.get("method"),ob); System.out.println(rel); &#125; /** * 运行指定的方法 * @param methodName 方法名 * @param cls 类 */ public static Object runMethod(String methodName,Object cls) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; Method method = cls.getClass().getMethod(methodName); return method.invoke(cls); &#125; /** * 根据传入的全类名创建对应的类 * @param classPath 全类名 * @return * @throws ClassNotFoundException * @throws IllegalAccessException * @throws InstantiationException */ public static Object beanFactory(String classPath) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123; return Class.forName(classPath).newInstance(); &#125; /** * 读取配置文件里面的信息并返回 * @return * @throws IOException */ public static Properties readProperties() throws IOException &#123; InputStream resourceAsStream = Object.class.getResourceAsStream("/bean.Properties"); Properties properties = new Properties(); properties.load(resourceAsStream); return properties; &#125;&#125; 运行结果 1默认值]]></content>
      <tags>
        <tag>JAVA</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm学习第一天-自动内存管理]]></title>
    <url>%2F2020%2F03%2F14%2Fjvm%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[运行时数据区域 方法区 堆 虚拟机栈 本地方法栈 程序计数器 其中前两个是线程共享的，后三个是线程独有的 程序计数器 程序计数器是一个记录着当前线程所执行的字节码的行号指示器。 如果线程执行的是一个java方法，那么这个计数器就表示正在执行的虚拟机字节码 如歌这个线程执行的是本地（Native）方法，那么这个计数器的值为空 虚拟机栈栈与堆的区别栈是一种运行时结构，堆是一种存储结构 虚拟机栈特点 和程序计数器一样是线程私有的 会产生oom错误 不需要GC（垃圾回收） 虚拟机栈运行过程每个方法被执行的时候，java虚拟机都会在虚拟机栈创建一个栈帧，当然，每个方法结束后都会移除该栈帧，也就是说在栈顶的栈帧一定是当前执行的方法的栈帧. 在编译程序代码的时候，栈帧中需要多大的局部变量表内存，多深的操作数栈都已经完全确定了。 因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。 栈帧 栈帧包含局部变量表，操作数栈，动态连接，方法出口等信息 两个栈帧的数据共享 局部变量表的共享 在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的，但是大多虚拟机的实现里都会进行一些优化处理，两个栈帧出现一部分重叠，这样做不仅节约了一些空间，更重要的是进行方法调用时就可以直接共用一部分数据。 局部变量表存放了编译期可知的各种java虚拟机基本数据类型和对象引用类型（reference），也有可能是指向对象的起始地址或者代表一个对象的句柄 局部变量表在编译期间确定大小 变量槽局部变量的存储使用变量槽表示，其中long和double使用两个变量槽 在方法运行期间不会改变局部变量表的大小，（大小指的是不会改变变量槽的数量） 1234567891011Slot复用 为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，也就是说当PC计数器的指令指已经超出了某个变量的作用域（执行完毕），那这个变量对应的Slot就可以交给其他变量使用。优点 ： 节省栈帧空间。 缺点 ： 影响到系统的垃圾收集行为。（如大方法占用较多的Slot，执行完该方法的作用域后没有对Slot赋值或者清空设置null值，垃圾回收器便不能及时的回收该内存。） 变量槽的复用当一个变量超出了他的作用域范围，那么这个变量的位置可以被复用. 演示1234567public void test()&#123; int a=1; &#123; int b=a; &#125; int c=2; &#125; 加入上述代码不存在复用的情况下应该是4个局部变量，但是由于b的作用域范围超出了，所以b的变量槽就被c所复用。也就是数上述代码分配的局部变量长度为3 异常如果线程请求的栈深度大于虚拟机所允许的深度，则会抛出StackOverFlowError异常，如果虚拟机栈容量可以动态扩展，当栈扩展无法申请到新的内存的时候会抛出OutOfMemoryError异常 操作数栈是一个后入先出的栈，和局部变量表一样，在编译时候他的最大深度被写入到了Code属性的max_stacks数据项中，其中32位数据占用容量为1,64位操作数占用容量为2 本地方法栈 本地方法栈和虚拟机栈功能是非常类似的，异常也是非常类似，本地方法栈就是执行一些（Native）的本地方法 在Hot-Spot虚拟机中将虚拟机栈和本地方法栈合二为一 JAVA堆java堆是虚拟机所管理的内存中最大的一块。（注意是虚拟机管理） 作用存放对象实例和数组 java对象实例几乎都在这上面存放（注意几乎） 特点 java堆被所有的线程所共享 java堆在物理上可以是不连续的，但是在逻辑上应该被视为连续的 堆大小是可以固定的，也是可以设置大小的（通过-Xmx和-Xms设置） 如果java虚拟机没有完成实例分配，并且堆也无法在扩展时，java虚拟机将会抛出OutOfMemoryError异常 方法区和java堆一样是各个线程共享的内存区域，他用于存储已经被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据，这里也是需要垃圾回收的。 运行时常量池运行时常量池是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项就是常量池。并且常量池相对于Class文件的另一个重要特征就是具备动态性 用于存放编译期生成的各种字面量与符号引用，这些内容在类加载后存放到方法区的运行时常量池中。 常量池无法申请到内存时会抛出OutOfMemoryError异常 如何判断对象是否死亡有项研究表明，新生代中的内存有百分之98熬不过第一轮回收 引用计数法在对象的内部添加一个引用计数器，当一个地方引用它时计数器就加一；当引用失效时，计数器值就减一，（java虚拟机并不是使用这种方法来进行判定的） 特点优点虽然占用了一些额外内存空间，但是它原理很简单，判定效率也很高。 缺点如果两个对象的静态变量相互持有对方，并且这两个对象永远不会执行，那么上面的方法是无法回收这两个“垃圾的” 可达性分析算法（java和C#都是使用这个算法进行判断对象是否存活）通过一系列称为“GC Roots”的根对象作为起始节点集，然后根据引用关系向下搜索，搜索过程中所走过的路径被称为引用链，如果某个对象与GC Roots间没有任何引用链相连，那么这个对象不可能再次被使用。 过程如果对象在进行可达性分析发现并没有与GC Roots相连，那么将会第一次标记这个对象，在随后进行一次筛选，筛选的条件是看看对象是否有必要执行finalize()方法，（一个对象只能被执行一次finalize方法），如果对象没有覆盖该方法或该方法已经被调用过了，那么就没有必要执行，对象将会被回收，如果执行了finalize方法，且对象在方法中重新持有了对象的引用，那么这个对象可以被救活。 扩展finalize()如今已经被官方声明为不推荐使用语法，有些教科书上说这个方法适合做一些对象被回收时的清理工作，事实上这是个错误的，try-catch-finally比这个方法更适合做这些事情。 知道了哪些对象已经死亡，那么如何清理这些对象分代收集理论收集器应该讲java堆划分不同区域，然后回收对象依据其年龄（即对象熬过垃圾收集过程的次数）分配到不同的区域中 如果一个区域中的对象都是朝生熄灭的，那么我们把他们放在一起，称他们为“新生代” 如果都是一些年龄比较大的那么我们把他们放在一起，称他们为”老年代” 带来的问题对象不是孤立的，对象之间可能出现跨代引用，但是我们可以得知，如果一个老年代对象引用了一个新生代的对象，那么这个新生代的对象大概率会存活，因为老年代对象引用了他。 标记-清除算法第一个阶段标记所有需要回收的对象，标记完成后统一回收所有的对象，当然也可以标记不要要回收的对象，标记完成后统一回收没有标记的对象。 特点 执行效率不稳定，如果java堆中包含大量对象。而且大部分是需要被回收的，这时必须进行大量标记和清除动作，导致标记和清除过程随着对象数量增长而降低。 内存空间的碎片化问题，标记后会产生大量不连续的内存碎片。 标记-复制算法将内存按容量划分为大小相等的两块，每次使用只使用其中的一块，当其中的一块用完后，就把所有存活的对象复制到另一块上面，然后把原来的内存块全部清除。 特点优点 解决了标记-除算法内存空间碎片化问题 实现简单运行高效，分配内存时按顺序分配即可 缺点 如果内存中多数对象都是存活的，那么这种算法复制时会产生大量的时间开销 内存浪费严重，将可用内存缩小了原来的一半 标记-整理算法和标记-清除算法一样，但是后续不是对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界内存。 特点缺点 如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，移动并更新所有这些对象的敌法将会是一个消耗极大的操作。 而且这种移动对象必须全程暂停用户应用程序。 作者：SnailClimb 简单的介绍一下强引用,软引用,弱引用,虚引用无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。 JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。 JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱） 强引用(StrongReference)以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 软引用(SoftReference)如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 弱引用(WeakReference)如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 虚引用（PhantomReference）“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。 经典垃圾收集器Serial收集器Serial收集器是最基础、历史最悠久的收集器，曾经（在JDK1.3.1之前）是HotSpot虚拟机新生代收集器的唯一选择，时至今日，垃圾收集器的不断改进，不断出新，Serial依然在我们的垃圾收集器的选项里面。 特点 优点：简单高效，拥有很高的单线程收集效率 缺点：收集过程需要暂停所有线程 使用算法：复制算法 适用范围：新生代 应用：Client模式下的默认新生代收集器 1对于Serial收集器缺点有一个比较有意思的故事：Serial收集器的运行过程需要暂停应用程序所有线程（Stop The World），它带给用户的恶劣体验。早期HotSpot虚拟机的设计者们表示完全理解，但也同时表示非常委屈：“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾，虽然垃圾收集这项工作听起来和打扫房间属于一个工种，但实际上肯定还要比打扫房间复杂得多！（现在的垃圾收集器一样需要停顿，只是都做到了毫秒级） 使用该垃圾收集器 -XX:+UseSerialGC使用之前我们可以去查看一下，当前虚拟机是否使用的Serial，如果是我们不需要去更改，如果不是则添加参数：-XX:+UseSerialGC。 ParNew收集器ParNew收集器实质上是Serial收集器的多线程并行版本 ParNew收集器的特点：优点：在多CPU时，比Serial效率高。 缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。 使用算法：复制算法 适用范围： 新生代应用：运行在Server模式下的虚拟机中首选的新生代收集器使用ParNew收集器 -XX:+UseParNewGC Parallel Scavenge收集器Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器……Parallel Scavenge的诸多特性从表面上看和ParNew非常相似，Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值。 吞吐量 = 运行用户代码时间/运行用户代码时间 + 运行垃圾收集器时间。 比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。 若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。 吞吐量我们可以自行控制？吞吐量我们从上面的描述可以看到，他是一个比值。那么我们自然能够通过调整比值的参数来影响吞吐量。主要涉及的命令有一下两个 -XX:MaxGCPauseMillis 控制最大的垃圾收集时间-XX:GCTimeRatio 直接设置吞吐量的大小根据吞吐量对应的计算公式我们可以看到，当我们的垃圾收集停顿时间变短的时候（垃圾收集停顿是一个大于0的毫秒数），我们的吞吐量在增大。不过大家不要异想天开地认为如果把这个参数的值设置得更小一点就能使得系统的垃圾收集速度变得更快，当我们把这个参数设置的更小的时候，它对应的能够有效收集的时间或者空间会变小。假若停顿时间为100ms能够收集500M的堆空间，那么50ms能够收集的空间可能会低于250M的堆空间。垃圾收集器的有效工作时间变短，收集垃圾的效率并不一定提高，同时对应的也只能相对的调整我们的吞吐量。 使用Parallel Scavenge收集器 -XX:+UseParallelGCSerial Old收集器Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。 Parallel Old收集器Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理算法”进行垃圾回收。 CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括： 1）初始标记（CMS initial mark）2）并发标记（CMS concurrent mark）3）重新标记（CMS remark）4）并发清除（CMS concurrent sweep）由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。 CMS收集器特点：优点：并发收集、低停顿缺点：产生大量空间碎片、并发阶段会降低吞吐量 使用CMS收集器 -XX:+UseConcMarkSweepGCGarbage First收集器Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它是一款主要面向服务端应用的垃圾收集器 使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 G1收集器的运作过程大致可划分为以下四个步骤：初始标记（Initial Marking）并发标记（Concurrent Marking）最终标记（Final Marking）筛选回收（Live Data Counting and Evacuation） 判断是否需要使用G1收集器？（1）50%以上的堆被存活对象占用（2）对象分配和晋升的速度变化非常大（3）垃圾回收时间比较长使用Garbage First收集器 -XX:+UseG1G]]></content>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中Native关键字]]></title>
    <url>%2F2020%2F03%2F13%2Fjava%E4%B8%ADNative%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Native 今天在看java.lang.Object类的时候发现有个静态代码块由Native修饰，并且很疑惑。 native关键字说明被修饰的方法是一个原生态方法，并且方法的实现并不是由java来实现的，而是通过其他语言实现的，例如C++，也可以理解为这是一个java平台和本地c代码交互的API全称Java Native Interface，简称JNI。 为什么需要有这个关键字呢 与java环境外交互，这是本地方法存在的主要原因 有些需求的实现对于java来说非常困难，而且有性能问题的时候需要借助本地方法实现 来着百科对JNI的解释SUN公司发布的Java 本地接口(JNI)提供了将Java与C/C++、汇编等本地代码集成的方案，该规范使得在 Java 虚拟机内运行的 Java 代码能够与其它编程语言互相操作，包括创建本地方法、更新Java对象、调用Java方法，引用 Java类，捕捉和抛出异常等，也允许 Java代码调用 C/C++或汇编语言编写的程序和库。作为一个标准程序接口，它没有对底层 Java虚拟机的实现施加任何限制，并具有以下特点： 二进制兼容。本地方法库与同一平台上所有Java 虚拟机之间实现二进制兼容，即对于给定平台开发人员只需要维护一种版本的本地方法库。 效率高。为了实现实时系统，JNI 在效率与虚拟机无关性之间进行了优化，以保障高效运行。 功能强。JNI 提供了大量的函数及接口让本地方法与Java 虚拟机内核相互操作，增强两者的功能。 本地代码与 Java 虚拟机之间是通过 JNI 函数实现相互操作的。JNI 函数通过接口指针来获得，本地方法将 JNI 接口指针当作参数来接受。虚拟机保证在从相同的 Java 线程中对本地方法进行多次调用时，传递给本地方法的接口指针是相同的，本地方法被不同的 Java 线程调用时，它接受不同的 JNI接口指针。 示例代码123456789public class HelloWorld &#123; public native void displayHelloWorld();//所有native关键词修饰的都是对本地的声明 static &#123; System.loadLibrary("hello");//载入本地库 &#125; public static void main(String[] args) &#123; new HelloWorld().displayHelloWorld(); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JNI</tag>
        <tag>Java Native Interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM虚拟机入门]]></title>
    <url>%2F2020%2F03%2F12%2FJVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JVM简介 JVM是JavaVirtualMachine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 6217002490002131915]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>java</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx入门]]></title>
    <url>%2F2020%2F03%2F11%2Fnginx%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[nginx入门简介 ginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。 其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。 三大功能反向代理什么是代理，和什么是反向代理正向代理加假如 你需要访问谷歌，但是你不能直接访问，需要借助翻墙软件，那么这种行为就是正向代理，即用户—&gt;访问翻墙的服务器(代理服务器)—-&gt;谷歌. 需要明确的是，这种代理服务器带你你访问的方法是由用户主动发起的，对于谷歌来说，他并不能直接知道你，也就是说谷歌对于用户来说是透明的（这里有点不恰当，能大概理解意思即可），但是用户对于谷歌来说谷歌并不知道用户是否使用了代理服务器 反向代理反向代理和正向代理恰好相反，即代理由用户主动变成了谷歌主动。反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。 负载均衡负载均衡：多在高并发情况下需要使用。其原理就是将数据流量分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。 Nginx可使用的负载均衡策略有：轮询（默认）、权重、ip_hash、url_hash(第三方)、fair(第三方)。 动静分离 常用于前后端分离，Nginx提供的动静分离是指把动态请求和静态请求分离开，合适的服务器处理相应的请求，使整个服务器系统的性能、效率更高。 Nginx可以根据配置对不同的请求做不同转发，这是动态分离的基础。静态请求对应的静态资源可以直接放在Nginx上做缓冲，更好的做法是放在相应的缓冲服务器上。动态请求由相应的后端服务器处理。 配置文件详解nginx 文件结构123456789101112131415161718192021222324252627... #全局块events &#123; #events块 ...&#125;http #http块&#123; ... #http全局块 server #server块 &#123; ... #server全局块 location [PATTERN] #location块 &#123; ... &#125; location [PATTERN] &#123; ... &#125; &#125; server &#123; ... &#125; ... #http全局块&#125; 1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。 2、events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。 3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。 4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。 5、location块：配置请求的路由，以及各种页面的处理情况。 配置举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid文件pid /usr/local/nginx/logs/nginx.pid;#指定进程可以打开的最大描述符：数目#工作模式与连接数上限#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误. open_file_cache_errors on;&#125; #设定http服务器，利用它的反向代理功能提供负载均衡支持http&#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream piao.jd.com &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配 #1、轮询（默认） #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 #2、weight #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 #例如： #upstream bakend &#123; # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #&#125; #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 #例如： #upstream bakend &#123; # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #&#125; #3、fair（第三方） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend &#123; # server server1; # server server2; # fair; #&#125; #4、url_hash（第三方） #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 #upstream backend &#123; # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #&#125; #tips: #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123; # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #&#125; #在需要使用负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表示单前的server暂时不参与负载 #2.weight为weight越大，负载的权重就越大。 #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 &#125; #虚拟主机的配置 server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.jd.com jd.com; index index.html index.htm index.php; root /data/www/jd; #对******进行负载均衡 location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #日志格式设定 #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。 #反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for&apos;; #定义本虚拟主机的访问日志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 &quot;/&quot; 启用反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数， #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。 #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小 proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置 #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic &quot;NginxStatus&quot;; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 &#125; #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ &#123; expires 15d; &#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>分页</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis入门]]></title>
    <url>%2F2020%2F03%2F11%2FRedis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Redis简介 REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 BSD协议 BSD开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。当你发布使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销 售，因此是对商业集成很友好的协议。 很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者 二次开发。 非关系型数据库什么是数据库？ 数据库是数据的仓库。 与普通的“数据仓库”不同的是，数据库依据“数据结构”来组织数据，因为“数据结构”，所以我们看到的数据是比较“条理化”的（比如不会跟以前的普通文件存储式存储成一个文件那么不条理化，我们的数据库分成一个个库，分成一个个表，分成一条条记录，这些记录是多么分明） 也因为其“数据结构”式，所以有极高的查找速率（比如B-Tree查找法），（由于专精，可以根据自己的结构特性来快速查找，所以对于数据库的查找会比较快捷；不像普通文件系统的“查找”那么通用） 如果与EXCEL来比的话，能明显的看出数据库的好处，我们能给一个个“字段”添加“约束”（比如约束一列的值不能为空） 数据库与普通的文件系统的主要区别（起因）：数据库能快速查找对应的数据 常说的XX数据库，其实实质上是XX数据库管理系统。数据库管理系统是一个软件，是数据库管理的程序实现。 什么是关系型数据库？ 关系型数据库是依据关系模型来创建的数据库。 所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型,因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。 关系型数据可以很好地存储一些关系模型的数据，比如一个老师对应多个学生的数据（“多对多”），一本书对应多个作者（“一对多”），一本书对应一个出版日期（“一对一”） 关系模型是我们生活中能经常遇见的模型，存储这类数据一般用关系型数据库 关系模型包括数据结构（数据存储的问题，二维表）、操作指令集合（SQL语句）、完整性约束(表内数据约束、表与表之间的约束)。 性能官方的bench-mark数据： 测试完成了50个并发执行100000个请求。 设置和获取的值是一个256字节字符串。 Linux box是运行Linux 2.6,这是X3320 Xeon 2.5 ghz。 文本执行使用loopback接口(127.0.0.1)。 结果:读的速度是110000次/s,写的速度是81000次/s 线程问题redis是单线程，线程安全 redis可以能够快速执行的原因： 绝大部分请求是纯粹的内存操作（非常快速） 采用单线程,避免了不必要的上下文切换和竞争条件 非阻塞IO - IO多路复用 IO多路复用中有三种方式：select,poll,epoll。需要注意的是，select,poll是线程不安全的，epoll是线程安全的 redis内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间 这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。 数据类型字符串、哈希、列表、集合、有序集合 类型 简介 特性 场景 String(字符串) 二进制安全 可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M — Hash(字典) 键值对集合,即编程语言中的Map类型 适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去) 存储、读取、修改用户属性 List(列表) 链表(双向链表) 增删快,提供了操作某一段元素的API 1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 Set(集合) 哈希表实现,元素不重复 1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作 1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐 Sorted Set(有序集合) 将Set中的元素增加一个权重参数score,元素按score有序排列 数据插入集合时,已经进行天然排序 1、排行榜 2、带权重的消息队列 String（字符串）string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。 实例1234redis 127.0.0.1:6379&gt; SET runoob "Hello World!"OKredis 127.0.0.1:6379&gt; GET runoob"Hello World!" 在以上实例中我们使用了 Redis 的 SET 和 GET 命令。键为 runoob，对应的值为 菜鸟教程。 注意：一个键最大能存储 512MB。 Hash（哈希）Redis hash 是一个键值(key=&gt;value)对集合。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 实例DEL runoob 用于删除前面测试用过的 key，不然会报错：(error) WRONGTYPE Operation against a key holding the wrong kind of value 1234567redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; HMSET runoob field1 "Hello" field2 "World""OK"redis 127.0.0.1:6379&gt; HGET runoob field1"Hello"redis 127.0.0.1:6379&gt; HGET runoob field2"World" 实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。 每个 hash 可以存储 232 List（列表）Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 实例123456789101112redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; lpush runoob redis(integer) 1redis 127.0.0.1:6379&gt; lpush runoob mongodb(integer) 2redis 127.0.0.1:6379&gt; lpush runoob rabitmq(integer) 3redis 127.0.0.1:6379&gt; lrange runoob 0 101) "rabitmq"2) "mongodb"3) "redis"redis 127.0.0.1:6379&gt; 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 Set（集合）Redis 的 Set 是 string 类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 sadd 命令添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。 1sadd key member 实例1234567891011121314redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; sadd runoob redis(integer) 1redis 127.0.0.1:6379&gt; sadd runoob mongodb(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabitmq(integer) 1redis 127.0.0.1:6379&gt; sadd runoob rabitmq(integer) 0redis 127.0.0.1:6379&gt; smembers runoob1) "redis"2) "rabitmq"3) "mongodb" 注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 zset(sorted set：有序集合)Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复。 zadd 命令添加元素到集合，元素在集合中存在则更新对应score 1zadd key score member 实例12345678910111213redis 127.0.0.1:6379&gt; DEL runoobredis 127.0.0.1:6379&gt; zadd runoob 0 redis(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq(integer) 1redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq(integer) 0redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 10001) "mongodb"2) "rabitmq"3) "redis"]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis常用命令]]></title>
    <url>%2F2020%2F03%2F09%2FRedis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Redis 常用命令登录 redis-cli -p 5566 -a password检查key是否存在 EXISTS key搜索某关键字 KSYS *4返回一个Key所影响的vsl的类型 TYPE key Stringset key value ：给数据库中名称为key的string赋予值value get key ：返回数据库中名称为key的string的value getset key value ：给名称为key的string赋予上一次的value mget key1 key2,… key N ：返回库中多个string的value setnx key value ：添加string，名称为key，值为value setex key time value ：向库中添加string，设定过期时间time mset key N value N ：批量设置多个string的值 msetnx key N value N ：如果所有名称为key i的string都不存在 incr key ：名称为key的string增1操作 incrby key integer ：名称为key的string增加integer decr key ：名称为key的string减1操作 decrby key integer ：名称为key的string减少integer append key value ：名称为key的string的值附加value substr key start end ：返回名称为key的string的value的子串 Hashhset key field value ：向名称为key的hash中添加元素field hget key field ：返回名称为key的hash中field对应的value hmget key fields ：返回名称为key的hash中field i对应的value hmset key fields ：向名称为key的hash中添加元素field hincrby key field integer ：将名称为key的hash中field的value增加integer hexists key field ：名称为key的hash中是否存在键为field的域 hdel key field ：删除名称为key的hash中键为field的域 hlen key ：返回名称为key的hash中元素个数 hkeys key ：返回名称为key的hash中所有键 hvals key ：返回名称为key的hash中所有键对应的value hgetall key ：返回名称为key的hash中所有的键（field）及其对应的value Listrpush key value ：在名称为key的list尾添加一个值为value的元素 lpush key value ：在名称为key的list头添加一个值为value的 元素 llen key ：返回名称为key的list的长度 lrange key start end ：返回名称为key的list中start至end之间的元素 ltrim key start end ：截取名称为key的list lindex key index ：返回名称为key的list中index位置的元素 lset key index value ：给名称为key的list中index位置的元素赋值 lrem key count value ：删除count个key的list中值为value的元素 lpop key ：返回并删除名称为key的list中的首元素 rpop key ：返回并删除名称为key的list中的尾元素 blpop key1 key2,… key N timeout ：lpop命令的block版本。 brpop key1 key2,… key N timeout ：rpop的block版本。 rpoplpush srckey dstkey ：返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部 setsadd key member ：向名称为key的set中添加元素member srem key member ：删除名称为key的set中的元素member spop key ：随机返回并删除名称为key的set中一个元素 smove srckey dstkey member ：移到集合元素 scard key ：返回名称为key的set的基数 sismember key member ：member是否是名称为key的set的元素 sinter key1 key2,…key N ：求交集 sinterstore dstkey keys ：求交集并将交集保存到dstkey的集合 sunion key1 keys ：求并集 sunionstore dstkey keys ：求并集并将并集保存到dstkey的集合 sdiff key1 keys ：求差集 sdiffstore dstkey keys ：求差集并将差集保存到dstkey的集合 smembers key ：返回名称为key的set的所有元素 srandmember key ：随机返回名称为key的set的一个元素 对value操作exists key ：确认一个key是否存在 del key ：删除一个key type key ：返回值的类型 keys pattern ：返回满足给定pattern的所有key randomkey：随机返回key空间的一个 keyrename oldname newname ：重命名key dbsize：返回当前数据库中key的数目 expire：设定一个key的活动时间（s） ttl：获得一个key的活动时间 select index ：按索引查询 move key dbindex ：移动当前数据库中的key到dbindex数据库 flushdb：删除当前选择数据库中的所有key flushall：删除所有数据库中的所有key]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
        <tag>非关系型数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之组合模式]]></title>
    <url>%2F2020%2F03%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合模式 组合模式也叫合成模式，用来描述部分和整体的关系。组合模式，也是很多人没有听说过的，那就不妨了解一下。其实组合模式就是上级管理下级的关系模式，比如说经理可以管理几个员工，他是有增删改查功能，而经理也是被总经理管理。。。 类型 结构型 适用场景 维护和战士部分-整体的场景，如树形菜单、文件和文件夹管理。 从一个整体中能够独立出部分模块或功能场景。 优点 高层模块调用简单：一颗树形结构中所有节点都是Component，局部和整体对调用者来说没有任何区别，高层模块不必关心自己处理的是单个对象还是整个组合结构。 节点自由增加：容易扩展，想要增加节点只要找到它的父节点就行，符合开闭原则，对后续的维护非常有利。 缺点 使得设计更加复杂。客户端需要花更多时间理清类之间的层次关系。 例子 定义 允许将对象组合成树形结构来表现”整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 特点 组件接口同时具有叶子节点和父节点的属性，具有2种角色。组合模式以单一责任设计原则换取透明性。 ### 代码实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.util.ArrayList;import java.util.List;/** * 菜单组件，同时具有菜单和菜的角色，菜单可以有子菜单 */abstract class MenuComponent &#123; /* 菜具有的方法 */ // 获取菜名 public String getName() &#123; throw new UnsupportedOperationException(); &#125; // 获取菜价格 public int getPrice() &#123; throw new UnsupportedOperationException(); &#125; /* 菜单具有的方法 */ // 向菜单中添加菜或子菜单 public void add(MenuComponent menuComponent) &#123; throw new UnsupportedOperationException(); &#125; /* 共有方法 */ public void print() &#123; throw new UnsupportedOperationException(); &#125;&#125;// 菜class MenuItem extends MenuComponent &#123; public String name; public int price; public MenuItem(String name, int price) &#123; this.name = name; this.price = price; &#125; @Override public String getName() &#123; return name; &#125; @Override public int getPrice() &#123; return price; &#125; @Override public void print() &#123; System.out.println("菜名: " + name + ": " + price); &#125;&#125;// 菜单class Menu extends MenuComponent &#123; // 用于存储菜名或子菜单 public List&lt;MenuComponent&gt; list = new ArrayList&lt;&gt;(); public String menuName; public Menu(String menuName) &#123; this.menuName = menuName; &#125; @Override public void add(MenuComponent menuComponent) &#123; list.add(menuComponent); &#125; @Override public String getName() &#123; return menuName; &#125; @Override public void print() &#123; System.out.println("菜单名: " + menuName); list.forEach(MenuComponent::print); &#125;&#125;// 客户端演示class Client &#123; public MenuComponent menuComponent; public void setMenuComponent(MenuComponent menuComponent) &#123; this.menuComponent = menuComponent; &#125; public void print() &#123; menuComponent.print(); &#125; public static void main(String[] args) &#123; Menu menu = new Menu("主菜单"); menu.add(new MenuItem("可乐", 3)); menu.add(new MenuItem("炸鸡", 15)); Menu subMenu = new Menu("子菜单"); subMenu.add(new MenuItem("汉堡", 20)); subMenu.add(new MenuItem("薯条", 10)); // 将子菜单加入主菜单 menu.add(subMenu); Client client = new Client(); client.setMenuComponent(menu); // 递归打印 client.print(); &#125;&#125; 总结这样我们就很方便的表示了整体和部分的关系]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
        <tag>结构型</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之代理模式]]></title>
    <url>%2F2020%2F03%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式代理(Proxy)是一种设计模式,提供了间接对目标对象进行访问的方式;即通过代理对象访问目标对象.这样做的好处是:可以在目标对象实现的功能上,增加额外的功能补充,即扩展目标对象的功能. 这就符合了设计模式的开闭原则，即在对既有代码不改动的情况下进行功能的扩展。 举个例子来说明代理的作用:明星与经纪人之间就是被代理和代理的关系,明星出演活动的时候，明星就是一个目标对象,他只要负责活动中的节目,而其他琐碎的事情就交给他的代理人(经纪人) 来解决.这就是代理思想在现实中的一个例子。 静态代理在使用静态代理时,被代理对象与代理对象需要一起实现相同的接口或者是继承相同父类，因此要定义一个接口或抽象类. 12345678910111213141516171819202122232425262728293031323334353637383940414243// 接口 interface IStar &#123; void sing(); &#125; // 真实对象 class LDHStar implements IStar &#123; @Override public void sing() &#123; System.out.println("刘德华唱歌"); &#125; &#125; // 代理类需要有真实对象的控制权 (引用) class ProxyManger implements IStar &#123; // 真实对象的引用 private IStar star; public ProxyManger() &#123; super(); &#125; public ProxyManger(IStar star) &#123; super(); this.star = star; &#125; @Override public void sing() &#123; System.out.println("唱歌前准备"); star.sing(); System.out.println("善后工作"); &#125; &#125;class Test&#123;public static void main(String[] args) &#123; // 创建明星对象 IStar ldh = new LDHStar(); ProxyManger proxy = new ProxyManger(ldh); proxy.sing(); &#125;&#125; 静态代理总结:优点：可以做到在不修改目标对象的功能前提下,对目标功能扩展.缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护. 而动态代理方式可以解决上面的问题 动态代理动态代理的主要特点就是能够在程序运行时JVM才为被代理对象生成代理对象。 常说的动态代理也叫做JDK代理也是一种接口代理，JDK中生成代理对象的代理类就是Proxy，所在包是java.lang.reflect 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//目标类接口interface IDog&#123; void run();&#125;//目标类class GunDog implements IDog&#123; @Override public void run() &#123; System.out.println("猎狗在跑"); &#125;&#125;class DogUtils&#123; public static void method1() &#123; System.out.println("增强方式一"); &#125; public static void method2() &#123; System.out.println("增强方式二"); &#125;&#125;class MyInvocationHandle implements InvocationHandler&#123; private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; DogUtils.method1(); method.invoke(target, args); DogUtils.method2(); return null; &#125;&#125; //生产代理对象的工厂 class MyProxyFactory&#123; public static Object getProxy(Object target) &#123; MyInvocationHandle handle = new MyInvocationHandle(); handle.setTarget(target); Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handle); return proxy; &#125; &#125;public class ProxyDemo &#123; public static void main(String[] args) &#123; IDog dog = new GunDog(); IDog proxy =(IDog) MyProxyFactory.getProxy(dog); proxy.run(); &#125;&#125; 总结：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能使用动态代理，因此这也算是这种方式的缺陷。 Cglib代理上面的静态代理和动态代理模式有个相同点就是都要求目标对象是实现一个接口的对象,然而并不是任何对象都会实现一个接口，也存在没有实现任何的接口的对象, 这时就可以使用继承目标类以目标对象子类的方式实现代理,这种方法就叫做:Cglib代理，也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展. 使用JDK动态代理有一个限制,就是被代理的对象必须实现一个或多个接口,若想代理没有实现接口的类,就需要使用Cglib实现. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class CglibProxy &#123; public static void main(String[] args) &#123; int[] arr = new int[100000]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = (int) (Math.random() * 1000); &#125; //实例化一个增强器，也就是cglib中的一个class generator Enhancer enhancer = new Enhancer(); //设置目标类 enhancer.setSuperclass(ArraySort2.class); //设置拦截对象，这里直接使用匿名内部类写法 enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object object , Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; String sortName = method.getName(); switch (sortName) &#123; case "bubbleSort": sortName = "冒泡排序"; break; case "selectSort": sortName = "选择排序"; break; case "quickSort": sortName = "快速排序"; break; default: break; &#125; long start = System.currentTimeMillis(); //此处一定要使用proxy的invokeSuper方法来调用目标类的方法 proxy.invokeSuper(object, args); long end = System.currentTimeMillis(); System.out.println("本次" + sortName + "的执行时间为: " + (end -start) + "ms"); return null; &#125; &#125;); //生成代理类并返回一个实例 ArraySort2 arraySort = (ArraySort2) enhancer.create(); arraySort.bubbleSort(arr); arraySort.selectSort(arr); arraySort.quickSort(arr); &#125; &#125;class ArraySort2&#123; public void quickSort(int[] arr) &#123; Arrays.sort(arr); &#125; public void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = i+1; j &lt; arr.length; j++) &#123; if (arr[i] &gt; arr[j]) &#123; int temp = 0; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; public void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; int temp = 0; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 总结： 在Spring的AOP编程中: 如果加入容器的目标对象有实现接口,用JDK代理 如果目标对象没有实现接口,用Cglib代理。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
        <tag>结构型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之装饰者模式]]></title>
    <url>%2F2020%2F03%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰者模式定义（动态扩展被装饰者类的功能） 在不改变原有对象的基础之上，将功能附加到对象上。提供了比继承更有弹性的替代方案（扩展原有对象功能） 类型 结构型 适用场景 扩展一个类的功能或者给一个类添加附加职责 给一个对象动态的添加功能，或动态撤销功能。 特点优点 可以动态扩展被装饰类的功能 继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能。（继承在扩展功能是静态的，必须在编译时就确定好，而使用装饰者可以在运行时决定，装饰者也建立在继承的基础之上的） 通过使用不同装饰类以及这些类的排列组合，可以实现不同的效果。 符合开闭原则 缺点 这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。 装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。 装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。 装饰者相关的设计模式 装饰者和代理模式 装饰者模式关注的是对象的动态添加功能。代理模式关注的是对对象的控制访问，对它的用户隐藏对象的具体信息。 装饰者模式和适配器模式 装饰者模式和被装饰的类要实现同一个接口，或者装饰类是被装饰的类的子类。 适配器模式和被适配的类具有不同的接口。 面开始看代码，看代码之前首先假设一个应用场景吧假设我们现在在路边摊看到一个卖煎饼果子的，现在想买煎饼果子，煎饼果子一般的话都是可以加鸡蛋加香肠什么的，好那我们就来模拟一下加在煎饼果子上加东西的操作。 首先我们看一下使用继承的方式怎么实现。 创建一个煎饼果子类 123456789public class Battercake &#123; protected String getDesc()&#123; return "煎饼果子"; &#125; protected int cost()&#123; return 8; &#125;&#125; 加鸡蛋类，我们让加鸡蛋类继承煎饼果子类 1234567891011public class BattercakeWithEgg extends Battercake &#123; @Override public String getDesc() &#123; return super.getDesc()+" 加一个鸡蛋"; &#125; @Override public int cost() &#123; return super.cost()+1; &#125;&#125; 加香肠类，同样的继承煎饼果子类。 1234567891011public class BattercakeWithEggSausage extends BattercakeWithEgg &#123; @Override public String getDesc() &#123; return super.getDesc()+ " 加一根香肠"; &#125; @Override public int cost() &#123; return super.cost()+2; &#125;&#125; 测试类 123456789101112131415public class DecoratorV1Test &#123; public static void main(String[] args) &#123; Battercake battercake = new Battercake(); System.out.println(battercake.getDesc()+" 销售价格:"+battercake.cost()); Battercake battercakeWithEgg = new BattercakeWithEgg(); System.out.println(battercakeWithEgg.getDesc()+" 销售价格:"+battercakeWithEgg.cost()); Battercake battercakeWithEggSausage = new BattercakeWithEggSausage(); System.out.println(battercakeWithEggSausage.getDesc()+" 销售价格:"+battercakeWithEggSausage.cost()); &#125;&#125; 输出结果 123煎饼 销售价格:8煎饼 加一个鸡蛋 销售价格:9煎饼 加一个鸡蛋 加一根香肠 销售价格:11 这样做有个问题，什么问题呢？假设我们现在要加2个鸡蛋呢？糟糕我们没写加2个鸡蛋的类，如果还有3个4个什么的那是不是就要类爆炸了。下面我们使用装饰者模式实现一下。 首先我们定义一个抽象的煎饼果子 12345public abstract class ABattercake &#123; protected abstract String getDesc(); protected abstract int cost();&#125; 实体煎饼果子类，实体煎饼果子继承了抽象煎饼果子类。 1234567891011public class Battercake extends ABattercake &#123; @Override protected String getDesc() &#123; return "煎饼"; &#125; @Override protected int cost() &#123; return 8; &#125;&#125; 装饰父类，这里也是可以使用抽象类，等会儿我们再说什么时候使用抽象类什么时候使用实体类。注意构造器和这个里面的花费、描述方法的写法。这里注入一个抽象煎饼类的对象。我们的获取描述花费的操作都委托抽象煎饼类来执行，为什么要这么做可以去看看我之前的文章依赖倒置原则。 12345678910111213141516public class AbstractDecorator extends ABattercake &#123; private ABattercake aBattercake; public AbstractDecorator(ABattercake aBattercake) &#123; this.aBattercake = aBattercake; &#125; @Override protected String getDesc() &#123; return this.aBattercake.getDesc(); &#125; @Override protected int cost() &#123; return this.aBattercake.cost(); &#125;&#125; 鸡蛋的装饰类，这里注意他的构造器，参数是父类的对象抽象煎饼类对象，这里获取描述和花费方法都是调用了父类的方法。 123456789101112131415public class EggDecorator extends AbstractDecorator &#123; public EggDecorator(ABattercake aBattercake) &#123; super(aBattercake); &#125; @Override protected String getDesc() &#123; return super.getDesc()+" 加一个鸡蛋"; &#125; @Override protected int cost() &#123; return super.cost()+1; &#125;&#125; 香肠装饰类 123456789101112131415public class SausageDecorator extends AbstractDecorator&#123; public SausageDecorator(ABattercake aBattercake) &#123; super(aBattercake); &#125; @Override protected String getDesc() &#123; return super.getDesc()+" 加一根香肠"; &#125; @Override protected int cost() &#123; return super.cost()+2; &#125;&#125; 最后是测试类，创建一个实体煎饼果子类并赋值给抽象煎饼果子类，然后将这个父类对象注入装饰类，再把得到的对象赋值给创建的抽象对象。 123456789101112public class DecoratorV2Test &#123; public static void main(String[] args) &#123; ABattercake aBattercake; aBattercake = new Battercake(); aBattercake = new EggDecorator(aBattercake); aBattercake = new EggDecorator(aBattercake); aBattercake = new SausageDecorator(aBattercake); System.out.println(aBattercake.getDesc()+" 销售价格:"+aBattercake.cost()); &#125;&#125; 输入结果 1煎饼 加一个鸡蛋 加一个鸡蛋 加一根香肠 销售价格:12 最后我们来说说装饰父类什么时候使用抽象类。一般当我们需要在具体的类中都需涛执行一些特定的操作时。我们一般就会使用抽象类，并定义抽象方法。 12345678910111213141516171819public abstract class AbstractDecorator extends ABattercake &#123; private ABattercake aBattercake; public AbstractDecorator(ABattercake aBattercake) &#123; this.aBattercake = aBattercake; &#125;//定义每个抽象类的独特方法 protected abstract void doSomething(); @Override protected String getDesc() &#123; return this.aBattercake.getDesc(); &#125; @Override protected int cost() &#123; return this.aBattercake.cost(); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
        <tag>结构型</tag>
        <tag>装饰者模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之适配器模式]]></title>
    <url>%2F2020%2F03%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式 适配器模式(Adapter Pattern)：将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。 根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。 角色Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。 Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。 类适配器假设要给一个手机充电，但是手机充电器只能是5v现在有一个220v的电源 被适配类，电源 12345678910111213package adapter;/** * 需要被使用的类 */public class Volt220 &#123; int v=220; public int volt()&#123; return v; &#125;&#125; 使用者,即充电器(只需要传入一个实现VoltInter接口的类传入即可充电) 1234567891011121314package adapter;/** * 手机充电器类 */public class PhoneCharger&#123; public void charger(VoltInter volt)&#123; if(volt.getVolt()!=5)&#123; System.out.println("电压不适配，无法充电"); &#125;else&#123; System.out.println("充电电压5V"); &#125; &#125;&#125; 接口 123456789101112package adapter;/** * 电压接口,要想给手机充电必须先实现这个接口 */public interface VoltInter &#123; /** * 获取电压 * @return */ public int getVolt();&#125; 适配器类(继承被适配类，实现使用者的接口或者抽象类) 123456789101112package adapter;/** * 适配器,基础被使用类，实现电源接口 */public class ChargerAdapter extends Volt220 implements VoltInter&#123; @Override public int getVolt() &#123; System.out.println("正在将"+super.volt()+"转换为5v"); return super.volt()/44; &#125;&#125; 这样一个类适配器就完成了，当然你肯定会有很多疑问，比如为什么要使用继承呢，不是继承违反了迪米特法则么，而不是把被适配者传入呢，别慌嘛，因为这是类适配器，底下肯定还要解决这个问题. 特点 违反了迪米特法则，增加了耦合度 因为继承了被适配类，所以可以根据需要重写被适配者，增加了灵活性 对象适配器只需要把上面的代码的适配器更改即可 12345678910111213141516171819package adapter;/** * 适配器,基础被使用类，实现电源接口 */public class ChargerAdapter implements VoltInter&#123; private Volt220 volt220; public ChargerAdapter(Volt220 volt220) &#123; this.volt220=volt220; &#125; @Override public int getVolt() &#123; System.out.println("正在将"+volt220.volt()+"转换为5v"); return volt220.volt()/44; &#125;&#125; 根据合成复用原则，这样通过传入参数的方式，当然也可以是接口，就解决了类适配器的问题。而且这种方式是一种较为常用的方式 特点 对象适配器和类适配器其实算是同一种思想，只是实现方式不同，根据合成复用原则，使用组合代替继承，所以他解决了继承被适配类的局限性问题，也不需要dist是接口 使用成本更低，更灵活 接口适配器模式当你想实现一个接口但又不想实现所有接口方法，只想去实现一部分方法时，就用中默认的适配器模式，他的方法是在接口和具体实现类中添加一个抽象类，而用抽象类去空实现目标接口的所有方法。而具体的实现类只需要覆盖其需要完成的方法即可。代码如下： 接口 1234567891011package adapter;/** * 有一个接口 */public interface Interface &#123; public void method1(); public void method2(); public void method3(); public void method4();&#125; 抽象类 123456789101112131415161718192021222324252627package adapter;/** *适配器 * 实现该接口所有的方法,但是都是空实现，方便使用这个抽象类的对象只需要关注其中一部分方法，无需全部实现 */public class Abstract implements Interface&#123; @Override public void method1() &#123; &#125; @Override public void method2() &#123; &#125; @Override public void method3() &#123; &#125; @Override public void method4() &#123; &#125;&#125; 客户端 123456789101112package adapter;public class Test &#123; public static void main(String[] args) &#123; //客户端使用只需要实现接口中的一部分即可，就无需实现该接口的所有实现类 new Abstract()&#123; @Override public void method1()&#123; &#125;; &#125;;&#125; 这种方法是不是很像gui编程里面事件监听呢，其实他们就是接口适配器模式。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>接口</tag>
        <tag>适配器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机推挽输出和开漏输出和准双向IO以及上拉电阻]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%8D%95%E7%89%87%E6%9C%BA%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E5%92%8C%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E5%92%8C%E5%87%86%E5%8F%8C%E5%90%91IO%E4%BB%A5%E5%8F%8A%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%2F</url>
    <content type="text"><![CDATA[推挽输出推挽输出既可以输出低电平，也可以输出高电平，可以直接驱动功耗不大的数字器件。 推挽电路是由两个三极管或MOSFET，以推挽方式存在于电路中，电路工作时，两只对称的开关管每次只有一个导通，所以导通损耗小、效率高、既提高电路的负载能力，又提高开关速度。其示意结构如下图所示： 当内部输出1电平时,上边的MOS管导通同时下边的MOS管截至,IO口输出高电平; 当内部输出0电平时,上边的MOS管截至同时下边的MOS管导通,IO口输出低电平; 开漏输出开漏输出只能输出低电平,如果要输出高电平必须通过上拉电阻才能实现。就类似于三级管的集电极输出,. 当io口为低电平的时候三极管不导通也就是输出低电平 当io口为高电平的时候三极管导通就输出高电平，也就是说让电路同时具备了高低电平的能力 准双向IO这个可以理解为吧开漏输出集成到了单片机的内部]]></content>
      <categories>
        <category>玩</category>
        <category>单片机</category>
        <category>电路基础</category>
      </categories>
      <tags>
        <tag>上拉电阻</tag>
        <tag>推挽</tag>
        <tag>开漏</tag>
        <tag>三极管</tag>
        <tag>准双向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之原型模式]]></title>
    <url>%2F2020%2F03%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式 原型模式是一种创建型设计模式,它通过复制一个已经存在的实例来返回新的实例,而不是新建实例.被复制的实例就是我们所称的原型,这个原型是可定制的.原型模式多用于创建复杂的或者耗时的实例, 因为这种情况下,复制一个已经存在的实例可以使程序运行更高效,或者创建值相等,只是命名不一样的同类数据. 特点原型模式中的拷贝分为”浅拷贝”和”深拷贝”:浅拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对 深拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制. 场景现在有一个问题假设我们需要创建一个对象一百次。你就想了，这很简单啊，直接for循环new它一百次就是ojbk了，其实有一个更好的办法，这个办法速度更快，就是java提供的复制 浅拷贝Person类,其中我们只要实现Cloneable接口里面的clone方法即可实现克隆 123456789101112131415161718192021222324252627282930313233343536373839404142434445package Protptype;public class Person implements Cloneable&#123; private String name; private int age; private Person friend; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person getFriend() &#123; return friend; &#125; public void setFriend(Person friend) &#123; this.friend = friend; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + ", friend=" + friend + '&#125;'; &#125;&#125; 但是我为什么标题说他是浅拷贝呢，请看接下来的例子 12345678910111213141516171819202122232425262728293031package Protptype;public class Test &#123; public static void main(String[] args) &#123; Person friend=new Person(); friend.setName("小明"); Person person=new Person(); person.setName("小红"); person.setAge(18); person.setFriend(friend); Person clone=null; try &#123; clone= (Person) person.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; System.out.println("改名前"); System.out.println(person); System.out.println(clone); friend.setName("王小明"); person.setName("王小红"); System.out.println("改名后"); System.out.println(person); System.out.println(clone); &#125;&#125; 123456改名前Person&#123;name=&apos;小红&apos;, age=18, friend=Person&#123;name=&apos;小明&apos;, age=0, friend=null&#125;&#125;Person&#123;name=&apos;小红&apos;, age=18, friend=Person&#123;name=&apos;小明&apos;, age=0, friend=null&#125;&#125;改名后Person&#123;name=&apos;小红&apos;, age=18, friend=Person&#123;name=&apos;王小明&apos;, age=0, friend=null&#125;&#125;Person&#123;name=&apos;小红的克隆人&apos;, age=18, friend=Person&#123;name=&apos;王小明&apos;, age=0, friend=null&#125;&#125; 从上面看出来，当小红的朋友改名字的时候克隆人的朋友也跟着改名字，这么说明他俩的朋友是同一个人，也就是说发生了值复制，也说明了浅复制对于普通变量来说是值复制，对于引用变量来说只是复制了引用，但是为什么改了名字，克隆人的名字和原来人的名字没有一起变化呢，难道string不是引用变量么，不不不，因为String特殊的原因，这里两人的String不是同一个对象，那么我们应该如何实现深复制呢 深复制(clone方法里面clone引用型变量)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package Protptype;public class Person implements Cloneable&#123; private String name; private int age; private Person friend; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person getFriend() &#123; return friend; &#125; public void setFriend(Person friend) &#123; this.friend = friend; &#125; @Override public Object clone() throws CloneNotSupportedException &#123;//在克隆方法中手动复制子类 Person person= (Person) super.clone(); person.setFriend(new Person()); return person; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + ", friend=" + friend + '&#125;'; &#125;&#125; 深复制(使用序列化和反序列化推荐使用)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package Protptype;import java.io.*;public class Person implements Cloneable,Serializable&#123; private String name; private int age; private Person friend; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public Person getFriend() &#123; return friend; &#125; public void setFriend(Person friend) &#123; this.friend = friend; &#125; @Override public Object clone() throws CloneNotSupportedException &#123;//在克隆方法中手动复制子类 return super.clone(); &#125; /** * 深克隆，使用序列化和反序列化进行克隆 * @return * @throws IOException * @throws ClassNotFoundException */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /** * 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject( this ); /** * 写出当前对象二进制流 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois; ois = new ObjectInputStream(bis); return ois.readObject(); &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + ", friend=" + friend + '&#125;'; &#125;&#125; 结果 123456改名前Person&#123;name=&apos;小红&apos;, age=18, friend=Person&#123;name=&apos;小明&apos;, age=0, friend=null&#125;&#125;Person&#123;name=&apos;小红&apos;, age=18, friend=Person&#123;name=&apos;小明&apos;, age=0, friend=null&#125;&#125;改名后Person&#123;name=&apos;小红&apos;, age=18, friend=Person&#123;name=&apos;王小明&apos;, age=0, friend=null&#125;&#125;Person&#123;name=&apos;小红的克隆人&apos;, age=18, friend=Person&#123;name=&apos;小明&apos;, age=0, friend=null&#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>原则</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之工厂模式]]></title>
    <url>%2F2020%2F03%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式 厂模式又称为创建模式，它是建对象的一种最佳方式。工厂模式的本质就是用工厂方法代替new操作创建一种实例化对象的方式。一句话中总结就是方便创建 同种类型接口产品 的 复杂对象。 重要特征根据传入的参数不同，来获取大量的对象 适用场景 创建对象需要大量重复的代码。 创建对象需要访问某些信息，而这些信息不应该包含在复合类中。 创建对象的生命周期必须集中管理，以保证在整个程序中具有一致的行为。 简单工厂模式简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码逻辑将会非常复杂。 直接看代码：定义一个抽象产品类形状类Shape 123abstract class Shape()&#123; public abstract void shape();&#125; 定义具体产品： 123456789101112131415class Circle extends Shape&#123; public void shape()&#123; System.out.println("圆形"); &#125;&#125;class Rectangle extends Shape&#123; public void shape()&#123; System.out.println("矩形"); &#125;&#125;class Triangle extends Shape&#123; public void shape()&#123; System.out.println("三角形"); &#125;&#125; 定义一个工厂生产具体产品 12345678910111213141516public class ShapeFactory&#123; public static Shape getshape(String sh)&#123; if(sh.equals("圆形"))&#123; return new Circle(); &#125;else if(sh.equals("矩形"))&#123; return new Rectangle(); &#125;else if(sh.equals("三角形"))&#123; return new Triangle(); &#125;else &#123; return null; &#125; &#125; public static void main(String args[])&#123;//根据需要获取指定对象，和new相比向当于交出了对象的创建 ShapeFactory.getshape("圆形").shape(); &#125;&#125; 从简单工厂中我们可以看出使用一个静态方法将实例化的创建和使用分离开。我们只需要调用方法传递参数就可以获得我们需要的对象。 缺点:我们不难看出如果我们想要增加一个形状类的产品不仅需要添加一个导出类而且我们必须要修改静态方法getshape，这样就违背了开闭原则（对于扩展是开放的，对于修改是封闭的） 工厂模式 假如说我们吧工厂也抽象出来，每次修改工厂产品的时候我们都可以写一个真正的工厂实现抽象工厂，那么我们是不是就解决了简单工厂没有遵守的开闭原则 抽象工厂：为具体工厂提供接口，也就是提供规范，只能有一个。 具体工厂：实现抽象工厂接口的类，可以有多个，根据需要生产的产品的变化可以使用其他的具体工厂 抽象产品：具体产品的父类。 具体产品：工厂模式中所有创建的对象都是具体产品的实例。 直接看代码：定义一个抽象产品类形状类Shape和一个工厂超类 123456abstract class Shape()&#123; public abstract void shape();&#125;abstract class Factory()&#123; public abstract void CreatShape();&#125; 定义具体产品： 123456789101112131415class Circle extends Shape&#123; public void shape()&#123; System.out.println("圆形"); &#125;&#125;class Rectangle extends Shape&#123; public void shape()&#123; System.out.println("矩形"); &#125;&#125;class Triangle extends Shape&#123; public void shape()&#123; System.out.println("三角形"); &#125;&#125; 定义多个个工厂生产具体产品 123456789101112131415161718public class CircleFactory extends Factory &#123; public static Shape CreatShape(String sh)&#123; if(sh.equals("圆形"))&#123; return new Circle(); &#125;else &#123; return null; &#125; &#125;&#125;public class RectangleFactory&#123; public static Shape CreatShape(String sh)&#123; if(sh.equals("矩形"))&#123; return new Rectangle(); &#125;else &#123; return null; &#125; &#125;&#125; 客户端 123456789public class Test&#123; public static void main(String args[])&#123; //根据需要获取指定对象，和new相比向当于交出了对象创建 getshape(new CircleFactory()); &#125; public static void getshape(Factory fac)&#123; fac.CreatShape().shape(); &#125;&#125; 如上所示：即使我们增加一个新的形状类，我们也只需要增加相应的工厂类，不需要修改代码的任何方法。当我们需要这个新产品的时候我们只需要getshap（new 新的工厂类），其他的我们不用去关心，不需要了解方法的实现，对象是如何创建的，我们只需要调用方法就行了——良好的封装性。优点： 良好的封装性：如上面所说。 可以是代码结构变得清晰，有效的封装变化，通常new一个具体类是很复杂多变的，通过工厂方法将new的过 程封装在具体工厂的方法中，调用者无须知道实例化的过程，只需要调用方法就可以得到自己想要的产品。 优点 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销； 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类； 一个具体工厂只能创建一种具体产品 缺点 当一个类不知道它所需要的对象的类时 在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可； 当一个类希望通过其子类来指定创建对象时 在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 工厂模式举例java.lang.Calendar类就是一个单例模式+简单工厂模式]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>原则</tag>
        <tag>工厂设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例设计模式]]></title>
    <url>%2F2020%2F03%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式 单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。 优点： 在内存中只有一个对象，节省内存空间； 避免频繁的创建销毁对象，可以提高性能； 避免对共享资源的多重占用，简化访问； 为整个系统提供一个全局访问点。 缺点： 不适用于变化频繁的对象； 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出； 如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失； 单例设计模式种类 恶汉式 懒汉式 双重检查 静态内部类 枚举 恶汉式(成员变量)1234567891011121314151617181920212223242526public class Singleton01 &#123; public static void main(String[] args) &#123; System.out.println("单例设计模式恶汉式~"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); &#125;&#125;/** * 单例设计模式恶汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 02.提供静态方法提供给外部获取该类 */class Singleton &#123; private Singleton()&#123;&#125;; //final可以优化 private static final Singleton singleton=new Singleton(); public static Singleton getInstance()&#123; return singleton; &#125;&#125; 特点 只要类加载就立刻创建对象 如果这个类永远没有被使用那么还是会创建这个对象并且浪费内存 由于在类装载的时候实例化这个对象，所以不会造成线程安全问题 恶汉式(静态代码块)123456789101112131415161718192021222324252627282930public class Singleton01 &#123; public static void main(String[] args) &#123; System.out.println("单例设计模式恶汉式~"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); &#125;&#125;/** * 单例设计模式恶汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 02.提供静态方法提供给外部获取该类 */class Singleton &#123; static &#123; singleton=new Singleton(); &#125; private Singleton()&#123;&#125;; private static Singleton singleton; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 特点这个特点和上面一样 懒汉式(延迟加载，但线程不安全)12345678910111213141516171819202122232425262728293031public class Singleton01 &#123; public static void main(String[] args) &#123; System.out.println("单例设计模式懒汉式~线程不安全"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); &#125;&#125;/** * 单例设计模式懒汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 03.提供静态方法提供给外部获取该类 * 04.提供静态方法中判断是否已经创建对象 */class Singleton &#123; private Singleton()&#123;&#125;; private static Singleton singleton; public static Singleton getInstance()&#123; if(singleton==null)&#123; //有可能多个线程同时进入这个代码块，以至于单例模式并不单例 singleton=new Singleton(); &#125; return singleton; &#125;&#125; 特点 实现了懒加载，保证了不浪费内存，但是带来了新的问题 在多线程的情况下有可能创建多个Singleton对象 懒汉式(延迟加载，方法同步)12345678910111213141516171819202122232425262728293031public class Singleton01 &#123; public static void main(String[] args) &#123; System.out.println("单例设计模式懒汉式~线程不安全"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); &#125;&#125;/** * 单例设计模式懒汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 03.提供静态方法提供给外部获取该类 * 04.提供静态方法中判断是否已经创建对象 */class Singleton &#123; private Singleton()&#123;&#125;; private static Singleton singleton; //相比上面的添加了方发锁，来保证线程安全问题，但是多个线程创建对象的时候其他现在必须在外部等待 public static synchronized Singleton getInstance()&#123; if(singleton==null)&#123; singleton=new Singleton(); &#125; return singleton; &#125;&#125; 特点 实现了懒加载，也避免了线程安全问题。 但是由于同步方法颗粒度过大，导致创建的时候验证影响效率 懒汉式(延迟加载，双重检查)1234567891011121314151617181920212223242526272829303132333435public class Singleton01 &#123; public static void main(String[] args) &#123; System.out.println("单例设计模式懒汉式~线程不安全"); Singleton singleton1=Singleton.getInstance(); Singleton singleton2=Singleton.getInstance(); System.out.println(singleton1==singleton2); &#125;&#125;/** * 单例设计模式懒汉式~ * 01.私有化构造器，防止外部重复new对象 * 02.私有化静态成员变量防止外部修改对象引用 * 03.提供静态方法提供给外部获取该类 * 04.提供静态方法中判断是否已经创建对象 */class Singleton &#123; private Singleton()&#123;&#125;; private static volatile Singleton singleton; public static Singleton getInstance()&#123; if(singleton==null)&#123; synchronized (Singleton.class)&#123; //在创建单例设计模式的时候双重检查保证了多个线程中只有一个线程去创建静态对象，二其他线程无需等待 if(singleton==null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 关于volatile关键字的使用，在单线程的环境下是不存在指令重排的情况，涉及到多线程就会涉及到指令重排。比如创建对象大致为三个过程：1.开辟内存空间2.创建对象。3.对象指定内存空间。在创建对象的过程中，多线程环境中是不一定会按照指令的顺序来进行创建对象。所以需要添加volitile关键字，保证对象是创建完毕再继续使用。 特点 实现了该类的懒加载 解决了线程问题，并且也解决了性能问题,推荐使用 静态内部类1234567891011121314class Singleton1&#123; private static Singleton1 singleton; private Singleton1()&#123;&#125;; private static class LazyHolder &#123; //防止内部误操作，不小心对其使用了代理或者其他的情况，final修饰，不允许改变 private static final Singleton1 INSTANCE = new Singleton1(); &#125; public static Singleton1 getInstance()&#123; return LazyHolder.INSTANCE; &#125;&#125; 通过内部类来实现懒加载单例模式，该种实现方式也较为常用。关于内部类实现懒加载的解释：类信息只有在使用其Class相关的时候才会加载字节码相关的类信息。静态内部类同样如此，只有在用到静态内部类的时候才会去用到我们内部类的静态相关信息。所以称其为懒加载。 很多种单例的写法都有一个通病，就是无法防止反射机制的漏洞，从而无法保证对象的唯一性，如下举例： 利用如下的反正代码对上文构造的单例进行对象的创建。 枚举123456enum Singleton1 &#123; INSTANCE; public void sayOk()&#123; System.out.println("OK"); &#125;&#125; 嘿嘿嘿就是这么简单。 其实这就是 enum 的一块语法糖，JVM 会阻止反射获取枚举类的私有构造方法。 仍然使用上文的反射代码来进行测试，发现，报错。嘿嘿，完美解决反射的问题。 4、缺点 使用枚举的方法是起到了单例的作用，但是也有一个弊端， 那就是 无法进行懒加载。 单例模式举例java.lang.Runtime这个类就是个典型的懒汉模式单例设计模式]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>原则</tag>
        <tag>单例设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之七大原则]]></title>
    <url>%2F2020%2F02%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[设计模式什么是设计模式 设计模式最早是从建筑领域引入到软件工程领域的，软件开发者在平时开发软件的时候发现有些场景和需求在不同的软件开发中是很相似的，于是乎将这些解决方案抽象出来就形成了设计模式 设计模式的目的和作用(5大作用目的) 代码重用性 可读性 可扩展性 可靠性 使程序呈现高内聚，低耦合的特性 设计模式的七大原则 单一职责原则 接口隔离原则 依赖倒置(倒转)原则 里氏替换原则 迪米特法则 合成复用原则 单一职责原则介绍 对于一个类来说一个类应该只负责一项职责，如果一个类负责多个职责，则应该拆分这个类，（如果这个类功能特别单一则可以违反类单一职责原则，但是要遵循方法单一职责原则） 举例太简单了，太容易了就不举例了╮(╯▽╰)╭ 单一职责原则细节和注意事项 降低类的复杂度，一个类只负责一项职责 提高类的可读性，可维护性 降低变更引起的风险 通常情况下要遵守单一职责原则，只有逻辑足够简单，才可以违反类单一则责原则，但是要在方法层面上遵循单一职责原则 接口隔离原则介绍 一个类不应该依赖他不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。 举例类A和类B都依赖一个接口interface,并且类A只需要这个接口的前几个方法，而类B只需要后几个方法，类A1和类B1都是对该接口的实现，不过类A1主要由类A调用实现，如果只有一个接口的话，那么类A1和类B1都要实现这个接口的所有方法。 错误示范1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859interface I &#123; public void method1(); public void method2(); public void method3(); public void method4(); public void method5();&#125;class A&#123; public void depend1(I i)&#123; i.method1(); &#125; public void depend2(I i)&#123; i.method2(); &#125; public void depend3(I i)&#123; i.method3(); &#125;&#125;class A1 implements I&#123; public void method1() &#123; System.out.println("类A1实现接口I的方法1"); &#125; public void method2() &#123; System.out.println("类A1实现接口I的方法2"); &#125; public void method3() &#123; System.out.println("类A1实现接口I的方法3"); &#125; //对于类A1来说，method4和method5不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method4() &#123;&#125; public void method5() &#123;&#125;&#125;class B&#123; public void depend2(I i)&#123; i.method4(); &#125; public void depend3(I i)&#123; i.method5(); &#125;&#125;class B1 implements I&#123; public void method1() &#123;&#125; //对于类B1来说，method2和method3不是必需的，但是由于接口A中有这两个方法， //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。 public void method2() &#123;&#125; public void method3() &#123;&#125; public void method4() &#123; System.out.println("类B1实现接口I的方法4"); &#125; public void method5() &#123; System.out.println("类B1实现接口I的方法5"); &#125;&#125; 正确示范上述情况其实我们可以把I接口分解成两个接口，让A1实现接口一让B1实现接口2即可，这样就隔离开了这两个接口，并且这两个接口都是他们的最小接口，那这样就是接口隔离原则了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152interface I1 &#123; public void method1(); public void method2(); public void method3();&#125;interface I2 &#123; public void method4(); public void method5();&#125;class A&#123; public void depend1(I1 i)&#123; i.method1(); &#125; public void depend2(I1 i)&#123; i.method2(); &#125; public void depend3(I1 i)&#123; i.method3(); &#125;&#125;class A1 implements I1&#123;//那么就可以不实现4和5方法了 public void method1() &#123; System.out.println("类A1实现接口I1的方法1"); &#125; public void method2() &#123; System.out.println("类A1实现接口I1的方法2"); &#125; public void method3() &#123; System.out.println("类A1实现接口I1的方法3"); &#125;&#125;class B&#123; public void depend2(I2 i)&#123; i.method4(); &#125; public void depend3(I2 i)&#123; i.method5(); &#125;&#125;class B1 implements I2&#123; public void method4() &#123; System.out.println("类B1实现接口I2的方法4"); &#125; public void method5() &#123; System.out.println("类B1实现接口I2的方法5"); &#125;&#125; 接口隔离原则细节和注意事项 接口要高内聚。什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互. 定制服务。一个系统或系统内的模块之间必然会有耦合，有耦合就要相互访问的接口（并不一定就是Java中定义的Interface，也可能是一个类或者是单纯的数据交换），我们设计时就需要给各个访问者（也就是客户端）定制服务，什么是定制服务？单独为一个个体提供优良优良的服务。我们在做系统设计时也需要考虑对系统之间或模块之间的定义要采用定制服务，采用定制服务就必然有一个要求就是：只提供访问者需要的方法，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 接口尽量小，但是要有限度。接口的设计粒度是越小系统越灵活，这是不争的事实，但是这就带来成接口数量过多，使设计结构的复杂化，开发难度增加，维护性降低，这不是一个项目或产品所期望看到的。所以一定要适度。 依赖倒置原则介绍 1、高层模块不应该依赖底层模块，二者都应该依赖抽象。 2、抽象不应该依赖细节，细节应该依赖抽象。 3、依赖倒置的中心思想是面向接口编程。 4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。 5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。 举例错误示范假如我喜欢玩游戏，那么有两个类，一个类是我只有一个方法就是玩，然后还有一个游戏类 123456789101112131415class My&#123; public void play(Game i)&#123; System.out.println("我在玩"+i.getName()); &#125;&#125;class Factorio&#123; public String getName()&#123; return "异星工厂"; &#125;&#125;public class Test&#123; public static void main(String[]args)&#123; new My().play(new Factorio()); &#125;&#125; 假如说我玩的游戏不知一个，有多个游戏那么上面代码怎么办呢，是不是就需要写多个play方法重载之类进行解决呢。 正确示范1234567891011121314151617181920212223242526272829interface Play&#123; public void getName();&#125;class My&#123; public void play(Play i)&#123; System.out.println("我在玩"+i.getName()); &#125;&#125;class Factorio implements Play&#123; public String getName()&#123; return "异星工厂"; &#125;&#125;class BF4 implements Play&#123; public String getName()&#123; return "战地4"; &#125;&#125;public class Test&#123; public static void main(String[]args)&#123; new My().play(new Factorio()); new My().play(new BF4()); &#125;&#125; 这样每次新增功能的改动就非常小了 注意事项 低层模块尽量都要有抽象类或者接口，或者而知都有，这样程序稳定性更好 变量的生命类型尽量是抽象类或者接口，这样我们的变量引用和实际对象间就存在一个缓存层，利于程序的扩展和优化 继承时遵循里氏原则 抽象不应该依赖细节 细节应该依赖抽象 里氏替换原则介绍 里氏替换原则(LSP)指的是所有引用基类的地方都可以透明的使用其子类的对象 可以理解为:只要有父类出现的地方，都可以使用子类来替代。而且不会出现任何错误或者异常。但是反过来却不行。子类出现的地方,不能使用父类来替代。 如果不符合上述的规定的话，我们可以想象子类的实例化调用方法时候,调用的确实父类的方法。会出现意想不到的结果 代码就不放出来了,这个也没有啥好说的里氏替换原则细节和注意事项 子类必须实现父类的抽象方法，但不得重写父类的非抽象(已实现的)方法。 子类中可增加自己特有的方法。(可以随时扩展) 当子类覆盖或者实现父类的方法时,方法的前置条件(方法形参)要比父类输入参数更加宽松。否则会调用到父类的方法。 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。否则会调用到父类的方法。 开闭原则定义 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 举例现在有一个图形基础类还有两个继承图形基础类的子类三角形和正方形，还有一个工具类可以将传入的图形之类画出来 错误示范123456789101112131415161718192021222324252627282930313233343536class Graph&#123; Integer id;&#125;class Triangle extends Graph&#123; public Triangle()&#123; super.id=1; &#125; public void drawTriangle()&#123; System.out.println("画三角形"); &#125;&#125;class Square extends Graph&#123; public Triangle()&#123; super.id=2; &#125; public void drawSquare()&#123; System.out.println("画正方形"); &#125;&#125;class Painting&#123; void painting(Graph g)&#123; if(g.id==1)&#123; g.drawTriangle(); &#125;else if(g.id==2)&#123; g.drawSquare(); &#125; &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Painting p=new Painting(); p.painting(new drawTriangle()); &#125;&#125; 如果现在我们有一个新的需求需要添加一个新的图形，那么一定得修改工具类Painting里面的方法，而且还要添加新的类 正确示范12345678910111213141516171819202122232425262728293031323334class Graph&#123; Integer id; abstract void draw();&#125;class Triangle extends Graph&#123; public Triangle()&#123; super.id=1; &#125; public void draw()&#123; System.out.println("画三角形"); &#125;&#125;class Square extends Graph&#123; public Triangle()&#123; super.id=2; &#125; public void draw()&#123; System.out.println("画正方形"); &#125;&#125;class Painting&#123; void painting(Graph g)&#123; g.draw(); &#125;&#125;public class Test&#123; public static void main(String[] args)&#123; Painting p=new Painting(); p.painting(new drawTriangle()); &#125;&#125; 我们把基础图形类Graph的一个方法draw定义成抽象的，接下来他的所有子类都实现这个方法，那么我们新增一个新的图形类那么只需要继承这个基础图形类即可，无需在修改工具类Painting类里面的方法，这样就满足了开闭原则。 那么我们为什么要在基类Graph里面新添一个抽象方法而不让其他的子类的同一个名字来解决呢，因为painting这个方法的参数是基类的，如果只是单独修改子类的方法为draw那么就不满足多态的概念，仔细想想为什么吧。 开闭原则细节和注意事项 要是面向对象的编程，在开发过程中都会强调开闭原则 是最基础的设计原则，其他五个设计原则都是开闭原则的具体形态 可以提高代码的复用性 可以提高代码的可维护性 用抽象构建框架，用实现扩展细节 迪米特法则（最少知道原则）定义迪米特法则(Law of Demeter, LoD)是1987年秋天由lan holland在美国东北大学一个叫做迪米特的项目设计提出的，它要求一个对象应该对其他对象有最少的了解，所以迪米特法则又叫做最少知识原则（Least Knowledge Principle, LKP）。 举例举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//总公司员工class Employee&#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125;//分公司员工class SubEmployee&#123; private String id; public void setId(String id)&#123; this.id = id; &#125; public String getId()&#123; return id; &#125;&#125;class SubCompanyManager&#123; public List&lt;SubEmployee&gt; getAllEmployee()&#123; List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++)&#123; SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId("分公司"+i); list.add(emp); &#125; return list; &#125;&#125;class CompanyManager&#123; public List&lt;Employee&gt; getAllEmployee()&#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++)&#123; Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId("总公司"+i); list.add(emp); &#125; return list; &#125; public void printAllEmployee(SubCompanyManager sub)&#123; List&lt;SubEmployee&gt; list1 = sub.getAllEmployee(); for(SubEmployee e:list1)&#123; System.out.println(e.getId()); &#125; List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2)&#123; System.out.println(e.getId()); &#125; &#125;&#125;//客户端public class Client&#123; public static void main(String[] args)&#123; CompanyManager e = new CompanyManager(); e.printAllEmployee(new SubCompanyManager()); &#125;&#125; 现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940class SubCompanyManager&#123; public List&lt;SubEmployee&gt; getAllEmployee()&#123; List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;(); for(int i=0; i&lt;100; i++)&#123; SubEmployee emp = new SubEmployee(); //为分公司人员按顺序分配一个ID emp.setId("分公司"+i); list.add(emp); &#125; return list; &#125; public void printEmployee()&#123; List&lt;SubEmployee&gt; list = this.getAllEmployee(); for(SubEmployee e:list)&#123; System.out.println(e.getId()); &#125; &#125;&#125;class CompanyManager&#123; public List&lt;Employee&gt; getAllEmployee()&#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for(int i=0; i&lt;30; i++)&#123; Employee emp = new Employee(); //为总公司人员按顺序分配一个ID emp.setId("总公司"+i); list.add(emp); &#125; return list; &#125; public void printAllEmployee(SubCompanyManager sub)&#123; sub.printEmployee(); List&lt;Employee&gt; list2 = this.getAllEmployee(); for(Employee e:list2)&#123; System.out.println(e.getId()); &#125; &#125;&#125; 修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。 迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。 合成复用原则 软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现 问题由来：通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 解决方案：合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>设计模式</tag>
        <tag>java</tag>
        <tag>原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电路基础]]></title>
    <url>%2F2020%2F02%2F16%2F%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言 最近在学习51单片机，但是无奈初中电路知识忘了，结果难以理解现在的一些东西，比如上拉电阻，于是乎我打算学习一下电路的基本知识. 欧姆定律在同一电路中，通过某一导体的电流跟这段导体两端的电压成正比，跟这段导体的电阻成反比,这就是欧姆定律. U=I*R I=U/R 分压定律和分流定律在串联电路中，各电阻上的电流相等，各电阻两端的电压之和等于电路总电压。可知每个电阻上的电压小于电路总电压，故串联电阻分压。 在并联电路中，各电阻两端的电压相等，各电阻上的电流之和等于总电流（干路电流）。可知每个电阻上的电流小于总电流（干路电流），故并联电阻分流。 电阻的串并联就好像水流，串联只有一条道路，电阻越大，流的越慢，并联的支路越多，电流越大。 那么问题来了怎么计算并联电路的支路上的电流呢 例子分流假设有一个并联电路，其中有两个路，我们假设这两条支路个有一个电阻。 分路1电流=干路电流*分路2电阻/（分路电阻1+分路电阻2） 分压假设有一个串联电路，其中有两个电阻 电阻1电压=总电压*(电阻1大小)/(电阻1+电阻2) 其实能把这些电路知识想象成水流就能明白很多了，例如电流的大小就是水流的大小，电阻就是河道对水流的阻碍，电压大小就是水流速度，那么久很容易啦(^o^)/~]]></content>
      <categories>
        <category>学习</category>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>电路</tag>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot缓存详解]]></title>
    <url>%2F2020%2F02%2F14%2FSpringboot%E7%BC%93%E5%AD%98%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[缓存的作用 缓存就是用于数据交换的缓冲区，一半特点就是速度快。 1.热点数据放入缓存以减少对数据库的访问次数2.临时数据放入缓存中减少数据库的压力，例如短信验证码3分钟有效就可以放入缓存中，超过3分钟就从缓存中去掉。不同缓存的作用操作系统磁盘缓存 ——&gt; 减少磁盘机械操作。数据库缓存——&gt;减少文件系统IO。应用程序缓存——&gt;减少对数据库的查询。Web服务器缓存——&gt;减少应用服务器请求。客户端浏览器缓存——&gt;减少对网站的访问。 缓存的策略1.基于访问时间 2.基于频率 3.基于访问模式 JSR107jsr107定义了5个核心接口 CachingProvider缓存提供者，定义了创建、配置、获取、管理多个CachingManager,并且一个java应用可以在运行期有多个CachingProviderCachingManage缓存管理器，定义了创建、配置、获取、管理多个唯一命名的Cache,这些Cache存在CacheManage的上下文中，并且CacheManage只能被一个CachingProvider拥有Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。Entry是一个存储在Cache中的key-value对。Expiry每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。springboot缓存抽象Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等； 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 使用Spring缓存抽象时我们需要关注以下两点； 确定方法需要被缓存以及他们的缓存策略 从缓存中读取之前缓存存储的数据 三、 几个重要概念和缓存注解 Cache 缓存接口，定义缓存操作。实现有： RedisCache、 EhCacheCache、 ConcurrentMapCache等 CacheManager 缓存管理器，管理各种缓存（Cache）组件 @Cacheable 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存 @CacheEvict 清空缓存 @CachePut 保证方法被调用，又希望结果被缓存。 @EnableCaching 开启基于注解的缓存 keyGenerator 缓存数据时key生成策略 serialize 缓存数据时value序列化策略 简要说明： @Cacheable注解加载方法中，那么该方法第一次会查询数据库，然后就会吧数据放在缓存中，使用Cache 进行数据的读取等操作。 @CacheEvict删除缓存，例如根据id删除用户，那么也要删除缓存中的用户信息 @CachePut更新缓存，例如更新用户信息后，同时也要更新缓存中的用户信息 Cache SpEL available metadata 名字 位置 描述 示例 methodName root object 当前被调用的方法名 #root.methodName method root object 当前被调用的方法 #root.method.name target root object 当前被调用的目标对象 #root.target targetClass root object 当前被调用的目标对象类 #root.targetClass args root object 当前被调用的方法的参数列表 #root.args[0] caches root object 当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”, “cache2”})）， 则有两个cache #root.caches[0].name argument name evaluation context 方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的 形式， 0代表参数的索引； #iban 、 #a0 、 #p0 result evaluation context 方法执行后的返回值（仅当方法执行之后的判断有效，如 ‘unless’ ， ’cache put’的表达式 ’cache evict’的表达式 beforeInvocation=false） #result 四、缓存使用 1、引入spring-boot-starter-cache模块 2、 @EnableCaching开启缓存 3、使用缓存注解 4、切换为其他缓存* SpELSpring Cache提供了一些供我们使用的SpEL上下文数据，下表直接摘自Spring官方文档： 名称 位置 描述 示例 methodName root对象 当前被调用的方法名 #root.methodname method root对象 当前被调用的方法 #root.method.name target root对象 当前被调用的目标对象实例 #root.target targetClass root对象 当前被调用的目标对象的类 #root.targetClass args root对象 当前被调用的方法的参数列表 #root.args[0] caches root对象 当前方法调用使用的缓存列表 #root.caches[0].name Argument Name 执行上下文 当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数 #artsian.id result 执行上下文 方法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false） #result 注意： 1.当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。 如 1@Cacheable(key = &quot;targetClass + methodName +#p0&quot;) 2.使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。 如： 12@Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;)@Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;) SpEL提供了多种运算符 类型 运算符 关系 &lt;，&gt;，&lt;=，&gt;=，==，!=，lt，gt，le，ge，eq，ne 算术 +，- ，* ，/，%，^ 逻辑 &amp;&amp;，||，!，and，or，not，between，instanceof 条件 ?: (ternary)，?: (elvis) 正则表达式 matches 其他类型 ?.，?[…]，![…]，^[…]，$[…] 演示1.开始使用前需要导入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 2.然后在启动类注解@EnableCaching开启缓存123456789@SpringBootApplication@EnableCaching //开启缓存public class DemoApplication&#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 3.缓存@Cacheable``@Cacheable注解会先查询是否已经有缓存，有会使用缓存，没有则会执行方法并缓存。 1234@Cacheable(value = &quot;emp&quot; ,key = &quot;targetClass + methodName +#p0&quot;)public List&lt;NewJob&gt; queryAll(User uid) &#123; return newJobDao.findAllByUid(uid);&#125; 此处的value是必需的，它指定了你的缓存存放在哪块命名空间。 此处的key是使用的spEL表达式，参考上章。这里有一个小坑，如果你把methodName换成method运行会报错，观察它们的返回类型，原因在于methodName是String而methoh是Method。 此处的User实体类一定要实现序列化public class User implements Serializable，否则会报java.io.NotSerializableException异常。 到这里，你已经可以运行程序检验缓存功能是否实现。 深入源码，查看它的其它属性 我们打开@Cacheable注解的源码，可以看到该注解提供的其他属性，如： 1234567String[] cacheNames() default &#123;&#125;; //和value注解差不多，二选一String keyGenerator() default &quot;&quot;; //key的生成器。key/keyGenerator二选一使用String cacheManager() default &quot;&quot;; //指定缓存管理器String cacheResolver() default &quot;&quot;; //或者指定获取解析器String condition() default &quot;&quot;; //条件符合则缓存String unless() default &quot;&quot;; //条件符合则不缓存boolean sync() default false; //是否使用异步模式 4.配置@CacheConfig当我们需要缓存的地方越来越多，你可以使用@CacheConfig(cacheNames = {&quot;myCache&quot;})注解来统一指定value的值，这时可省略value，如果你在你的方法依旧写上了value，那么依然以方法的value值为准。 使用方法如下： 123456789@CacheConfig(cacheNames = &#123;"myCache"&#125;)public class BotRelationServiceImpl implements BotRelationService &#123; @Override @Cacheable(key = "targetClass + methodName +#p0")//此处没写value public List&lt;BotRelation&gt; findAllLimit(int num) &#123; return botRelationRepository.findAllLimit(num); &#125;&#125; 查看它的其它属性 123String keyGenerator() default ""; //key的生成器。key/keyGenerator二选一使用String cacheManager() default ""; //指定缓存管理器String cacheResolver() default ""; //或者指定获取解析器 5.更新@CachePut@CachePut注解的作用 主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用 。简单来说就是用户更新缓存数据。但需要注意的是该注解的value 和 key 必须与要更新的缓存相同，也就是与@Cacheable 相同。示例： 123456789101112@CachePut(value = "emp", key = "targetClass + #p0")public NewJob updata(NewJob job) &#123; NewJob newJob = newJobDao.findAllById(job.getId()); newJob.updata(job); return job;&#125;@Cacheable(value = "emp", key = "targetClass +#p0")//清空缓存public NewJob save(NewJob job) &#123; newJobDao.save(job); return job;&#125; 查看它的其它属性 123456String[] cacheNames() default &#123;&#125;; //与value二选一String keyGenerator() default ""; //key的生成器。key/keyGenerator二选一使用String cacheManager() default ""; //指定缓存管理器String cacheResolver() default ""; //或者指定获取解析器String condition() default ""; //条件符合则缓存String unless() default ""; //条件符合则不缓存 6.清除@CacheEvict@CachEvict 的作用 主要针对方法配置，能够根据一定的条件对缓存进行清空 。 属性 解释 示例 allEntries 是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存 @CachEvict(value=”testcache”,allEntries=true) beforeInvocation 是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存 @CachEvict(value=”testcache”，beforeInvocation=true) 示例： 1234567891011121314151617181920212223@Cacheable(value = "emp",key = "#p0.id")public NewJob save(NewJob job) &#123; newJobDao.save(job); return job;&#125;//清除一条缓存，key为要清空的数据@CacheEvict(value="emp",key="#id")public void delect(int id) &#123; newJobDao.deleteAllById(id);&#125;//方法调用后清空所有缓存@CacheEvict(value="accountCache",allEntries=true)public void delectAll() &#123; newJobDao.deleteAll();&#125;//方法调用前清空所有缓存@CacheEvict(value="accountCache",beforeInvocation=true)public void delectAll() &#123; newJobDao.deleteAll();&#125; 其他属性 12345String[] cacheNames() default &#123;&#125;; //与value二选一String keyGenerator() default &quot;&quot;; //key的生成器。key/keyGenerator二选一使用String cacheManager() default &quot;&quot;; //指定缓存管理器String cacheResolver() default &quot;&quot;; //或者指定获取解析器String condition() default &quot;&quot;; //条件符合则清空 7.组合@Caching有时候我们可能组合多个Cache注解使用，此时就需要@Caching组合多个注解标签了。 1234567891011121314@Caching(cacheable = &#123; @Cacheable(value = "emp",key = "#p0"), ...&#125;,put = &#123; @CachePut(value = "emp",key = "#p0"), ...&#125;,evict = &#123; @CacheEvict(value = "emp",key = "#p0"), ....&#125;)public User save(User user) &#123; ....&#125; 下面讲到的整合第三方缓存组件都是基于上面的已经完成的步骤，所以一个应用要先做好你的缓存逻辑，再来整合其他cache组件。 五：整合EHCACHEEhcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 1.导入依赖整合ehcache必须要导入它的依赖。 123456789&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 2.yml配置需要说明的是config: classpath:/ehcache.xml可以不用写，因为默认就是这个路径。但ehcache.xml必须有。 12345spring: cache: type: ehcache ehcache: config: classpath:/ehcache.xml 3.ehcache.xml在resources目录下新建ehcache.xml，注释啥的应该可以说相当详细了 123456789101112131415161718192021222324252627282930313233&lt;ehcache&gt; &lt;!-- 磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存 path:指定在硬盘上存储对象的路径 path可以配置的目录有： user.home（用户的家目录） user.dir（用户当前的工作目录） java.io.tmpdir（默认的临时目录） ehcache.disk.store.dir（ehcache的配置目录） 绝对路径（如：d:\\ehcache） 查看路径方法：String tmpDir = System.getProperty("java.io.tmpdir"); --&gt; &lt;diskStore path="java.io.tmpdir" /&gt; &lt;!-- defaultCache:默认的缓存配置信息,如果不加特殊说明,则所有对象按照此配置项处理 maxElementsInMemory:设置了缓存的上限,最多存储多少个记录对象 eternal:代表对象是否永不过期 (指定true则下面两项配置需为0无限期) timeToIdleSeconds:最大的发呆时间 /秒 timeToLiveSeconds:最大的存活时间 /秒 overflowToDisk:是否允许对象被写入到磁盘 说明：下列配置自缓存建立起600秒(10分钟)有效 。 在有效的600秒(10分钟)内，如果连续120秒(2分钟)未访问缓存，则缓存失效。 就算有访问，也只会存活600秒。 --&gt; &lt;defaultCache maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="600" timeToLiveSeconds="600" overflowToDisk="true" /&gt; &lt;cache name="myCache" maxElementsInMemory="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="600" overflowToDisk="true" /&gt;&lt;/ehcache&gt; 4.使用缓存@CacheConfig(cacheNames = {“myCache”})设置ehcache的名称，这个名称必须在ehcache.xml已配置 。 123456789@CacheConfig(cacheNames = &#123;"myCache"&#125;)public class BotRelationServiceImpl implements BotRelationService &#123; @Cacheable(key = "targetClass + methodName +#p0") public List&lt;BotRelation&gt; findAllLimit(int num) &#123; return botRelationRepository.findAllLimit(num); &#125;&#125; 整合完毕！ 别忘了在启动类开启缓存！]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SSM</tag>
        <tag>Mybatis</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker入门]]></title>
    <url>%2F2020%2F01%2F30%2FDocker%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Docker入门前言 docker是一种容器,其产生的目的只要是解决了开发环境和运维环境不同的一个解决方案，解决了运行环境和配置环境的问题，但是它又和虚拟化技术不同，docker比虚拟化技术占用资源更少，启动更快，甚至启动是毫秒级的 Docker的重要部分镜像 将软件环境打包好的模板，用来创建容器的，一个镜像可以创建多个容器。 容器 Docker的运行组件，启动一个镜像就是一个容器，容器与容器之间相互隔离，并且互不影响。 仓库仓库就是镜像的仓库，分为私有仓库和公共仓库，其中私有仓库是自己的镜像仓库，公共仓库是docker提供的仓库 docker常用命令1、Docker容器信息123456##查看docker容器版本docker version##查看docker容器信息docker info##查看docker容器帮助docker --help 2、镜像操作提示：对于镜像的操作可使用镜像名、镜像长ID和短ID。 2.1、镜像查看1234##列出本地imagesdocker images##含中间映像层docker images -a 1234##只显示镜像IDdocker images -q##含中间映像层docker images -qa 1234##显示镜像摘要信息(DIGEST列)docker images --digests##显示镜像完整信息docker images --no-trunc 12##显示指定镜像的历史创建；参数：-H 镜像大小和日期，默认为true；--no-trunc 显示完整的提交记录；-q 仅列出提交记录IDdocker history -H redis 2.2、镜像搜索12345678##搜索仓库MySQL镜像docker search mysql## --filter=stars=600：只显示 starts&gt;=600 的镜像docker search --filter=stars=600 mysql## --no-trunc 显示镜像完整 DESCRIPTION 描述docker search --no-trunc mysql## --automated ：只列出 AUTOMATED=OK 的镜像docker search --automated mysql 2.3、镜像下载123456##下载Redis官方最新镜像，相当于：docker pull redis:latestdocker pull redis##下载仓库所有Redis镜像docker pull -a redis##下载私人仓库镜像docker pull bitnami/redis 2.4、镜像删除12345678##单个镜像删除，相当于：docker rmi redis:latestdocker rmi redis##强制删除(针对基于镜像有运行的容器进程)docker rmi -f redis##多个镜像删除，不同镜像间以空格间隔docker rmi -f redis tomcat nginx##删除本地全部镜像docker rmi -f $(docker images -q) 2.5、镜像构建12345##（1）编写dockerfilecd /docker/dockerfilevim mycentos##（2）构建docker镜像docker build -f /docker/dockerfile/mycentos -t mycentos:1.1 3、容器操作提示：对于容器的操作可使用CONTAINER ID 或 NAMES。 3.1、容器启动1234##新建并启动容器，参数：-i 以交互模式运行容器；-t 为容器重新分配一个伪输入终端；--name 为容器指定一个名称docker run -i -t --name mycentos##后台启动容器，参数：-d 已守护方式启动容器docker run -d mycentos 注意：此时使用”docker ps -a”会发现容器已经退出。这是docker的机制：要使Docker容器后台运行，就必须有一个前台进程。解决方案：将你要运行的程序以前台进程的形式运行。 1234##启动一个或多个已经被停止的容器docker start redis##重启容器docker restart redis 3.2、容器进程12345##top支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]##列出redis容器中运行进程docker top redis##查看所有运行容器的进程信息for i in `docker ps |grep Up|awk &apos;&#123;print $1&#125;&apos;`;do echo \ &amp;&amp;docker top $i; done 3.3、容器日志123456##查看redis容器日志，默认参数docker logs rabbitmq##查看redis容器日志，参数：-f 跟踪日志输出；-t 显示时间戳；--tail 仅列出最新N条容器日志；docker logs -f -t --tail=20 redis##查看容器redis从2019年05月21日后的最新10条日志。docker logs --since=&quot;2019-05-21&quot; --tail=10 redis 3.4、容器的进入与退出1234567891011121314##使用run方式在创建时进入docker run -it centos /bin/bash##关闭容器并退出exit##仅退出容器，不关闭快捷键：Ctrl + P + Q##直接进入centos 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=false 确保CTRL-D或CTRL-C不会关闭容器docker attach --sig-proxy=false centos ##在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i 即使没有附加也保持STDIN 打开；-t 分配一个伪终端docker exec -i -t centos /bin/bash##以交互模式在容器中执行命令，结果返回到当前终端屏幕docker exec -i -t centos ls -l /tmp##以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端docker exec -d centos touch cache.txt 3.5、查看容器12345678##查看正在运行的容器docker ps##查看正在运行的容器的IDdocker ps -q##查看正在运行+历史运行过的容器docker ps -a##显示运行容器总文件大小docker ps -s 123456##显示最近创建容器docker ps -l##显示最近创建的3个容器docker ps -n 3##不截断输出docker ps --no-trunc 1234##获取镜像redis的元信息docker inspect redis##获取正在运行的容器redis的 IPdocker inspect --format=&apos;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&apos; redis 3.6、容器的停止与删除123456789101112131415##停止一个运行中的容器docker stop redis##杀掉一个运行中的容器docker kill redis##删除一个已停止的容器docker rm redis##删除一个运行中的容器docker rm -f redis##删除多个容器docker rm -f $(docker ps -a -q)docker ps -a -q | xargs docker rm## -l 移除容器间的网络连接，连接名为 dbdocker rm -l db ## -v 删除容器，并删除容器挂载的数据卷docker rm -v redis 3.7、生成镜像12##基于当前redis容器创建一个新的镜像；参数：-a 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID] myredis:v1.1 3.8、容器与主机间的数据拷贝123456##将rabbitmq容器中的文件copy至本地路径docker cp rabbitmq:/[container_path] [local_path]##将主机文件copy至rabbitmq容器docker cp [local_path] rabbitmq:/[container_path]/##将主机文件copy至rabbitmq容器，目录重命名为[container_path]（注意与非重命名copy的区别）docker cp [local_path] rabbitmq:/[container_path]]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue入门]]></title>
    <url>%2F2019%2F12%2F26%2Fvue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[vue入门12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt;&amp;#123;&amp;#123; msg &amp;#125;&amp;#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"#app",//挂载点 data:&amp;#123; msg :"哈哈哈1" &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 挂载点（el:）作用： 挂载点的作用就是设置vue的作用范围，如果&#123;&#123;&#125;&#125;取值在选择器外部则原样显示，当然挂载点可以是id选择器，类选择器，还有class选择器，（开发中推荐使用id选择器） 特殊情况选择器不能作用到body标签和html标签以及单标签上 演示使用类选择器 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app" class="class"&gt;&amp;#123;&amp;#123; msg &amp;#125;&amp;#125;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; //el:"#app",id选择器 //el:"div",标签选择器 el:".class", data:&amp;#123; msg :"哈哈哈1" &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 数据对象（data:）作用 vue中用到的数据定义在data中 data中可以写复杂类型的数据 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div&gt;&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div&gt; &lt;div&gt;&amp;#123;&amp;#123;arr[0]&amp;#125;&amp;#125;&lt;/div&gt; &lt;div&gt;&amp;#123;&amp;#123;map.name&amp;#125;&amp;#125;&lt;/div&gt; &lt;div&gt;&amp;#123;&amp;#123;isTrue&amp;#125;&amp;#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"哈哈哈1",//字符串类型 arr:["1","2","3","4"],//数组 map:&amp;#123;"name":"张珊"&amp;#125;,//map isTrue:true//布尔类型 &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 结果为 1234哈哈哈11张珊true v-text作用v-text指令的作用是设置标签的内容（textContext） 默认写法会替换全部内容，使用差值表达式&#123;&#123;&#125;&#125;可以替换指定内容 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div v-text="msg"&gt;&lt;/div&gt; &lt;div&gt;&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;差值表达式&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"哈哈哈1",//字符串类型 &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 结果 12哈哈哈1哈哈哈1差值表达式 v-html和v-text区别:v-text会把元素内容替换为字符串，如果有特殊字符也会当做字符串， v-html会吧里面的标签解析出来 作用 v-html指令的作用是:设置元素的innerHTML 内容中有html结果会被解析为标签 v-text指令无论内容是什么，都会解析为文本 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div v-text="msg"&gt;&lt;/div&gt; &lt;div v-html="msg"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"&lt;a&gt;哈哈哈&lt;/a&gt;",//字符串类型 &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 结果： 12&lt;a&gt;哈哈哈&lt;/a&gt;哈哈哈 v-on作用: v-on指令的作用是：为元素绑定事件 指令可以简写为@ 绑定的方法必须在methods属性中 事件名不需要写on 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;button type="button" v-on:click="click(1)"&gt;v-on&lt;/button&gt; &lt;button type="button" @click="click(1)"&gt;@&lt;/button&gt; &lt;div&gt;&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"&lt;a&gt;哈哈哈&lt;/a&gt;",//字符串类型 &amp;#125;, methods:&amp;#123; click:function(num)&amp;#123; this.msg="被点击"+num; &amp;#125; &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 结果 12v-on @被点击1 v-show作用 v-show指令的作用是：根据真假切换元素的显示状态 原理是修改元素的display，实现显示和隐藏 指令后面的内容都会被解析为布尔值 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div v-show="isTrue"&gt;&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div&gt; &lt;div v-show="isFalse"&gt;&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"&lt;a&gt;哈哈哈&lt;/a&gt;",//字符串类型 isTrue:true, isFalse:false &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 结果 1&lt;a&gt;哈哈哈&lt;/a&gt; v-if作用 v-if指令的作用是：根据表达式的真假切换元素的显示 本质是操作和移除dom元素 v-bind作用 属性绑定（因为标签内部不能使用差值表达式，所以要通过属性绑定的方式实现这个功能） 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;a v-bind:href="msg"&gt;去b站&lt;/a&gt; &lt;a :href="msg"&gt;去b站&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"https://www.bilibili.com/",//字符串类型 &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; v-for作用 v-for根据数据生成列表结构 数组经常和v-for使用 语法是(item,index) in 数据 item和index可以结合其他指令一起使用 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="item in arr"&gt;&amp;#123;&amp;#123;item&amp;#125;&amp;#125;&lt;/li&gt; &lt;br /&gt; &lt;li v-for="(item,index) in arr"&gt;&amp;#123;&amp;#123;index&amp;#125;&amp;#125;:&amp;#123;&amp;#123;item&amp;#125;&amp;#125;&lt;/li&gt; &lt;br /&gt; &lt;li v-for="(item,index) in arr"&gt;&amp;#123;&amp;#123;index+1&amp;#125;&amp;#125;:&amp;#123;&amp;#123;item&amp;#125;&amp;#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"https://www.bilibili.com/",//字符串类型 arr:[1,2,3,4,5,6,7,8] &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 结果 1234567891011121314151617181920212223242526123456780:11:22:33:44:55:66:77:81:12:23:34:45:56:67:78:8 v-model（双向数据绑定，仅限表单）作用（也就是表单改变数据也改变，数据改变表单同时改变） v-model指令的作用是便捷的设置和获取表单元素的值 绑定的数据会和表单元素值想关联 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Hello Vue&lt;/title&gt; &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="msg" :placeholder="msg"&gt; &lt;button type="button" v-on:click="click"&gt;v-on&lt;/button&gt; msg结果:&lt;div&gt;&amp;#123;&amp;#123;msg&amp;#125;&amp;#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;script&gt; var vue=new Vue(&amp;#123; el:"div", data:&amp;#123; msg :"哈哈哈",//字符串类型 &amp;#125;, methods:&amp;#123; click:function()&amp;#123; this.msg="被点击"; &amp;#125; &amp;#125; &amp;#125;)&lt;/script&gt;&lt;/html&gt; 结构 123被点击 v-on msg结果:被点击]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>前端</tag>
        <tag>习惯</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uni-app入门]]></title>
    <url>%2F2019%2F12%2F25%2Funi-app%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[uni-app入门 有个老师想让我们做一款评分上传文件的软件，但是要求最好是安卓端，我也不会安卓，因为我是搞后台的，但是也搞过一点前端，于是乎我就学一点这个吧，也方便以后使用。 首先目录结构123456789101112131415┌─components uni-app组件目录│ └─comp-a.vue 可复用的a组件├─hybrid 存放本地网页的目录，详见├─platforms 存放各平台专用页面的目录，详见├─pages 业务页面文件存放的目录│ ├─index│ │ └─index.vue index页面│ └─list│ └─list.vue list页面├─static 存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此├─wxcomponents 存放小程序组件的目录├─main.js Vue初始化入口文件├─App.vue 应用配置，用来配置App全局样式以及监听 应用生命周期├─manifest.json 配置应用名称、appid、logo、版本等打包信息└─pages.json 配置页面路由、导航条、选项卡等页面类信息 页面样式与布局uni-app 支持的通用 css 单位包括 px、rpx（也就说你全当小程序宽度就是750px,因为底层已经做好了适配） px 即屏幕像素 rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。以750宽的屏幕为基准，750rpx恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大。 vue页面支持普通H5单位，但在nvue里不支持： rem 默认根字体大小为 屏幕宽度/20（微信小程序、头条小程序、App、H5） vh viewpoint height，视窗高度，1vh等于视窗高度的1% vw viewpoint width，视窗宽度，1vw等于视窗宽度的1% nvue还不支持百分比单位。（nvue标准就可以让小程序拥有更高的性能） App端，在 pages.json 里的 titleNView 或页面里写的 plus api 中涉及的单位，只支持 px。注意此时不支持 rpx Vue文件解析.vue 文件是一个自定义的文件类型，用类 HTML 语法描述一个 Vue 组件。每个 .vue 文件包含三种类型的顶级语言块 &lt;template&gt;、&lt;script&gt; 和 &lt;style&gt;，还允许添加可选的自定义块： 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=&quot;example&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; msg: &apos;Hello world!&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.example &#123; color: red;&#125;&lt;/style&gt;&lt;custom1&gt; This could be e.g. documentation for the component.&lt;/custom1&gt; vue-loader 会解析文件，提取每个语言块，如有必要会通过其它 loader 处理，最后将他们组装成一个 ES Module，它的默认导出是一个 Vue.js 组件选项的对象。 vue-loader 支持使用非默认语言，比如 CSS 预处理器，预编译的 HTML 模版语言，通过设置语言块的 lang 属性。例如，你可以像下面这样使用 Sass 语法编写样式： 123&lt;style lang=&quot;sass&quot;&gt; /* write Sass! */&lt;/style&gt; 更多细节可以在使用预处理器中找到。 语言块模板 每个 .vue 文件最多包含一个 &lt;template&gt; 块。 内容将被提取并传递给 vue-template-compiler 为字符串，预处理为 JavaScript 渲染函数，并最终注入到从 &lt;script&gt; 导出的组件中。 脚本 每个 .vue 文件最多包含一个 &lt;script&gt; 块。 这个脚本会作为一个 ES Module 来执行。 它的默认导出应该是一个 Vue.js 的组件选项对象。也可以导出由 Vue.extend() 创建的扩展对象，但是普通对象是更好的选择。 任何匹配 .js 文件 (或通过它的 lang 特性指定的扩展名) 的 webpack 规则都将会运用到这个 &lt;script&gt; 块的内容中。 样式 默认匹配：/\.css$/。 一个 .vue 文件可以包含多个 &lt;style&gt; 标签。 标签可以有 scoped 或者 module 属性 (查看 scoped CSS和 CSS Modules) 以帮助你将样式封装到当前组件。具有不同封装模式的多个 标签可以在同一个组件中混合使用。 任何匹配 .css 文件 (或通过它的 lang 特性指定的扩展名) 的 webpack 规则都将会运用到这个 &lt;style&gt; 块的内容中。 自定义块可以在 .vue 文件中添加额外的自定义块来实现项目的特定需求，例如 &lt;docs&gt; 块。vue-loader 将会使用标签名来查找对应的 webpack loader 来应用在对应的块上。webpack loader 需要在 vue-loader 的选项 loaders 中指定。 更多细节，查看自定义块。 Src 导入如果喜欢把 .vue 文件分隔到多个文件中，你可以通过 src 属性导入外部文件： 123&lt;template src=&quot;./template.html&quot;&gt;&lt;/template&gt;&lt;style src=&quot;./style.css&quot;&gt;&lt;/style&gt;&lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt; 需要注意的是 src 导入遵循和 webpack 模块请求相同的路径解析规则，这意味着： 相对路径需要以 ./ 开始 你可以从 NPM 依赖中导入资源： 12&lt;!-- import a file from the installed &quot;todomvc-app-css&quot; npm package --&gt;&lt;style src=&quot;todomvc-app-css/index.css&quot;&gt; 在自定义块上同样支持 src 导入，例如： 12&lt;unit-test src=&quot;./unit-test.js&quot;&gt;&lt;/unit-test&gt; 注释在语言块中使用该语言块对应的注释语法 (HTML、CSS、JavaScript、Jade 等)。顶层注释使用 HTML 注释语法：&lt;!-- comment contents here --&gt;。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>前端</tag>
        <tag>习惯</tag>
        <tag>app</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡特兰数详解]]></title>
    <url>%2F2019%2F12%2F19%2F%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[卡特兰数1,1,2,5,14,42,132常见公式 问题一由 个“(”和 个“)”组成的字符串，要求左括号和右括号是匹配的，问一共有多少种合法的括号组合方式?解析:​ 加上现在有三对括号，我们吧这三对括号所有的情况排列下来 ​ $\color{red}()$()() 红色括号内没有括号 ​ $\color{red}()$(()) ​ $\color{red}($() $\color{red}{)}$() 红色括号内有一对括号 ​ $\color{red}($()()$\color{red}{)}$ 红色括号内有两对括号 ​ $\color{red}($(())$\color{red}{)}$ markdown染色太累了（╮(╯▽╰)╭） 到目前为止是不是发现有些规律呢？ 当n=3的时候假设f(n)就表示括号有三对的所有情况 ​ f(3)=f(0) * f(2)+f(1) * f(1)+f(2)*f(0) 上面这个公式和规律又有啥关系呢？我们可以这么想，第一个括号一定是左括号，那么第一个对括号一定是会出现，那么第一对括号之间可能出现一对括号或者到n-1对括号，为啥是n-1对呢，因为第一对括号已经确定了，所有里面最多只能有n-1对，所以说n对括号应该是: f(n)=f(0) * f(n-1)+…+f(n-1)*f(0)当然也有特殊情况，当n=0的时候答案应该是1,想一想为什么所有根据上面的公式我们写出代码 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;int sum[20];//存放卡特兰数结果等价于f(n)int f(int num)//计算num项的卡特兰数&#123; if(sum[num]!=-1) return sum[num]; else if(num==1) return 1; else if(num==0) return 1; else &#123; int sum1=0; for(int i=0;i&lt;num;i++) &#123; sum1+=f(i)*f(num-i-1); &#125; return sum[num]=sum1; &#125; &#125;int main(void)&#123; sum[0]=1; sum[1]=1; for(int i=0;i&lt;10;i++) sum[i]=-1; for(int i=1;i&lt;10;i++) &#123; cout&lt;&lt;f(i)&lt;&lt;endl; &#125; return 0;&#125; 上面的代码固然能够计算卡特兰数，当然不能忘了文章开头写的几个公式来一个线性复杂度的卡特兰数 123456789101112131415161718#include&lt;iostream&gt; using namespace std;long long catalan[20];int main(void)&#123; int n; cin&gt;&gt;n; catalan[0]=1; for(int i=1;i&lt;=n;i++)//公式3求解 catalan[i]=(catalan[i-1]*(4*i-2))/(i+1); cout&lt;&lt;catalan[n]; &#125; 其实上面这个代码的缺点也很明显，虽然速度很快，但是大多的卡特兰数体型的值都是比较大的，并且需要取模运算的，例如题型洛谷 P3200 栈所以接下来一个更通用的卡特兰数解法 123456789101112131415161718192021222324#include&lt;iostream&gt; using namespace std;int catalan[1000010];//注意卡特兰数数组的初始化结果为0 int main(void)&#123; int n,p;//n为计算第几项卡特兰数，p是取模 cin&gt;&gt;n&gt;&gt;p; //初始化前两项 catalan[0] =1; catalan[1] =1; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;n;j++) catalan[i]=(catalan[j]*catalan[i-j-1]%p+catalan[i])%p; cout&lt;&lt;catalan[n]; return 0;&#125; 其他类似题型问题一有2n个人排成一行进入剧场。入场费 5 元。其中只有 个人有一张 5 元钞票，另外n人只有 10 元钞票，剧院无其它钞票，问有多少中方法使得只要有 10 元的人买票，售票处就有 5 元的钞票找零？ 问题分析首先这个问题也是2n类型的问题，然后就是一个5元的和一个10元的结合在一起就能满足类似括号问题，5元就是左括号，10元就是右括号，那么问题就转换成了求解卡特兰数问题。 问题二 n个不同的数依次进栈，求不同的出栈结果的种数 问题分析首先这个问题也是满足2n个问题的，因为题目进栈和出栈的次数是一样的所有也满足2n问题，同时也转换成了括号问题，也就变成了求解卡特兰数。 问题三 n个结点可够造多少个不同的二叉树？ 问题分析f(n)就表示n个节点二叉树构造的不同二叉树，那么当n=3的时候f(n)=f(0) * f(2)+f(1) * f(1)+f(2) * f(0),为什么会是这样呢，一个二叉树的所有情况应该是根节点左子树的所有情况乘以右子数的所有情况，并且左子数所有节点加右节点等于n-1，如果左子树有0个节点那么右子树就有2个节点，依次类推会发现就是括号问题。]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式session]]></title>
    <url>%2F2019%2F12%2F14%2F%E5%88%86%E5%B8%83%E5%BC%8Fsession%2F</url>
    <content type="text"><![CDATA[分布式session入门前言 我院大佬要安排一个项目，有一块要有人负责session这一块，于是乎没人想学，我就接下这个活了，希望自己能理解的不错吧。 session介绍session简介session是一次浏览器和服务器的交互会话，那会话又是什么呢，牛津词典的解释是进行某个活动连续的一段时间。 session作用session复制原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。 优点：如果其中一个服务器挂掉不会影响这个服务器集群。 缺点：如果用户访问量非常庞大，那么个个服务器之间进行session同步的次数会非常的多，以至于占用大量内网带宽 演示:1.复制多分tomcat 2.设置每个tomcat的server.xml来开启tomcat集群功能 3.在web.xml中添加信息：通知应用当前在集群环境中。 粘性session原理：粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。 优点：简单，不需要对session做任何处理。 缺点：缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的session信息都将失效。 适用场景：发生故障对客户产生的影响较小；服务器发生故障是低概率事件。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>分布式</tag>
        <tag>Spring</tag>
        <tag>SSM</tag>
        <tag>Mybatis</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安阳师院软件学院报名系统使用流程]]></title>
    <url>%2F2019%2F11%2F27%2F%E5%AE%89%E9%98%B3%E5%B8%88%E9%99%A2%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2%E6%8A%A5%E5%90%8D%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安阳师院软件学院报名系统使用流程团队赛报名流程请大家使用谷歌浏览器或者国内的浏览器切换到极速模式在来打开本网站报名系统 前言 首先团队赛比赛有多个人参赛，该系统针对这类比赛提供团队比赛账号的注册，也就是说报名这类比赛必须先注册好个人账号，然后由团队账号邀请您加入该团队，之后进行报名。 第一步：注册属于您的个人账号1.进入登陆页面后点击创建账号,随后就能创建个人账号 学号和姓名必须要真实有效，否则影响您的获奖证书 电子邮箱可以用来找回密码 然后点击注册即可 第二步：如果您的队伍有团队账号请跳过这一步1.注册一个团队账号，在注册页面的上面有个团队账号点击即可 电子邮箱可以用来找回密码 第三步：登陆您团队账号1.登陆进去以后在导航栏找到管理我的团队 在邀请一栏中输入您队友的学号点击发送邀请即可，此时，该用户就会收到一个邀请信息，如果对方同意，那么在下面这一栏就会出现他的个人信息。 3.2个人账号同意加入队伍第一步登陆您的个人账号，点击导航栏的信封 第二步同意团队邀请 接下来在我加入的团队里面就能看见您当前加入的团队 第四步：报名比赛 团队比赛只能由团队账号报名 接下来点击导航栏的所有比赛找到您想参加的比赛点击报名即可如果没有邀请码可以直接确认跳过邀请码 如果没有邀请码点击确认即可 恭喜您成功报名个人赛报名流程第一步：您登陆您的个人账号 第二步：找到您要报名的比赛点击报名即可。]]></content>
      <categories>
        <category>软件学院</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>报名系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo+zookeeper]]></title>
    <url>%2F2019%2F11%2F21%2FDubbo%2Bzookeeper%2F</url>
    <content type="text"><![CDATA[Dubbo 我院大佬今天在阿里转正了，他应该是打算写毕业设计了，于是乎准备带带我们这些弱鸡，他就想先让俺们学一学Dubbo。 前言 dubbo是阿里爸爸公司开源的一个高性能优秀的服务框架（手动狗头╮(╯▽╰)╭，怪不得用这个，因为他也是阿里的），得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和Spring框架无缝集成。 分布式 分布式我觉得就是把单体应用拆分成多个，简单来说就是多个计算机一起做不同的事情(集群简单点来讲就是多个计算机一起做一模一样的事情,╮(╯▽╰)╭)。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot入门环境搭建]]></title>
    <url>%2F2019%2F11%2F05%2FSpringBoot%E5%85%A5%E9%97%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SpringBoot入门环境搭建技术栈Springboot,mybatis,logback 开始第一步，idea新建SpringBoot工程 第二部配置开发环境 application.yml 12345678logging: file: path: loggerspring: profiles: active: devmybatis: mapper-locations: classpath:mapping/*.xml application-dev-yml 123456789101112131415161718spring: #注意下面的username和password的写法，这两个是大坑 datasource: url: jdbc:mysql://localhost:3306/dirver username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver http: encoding: force: true charset: utf-8 enabled: trueserver: port: 8081 tomcat: uri-encoding: UTF-8 第三步，使用mybatis-Generator生成mapper和mapping 第四步，配置logback]]></content>
  </entry>
  <entry>
    <title><![CDATA[Thymeleaf入门教程]]></title>
    <url>%2F2019%2F11%2F01%2FThymeleaf%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Thymeleaf入门教程前言 最近在学习SpringBoot框架，以前在写web项目的时候一直使用的是JSP页面模板语言，但是在SpringBoot中已经不推荐使用了。所有要使用新的模板语言了，整合SpringBoot推荐这个Thymeleaf模板语言，所有就学习这个模板引擎吧 SpringBoot支持的模板语言 Thymeleaf(SpringBoot框架推荐) FreeMarker Velocity Groovy JSP … 1.快速开始首先要想使用Thymeleaf要添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot默认的存放模板页面的路径是src/main/resource/tempates或者src/main/view/templates 然后创建一个Controller对象，在其中进行参数传递 123456789@Controllerpublic class ThymeleafController &#123; @RequestMapping(value = "show", method = RequestMethod.GET) public String show(Model model)&#123; model.addAttribute("uid","123456789"); model.addAttribute("name","Jerry"); return "show"; &#125;&#125; 在SpringBoot默认页面下创建html文件(注意第二行的Thymeleaf的约束) 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;SpringBoot模版渲染&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:text="'用户ID：' + $&#123;uid&#125;"/&gt; &lt;p th:text="'用户名称：' + $&#123;name&#125;"/&gt;&lt;/body&gt;&lt;/html&gt; 这样就会生成这样的html文件 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;title&gt;SpringBoot模版渲染&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;用户ID：123456789&lt;/p&gt; &lt;p&gt;用户名称：Jerry&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 标准表达式 ${...} : 变量表达式。 *{...} : 选择表达式。 #{...} : 消息 (i18n) 表达式。 @{...} : 链接 (URL) 表达式。 ~{...} : 片段表达式。 变量表达式变量表达式是OGNL表达式 - 如果将Thymeleaf 与Spring - 集成在上下文变量上(也称为Spring术语中的模型属性)，则为Spring EL。 它们看起来像这样: 1$&#123;person.name&#125; 选择表达式选择表达式就像变量表达式一样，它们不是整个上下文变量映射上执行，而是在先前选择的对象。 它们看起来像这样: 1*&#123;customer.name&#125; 它们所作用的对象由th:object属性指定: 12345&lt;div th:object="$&#123;book&#125;"&gt; ... &lt;span th:text="*&#123;title&#125;"&gt;...&lt;/span&gt; ...&lt;/div&gt; 所以这相当于: 123456&#123; // th:object="$&#123;book&#125;" final Book selection = (Book) context.getVariable("book"); // th:text="*&#123;title&#125;" output(selection.getTitle());&#125; 消息(i18n)表达式消息表达式(通常称为文本外部化，国际化或i18n)允许从外部源(如:.properties)文件中检索特定于语言环境的消息，通过键来引用这引用消息。 在Spring应用程序中，它将自动与Spring的MessageSource机制集成。如下 - 12#&#123;main.title&#125;#&#123;message.entrycreated($&#123;entryId&#125;)&#125; 以下是在模板中使用它们的方式: 123456&lt;table&gt; ... &lt;th th:text="#&#123;header.address.city&#125;"&gt;...&lt;/th&gt; &lt;th th:text="#&#123;header.address.country&#125;"&gt;...&lt;/th&gt; ...&lt;/table&gt; 请注意，如果希望消息键由上下文变量的值确定，或者希望将变量指定为参数，则可以在消息表达式中使用变量表达式: 1#&#123;$&#123;config.adminWelcomeKey&#125;($&#123;session.user.name&#125;)&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot入门]]></title>
    <url>%2F2019%2F10%2F20%2Fspringboot%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[springboot入门概述: 什么是springboot 它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。 它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架 使用springboot有什么好处回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要： 1）配置 web.xml，加载 spring 和 spring mvc 2）配置数据库连接、配置日志文件 3）配置家在配置文件的读取，开启注解 4）配置mapper文件 ….. 而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了… 划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。 快速入门 1.导入maven坐标12345678910111213141516171819202122232425&gt; &lt;properties&gt;&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;&gt; &lt;/properties&gt;&gt; &lt;parent&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&gt; &lt;/parent&gt;&gt; &gt; &gt; &lt;dependencies&gt;&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&gt; &lt;/dependency&gt;&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;junit&lt;/groupId&gt;&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt;&gt; &lt;version&gt;4.11&lt;/version&gt;&gt; &lt;scope&gt;test&lt;/scope&gt;&gt; &lt;/dependency&gt;&gt; &lt;/dependencies&gt;&gt; 2.新建springboot入口（其他包必须与此类在同级目录或者子包下 ）123456789101112&gt; package com.qs304;&gt; &gt; import org.springframework.boot.SpringApplication;&gt; import org.springframework.boot.autoconfigure.SpringBootApplication;&gt; &gt; @SpringBootApplication&gt; public class SpringbootRunMain &#123;&gt; public static void main(String[] args) &#123;&gt; SpringApplication.run(SpringbootRunMain.class,args);&gt; &#125;&gt; &#125;&gt; 3.编写controller123456789101112131415&gt; package com.qs304.controller;&gt; &gt; import org.springframework.stereotype.Controller;&gt; import org.springframework.web.bind.annotation.RequestMapping;&gt; import org.springframework.web.bind.annotation.ResponseBody;&gt; &gt; @Controller&gt; public class HellpController &#123;&gt; @RequestMapping("/hello")&gt; @ResponseBody&gt; public String helloWorld()&#123;&gt; return "HelloWorld";&gt; &#125;&gt; &#125;&gt; 然后浏览器输入ip+项目名称就能访问了 Springboot研究 1.POM文件1.父项目（一般作为依赖管理）123456&gt; &lt;parent&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&gt; &lt;/parent&gt;&gt; 这个starter父项目还依赖了一个叫spring-boot-dependencies的父项目spring-boot-starter-parent(定义了每一个依赖的版本,管理springboot版本仲裁中心，定义了所有的依赖版本)1234567891011121314151617181920212223&gt; &lt;properties&gt;&gt; &lt;!-- Dependency versions --&gt;&gt; &lt;activemq.version&gt;5.14.5&lt;/activemq.version&gt;&gt; &lt;antlr2.version&gt;2.7.7&lt;/antlr2.version&gt;&gt; &lt;appengine-sdk.version&gt;1.9.59&lt;/appengine-sdk.version&gt;&gt; &lt;artemis.version&gt;1.5.5&lt;/artemis.version&gt;&gt; &lt;aspectj.version&gt;1.8.13&lt;/aspectj.version&gt;&gt; &lt;assertj.version&gt;2.6.0&lt;/assertj.version&gt;&gt; &lt;atomikos.version&gt;3.9.3&lt;/atomikos.version&gt;&gt; &lt;bitronix.version&gt;2.1.4&lt;/bitronix.version&gt;&gt; &lt;caffeine.version&gt;2.3.5&lt;/caffeine.version&gt;&gt; &lt;cassandra-driver.version&gt;3.1.4&lt;/cassandra-driver.version&gt;&gt; &lt;classmate.version&gt;1.3.4&lt;/classmate.version&gt;&gt; &lt;commons-beanutils.version&gt;1.9.3&lt;/commons-beanutils.version&gt;&gt; &lt;commons-collections.version&gt;3.2.2&lt;/commons-collections.version&gt;&gt; &lt;commons-codec.version&gt;1.10&lt;/commons-codec.version&gt;&gt; &lt;commons-dbcp.version&gt;1.4&lt;/commons-dbcp.version&gt;&gt; &lt;commons-dbcp2.version&gt;2.1.1&lt;/commons-dbcp2.version&gt;&gt; &lt;commons-digester.version&gt;2.1&lt;/commons-digester.version&gt;&gt; &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt;&gt; ...&gt; &lt;/properties&gt;&gt; 没有被定义的依赖还是需要我们手动进行版本的定义的 2.依赖&lt;dependency&gt;12345&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&gt; &lt;/dependency&gt;&gt; spring-boot-starter-web：​ spring-boot-starter:是springboot的场景启动器，帮我们导入了web模块相关的依赖 也就是所还有很多其他的场景 springbot将所有的功能抽取出来，做成了一个个的starters（启动器）,只需要在项目里面引入这些相关场景，就能把需要的功能导入进来。 @SpringBootApplication: Spring Boot 应用标注在某个类上说明这个类似SpringBoot的主配置类,springBoot就是运行这个类的main方法来启动SpringBoot应用:@SpringBootApplication里面的注解 1234567891011121314151617&gt; @Target(&#123;ElementType.TYPE&#125;)&gt; @Retention(RetentionPolicy.RUNTIME)&gt; @Documented&gt; @Inherited&gt; @SpringBootConfiguration&gt; @EnableAutoConfiguration&gt; @ComponentScan(&gt; excludeFilters = &#123;@Filter(&gt; type = FilterType.CUSTOM,&gt; classes = &#123;TypeExcludeFilter.class&#125;&gt; ), @Filter(&gt; type = FilterType.CUSTOM,&gt; classes = &#123;AutoConfigurationExcludeFilter.class&#125;&gt; )&#125;&gt; )&gt; @ConfigurationPropertiesScan&gt; @SpringBootConfiguration:Spring Boot配置类标注在某个类上，表示这是一个SpringBoot的配置类: @SpringBootConfiguration:Spring里面的注解有 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration( proxyBeanMethods = false) Configuration：使用这个注解表示这个类是一个配置类（配置类也是一个组件）EnableAutoConfiguration：开启自动配置(以前手写SSM框架整合的时候需要我们手写配置，现在SpringBoot通过这个注解开启自动配置，这样自动配置才能生效)@EnableAutoConfiguration这个注解里面的注解有: 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;) @AutoConfigurationPackage：自动配置包@AutoConfigurationPackage里面的注解 12345@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;) ​ @import：给容器导入组件 最后，由SpringBootApplication标注的类，的所在包和下面的子包里面所有组件扫描到Spring容器中; yml配置文件SpringBoot默认会使用两个全局配置文件 application.properties application.yml yml简介 YAML (YAML Aint Markup Language)是一种标记语言，通常以.yml为后缀的文件，是一种直观的能够被电脑识别的数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，一种专门用来写配置文件的语言。可用于如： Java，C/C++, Ruby, Python, Perl, C#, PHP等。 yml的优点 YAML易于人们阅读。 YAML数据在编程语言之间是可移植的。 YAML匹配敏捷语言的本机数据结构。 YAML具有一致的模型来支持通用工具。 YAML支持单程处理。 YAML具有表现力和可扩展性。 YAML易于实现和使用。 yml的语法1.约定 k: v表示键值对关系，（注意冒号后面必须有一个空格) 使用空格的缩进表示层级关系，空格数目不重要，只要是左对齐的一列数据，都是一个层级的 大小写敏感 使用缩进时不允许使用tab键，只能使用空格 松散的表示，java中对于驼峰命名法，可以用原名或者使用-代替驼峰（bean的lastName属性，可以使用lastName或者last-name） 在yml语法中，空值可以使用null表示 键值对关系 字符串默认不用加单引号或者双引号 “”双引号；会转义字符串里面的特殊字符， ‘’单引号不会转义里面的字符 list数组类型行内写法使用[]，展开使用- map类型行内写法使用{}，展开使用k: v 日期使用 2019/01/01 文档块使用—-隔开，可以把不同的配置文件写入一个yml配置文件中 演示 123456789101112ren: #普通的int类型 id: 10 #String类型 name: 100 #list类型，里面是String类型 list: ["我是双引号我换行码？\n换行",'我是单引号我换行码?\n不换行'] #string类型,使用null string: null #运行结果: #Person&#123;id=10, name='100', list=[我是双引号我换行码？ #换行, 我是单引号我换行码?\n不换行], string=''&#125; @Value和@ConfigurationProperties注解的区别 @ConfigurationProperties @Value 功能 批量注入文件中的属性 一个一个指定 松散绑定（松散语法） 支持 不支持 spel 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 总结 @Value只能获取基本数据类型 @ConfigurationProperties可以获取map,list等封装类型的值 配置文件yaml和properties都可以获取到值 如果只是需要在业务逻辑中获取一下配置文件中的某个值，使用@Value 如果要是把javabean和配置文件进行11映射，使用@ConfigurationProperties @ConfigurationProperties默认是从全局配置文件中获取值的 @PropertySource与@ImportResource的区别PropertySource自定义配置文件，多用于配置文件与实体属性映射 在从配置文件里面获取值，与javaBean做映射时存在一个问题，我们从主配置文件（application.yml）里面读取会导致主配置文件特别臃肿，为了按照不同模块自定义不同的配置文件引入了@PropertySource 演示： 12345678910person.propertiesperson.lastName=李四person.age=25person.birth=2017/12/15person.boss=trueperson.maps.key1=value1person.maps.key2=value2person.lists=a,b,cperson.dog.name=dogperson.dog.age=2 javabean 12345678@PropertySource(value = &#123;"classpath:person.properties"&#125;)//通过类路径修改默认配置文件@ConfigurationProperties(prefix = "person")//加载配置文件@Componentpublic class Person &#123; private String lastName; private Integer age; private boolean isBoss; private Date birth; @ImplementResources 一般情况下我们自定义的xml配置文件默认情况下这个bean是不会加载到Spring容器中来的，于是乎我们需要@ImportResoure注解将这个配置文件加载进来 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloService" class="com.chentongwei.springboot.service.HelloService"&gt;&lt;/bean&gt;&lt;/beans&gt; 总结： @PropertySource 用于引入.Properties或者 *.yml 用于给javabean注入值 @ImportResource 用于引入.xml 类型的配置文件 在spring boot中已经被配置类替代 @PropertySource 一般用在javabean的类名上 @ImportResource一般用于启动类上 SpringBoot配置文件占位符前言: 在springboot的配置文件中，我们可以使用springboot提供的一些随机数或者使用我们在配置文件中定义的值 随机数12345678910person.propertiesperson.lastName=$&#123;person.properties&#125;person.age=25person.birth=2017/12/15person.boss=trueperson.maps.key1=$&#123;random.int[1024,65536]&#125;person.maps.key2=value2person.lists=a,b,cperson.dog.name=dogperson.dog.age=2 ${random.value} - 类似uuid的随机数，没有”-“连接 ${random.int} - 随机取整型范围内的一个值 ${random.long} - 随机取长整型范围内的一个值 ${random.long(100,200)} - 随机生成长整型100-200范围内的一个值 ${random.uuid} - 生成一个uuid，有短杠连接 ${random.int(10)} - 随机生成一个10以内的数 ${random.int(100,200)} - 随机生成一个100-200 范围以内的数 占位符12person.propertiesperson.lastName=$&#123;person.properties&#125;#引用person.properties的值 SpringBoot配置Profile多环境支持1.多Profile文件​ 我们在主配置文件编写的时候，文件名可以是 application-{profile}.yml或者application-{profile}.properties ,都行，以下用yml为主。以下主配置文件表示 application.yml 编写一个名为 application-dev.yml文件： 12server: port: 8081 123#编写一个名为application-prod.yml文件：server: port: 8082 先启动springboot项目，发现启动的端口为 81(application.yml中指定的端口为 81) ，也就是说默认启动的是application.yml的环境。 2.yml多文档块支持配置文件中也支持使用多文档块的方式创建多环境，是用 — (三个-)表示一个文档块 ，如果不指定启动别的文档块，默认启动第一个文档块，可以通过 spring.profiles.actice=dev 来指定启动别的文档块。 12345678910111213141516server: port: 8081spring: profiles: #指定启动的环境 active: dev---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod 这样启动的时候就会使用dev这个环境 3.使用命令指定环境在idea里面有一个run configurations中指定参数 –spring.profiles.active=dev也可以指定环境 SpringBoot静态资源目录1、classpath 类目录 (src/mian/resource)classpath 即 WEB-INF 下面的 classes 目录 ，在 SpringBoot 项目中是 src/main/resource 目录。 2、ServletContext 根目录下( src/main/webapp )一、SpringBoot 访问web中的静态资源SpringBoot默认指定了一些固定的目录结构，静态资源放到这些目录中的某一个，系统运行后浏览器就可以访问到 1、SpringBoot 默认指定的可以存放静态资源的目录有哪些？ classpath:/META-INF/resources/ 需创建/META-INF/resources/ 目录 classpath:/resources/ 需创建/resources/目录 classpath:/static/ 工具自动生成的static目录，也是用的最多的目录 classpath:/public/ 需创建/public/ 目录 src/main/webapp/ 需创建/webapp/ 目录 这些目录下的文件可以直接访问不需要在url上面添加文件名 3、SpringBoot 默认的首页是放在任一个静态资源目录下的index.html 4、SpringBoot 默认的web页面图标是放在任一静态资源目录下的favicon.ico]]></content>
  </entry>
  <entry>
    <title><![CDATA[pageHelper入门]]></title>
    <url>%2F2019%2F10%2F20%2FpageHelper%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[pageHelper入门前言 之前写web网页的时候使用的是SQL语句中的limit进行分页，无意间发现这种分页写法特别傻屌（╮(╯▽╰)╭），假如你每页有100条数据，你要查询第100页的数据，那么这个SQL语句做的事情就是获取前100100大概这个范围的数据，然后把前100000条数据丢弃，这样是非常浪费性能的，所有我就学习了pageHelper这个分页插件 快速入门步骤 1.使用maven导入依赖 123456&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;&gt; &lt;version&gt;5.1.2&lt;/version&gt;&gt; &lt;/dependency&gt;&gt; 2.在配置文件中配置拦截器插件 第一种：使用spring的属性配置 12345678910111213141516&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;&gt; &lt;!-- 注意其他配置 --&gt;&gt; &lt;property name="plugins"&gt;&gt; &lt;array&gt;&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt;&gt; &lt;property name="properties"&gt;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt;&gt; &lt;value&gt;&gt; params=value1&gt; &lt;/value&gt;&gt; &lt;/property&gt;&gt; &lt;/bean&gt;&gt; &lt;/array&gt;&gt; &lt;/property&gt;&gt; &lt;/bean&gt;&gt; 第二种使用mybatis配置 12345678910111213141516&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;&gt; &lt;!-- 注意其他配置 --&gt;&gt; &lt;property name="plugins"&gt;&gt; &lt;array&gt;&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt;&gt; &lt;property name="properties"&gt;&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt;&gt; &lt;value&gt;&gt; params=value1&gt; &lt;/value&gt;&gt; &lt;/property&gt;&gt; &lt;/bean&gt;&gt; &lt;/array&gt;&gt; &lt;/property&gt;&gt; &lt;/bean&gt;&gt; 3.编写需要分页的controller 1234567891011121314151617181920&gt; //获取第1页，10条内容，默认查询总数count&gt; PageHelper.startPage(1, 10);&gt; List&lt;Country&gt; list = countryMapper.selectAll();&gt; //用PageInfo对结果进行包装&gt; PageInfo page = new PageInfo(list);&gt; //测试PageInfo全部属性&gt; //PageInfo包含了非常全面的分页属性&gt; assertEquals(1, page.getPageNum());&gt; assertEquals(10, page.getPageSize());&gt; assertEquals(1, page.getStartRow());&gt; assertEquals(10, page.getEndRow());&gt; assertEquals(183, page.getTotal());&gt; assertEquals(19, page.getPages());&gt; assertEquals(1, page.getFirstPage());&gt; assertEquals(8, page.getLastPage());&gt; assertEquals(true, page.isFirstPage());&gt; assertEquals(false, page.isLastPage());&gt; assertEquals(false, page.isHasPreviousPage());&gt; assertEquals(true, page.isHasNextPage());&gt; 导航栏演示 12345678910111213141516171819202122232425262728293031323334&gt; &lt;div class="row"&gt;&gt; &lt;div class="col-md-6"&gt;当前是第$&#123;pageInfo.pageNum&#125;,页一共有$&#123;pageInfo.pages&#125;页,共有$&#123;pageInfo.total&#125;条数据&lt;/div&gt;&gt; &lt;div class="col-md-6"&gt;&gt; &lt;nav aria-label="Page navigation"&gt;&gt; &lt;ul class="pagination"&gt;&gt; &gt; &lt;c:if test="$&#123;pageInfo.pageNum!=1&#125;"&gt;&gt; &lt;li&gt;&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageInfo.prePage&#125;" aria-label="Previous"&gt;&gt; &lt;span aria-hidden="true"&gt;&amp;laquo;&lt;/span&gt;&gt; &lt;/a&gt;&gt; &lt;/li&gt;&gt; &lt;/c:if&gt;&gt; &gt; &lt;li class="$&#123;pageInfo.pageNum==1?"disabled":""&#125;"&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageInfo.firstPage&#125;"&gt;首页&lt;/a&gt;&lt;/li&gt;&gt; &gt; &lt;c:forEach items="$&#123;pageInfo.navigatepageNums&#125;" var="pageNum"&gt;&gt; &lt;li class="$&#123;pageInfo.pageNum==pageNum?"disabled":""&#125;"&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageNum&#125;"&gt;$&#123;pageNum&#125;&lt;/a&gt;&lt;/li&gt;&gt; &lt;/c:forEach&gt;&gt; &gt; &lt;li class="$&#123;pageInfo.pageNum==pageInfo.pages?"disabled":""&#125;"&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageInfo.lastPage&#125;"&gt;末页&lt;/a&gt;&lt;/li&gt;&gt; &gt; &lt;c:if test="$&#123;pageInfo.pageNum!=pageInfo.navigateLastPage&#125;"&gt;&gt; &lt;li&gt;&gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/?pn=$&#123;pageInfo.nextPage&#125;#" aria-label="Next"&gt;&gt; &lt;span aria-hidden="true"&gt;&amp;raquo;&lt;/span&gt;&gt; &lt;/a&gt;&gt; &lt;/li&gt;&gt; &lt;/c:if&gt;&gt; &lt;/ul&gt;&gt; &lt;/nav&gt;&gt; &lt;/div&gt;&gt; &lt;/div&gt;&gt; 参数介绍 3. 分页插件参数介绍分页插件提供了多个可选参数，这些参数使用时，按照上面两种配置方式中的示例配置即可。 分页插件可选参数如下： dialect：默认情况下会使用 PageHelper 方式进行分页，如果想要实现自己的分页逻辑，可以实现 Dialect(com.github.pagehelper.Dialect) 接口，然后配置该属性为实现类的全限定名称。 下面几个参数都是针对默认 dialect 情况下的参数。使用自定义 dialect 实现时，下面的参数没有任何作用。 helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。 你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2,sqlserver2012,derby特别注意：使用 SqlServer2012 数据库时，需要手动指定为 sqlserver2012，否则会使用 SqlServer2005 的方式进行分页。你也可以实现 AbstractHelperDialect，然后配置该属性为实现类的全限定名称即可使用自定义的实现方法。 offsetAsPageNum：默认值为 false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为 true 时，会将 RowBounds 中的 offset 参数当成 pageNum 使用，可以用页码和页面大小两个参数进行分页。 rowBoundsWithCount：默认值为false，该参数对使用 RowBounds 作为分页参数时有效。 当该参数设置为true时，使用 RowBounds 分页会进行 count 查询。 pageSizeZero：默认值为 false，当该参数设置为 true 时，如果 pageSize=0 或者 RowBounds.limit = 0 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 Page 类型）。 reasonable：分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时），会查询最后一页。默认false 时，直接根据参数进行查询。 params：为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值， 默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。 supportMethodsArguments：支持通过 Mapper 接口参数来传递分页参数，默认值false，分页插件会从查询方法的参数值中，自动根据上面 params 配置的字段中取值，查找到合适的值时就会自动分页。 使用方法可以参考测试代码中的 com.github.pagehelper.test.basic 包下的 ArgumentsMapTest 和 ArgumentsObjTest。 autoRuntimeDialect：默认值为 false。设置为 true 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择sqlserver2012，只能使用sqlserver），用法和注意事项参考下面的场景五。 closeConn：默认值为 true。当使用运行时动态数据源或没有设置 helperDialect 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认true关闭，设置为 false 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定。 重要提示： 当 offsetAsPageNum=false 的时候，由于 PageNum 问题，RowBounds查询的时候 reasonable 会强制为 false。使用 PageHelper.startPage 方法不受影响。 pageHelper属性1234567891011121314151617181920212223242526272829303132333435363738//当前页private int pageNum;//每页的数量private int pageSize;//当前页的数量private int size;//由于startRow 和endRow 不常用，这里说个具体的用法//可以在页面中"显示startRow 到endRow 共size 条数据"//当前页面第一个元素在数据库中的行号private int startRow;//当前页面最后一个元素在数据库中的行号private int endRow;//总记录数private long total;//总页数private int pages;//结果集private List&lt;T&gt; list;//前一页private int prePage;//下一页private int nextPage;//是否为第一页private boolean isFirstPage = false;//是否为最后一页private boolean isLastPage = false;//是否有前一页private boolean hasPreviousPage = false;//是否有下一页private boolean hasNextPage = false;//导航页码数private int navigatePages;//所有导航页号private int[] navigatepageNums;//导航条上的第一页private int navigateFirstPage;//导航条上的最后一页private int navigateLastPage;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>分页</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery入门教程]]></title>
    <url>%2F2019%2F10%2F17%2FjQuery%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[jQuery入门教程 jQuery就是一个js库，它极大地简化了js的编程，因此jQuery也很容易学习和使用。 入门演示这个隐藏了body标签下div这个长200px和宽200px粉色的盒子，并且打印一行话 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $("div").hide(); alert("asfda"); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery顶级对象$ $是jQuery的一个别称，在代码中可以使用$符号代替jQuery，通常目的都是为了简化操作。 $是jQuery的顶级对象，相当于原生javaScript中的window 演示1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; $("div").hide(); alert("asfda"); &#125;); //下面的和上面的效果完全一致 jQuery(function()&#123; jQuery("div").hide(); alert("asfda"); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery对象和DOM对象 使用原生js获取的对象就是DOM对象 使用JQuery中的$获取的对象就是jQuery对象 他们之间可以相互转化，但是不相互转化之前不能使用对方的属性和方法 演示123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; //获取原生的DOM对象 console.dir(document.querySelector('div')); //获取jQuery对象 console.dir($('div')); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery和DOM对象相互转化DOM对象转化为JQuery对象 1$(&lt;DOM对象&gt;) jQuery对象转化DOM对象 12$(&lt;jQuer对象&gt;)[&lt;index&gt;]//下标访问的方式$(&lt;jQuer对象&gt;).get(&lt;index&gt;) 演示1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; //1.获取原生的DOM对象 var DOMClass=document.querySelector('div'); //转化jQuery对象 var parseJquery=$(DOMClass); //2.获取jQuery对象 var jQueryClass=$('div'); //转化为DOM对象,因为这个代码里面只有一个div所有通过下标访问0下标就可以得到 var parseDOM=jQueryClass[0]; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery选择器1.基础选择器 名称 用法 描述 ID选择器 $(“#id”) 获取指定的ID元素 全选选择器 $(“*”) 获取所有元素 类选择器 $(“.class”) 获取同一类class的元素 标签选择器 $(“div”) 获取同一标签的所有元素 并集选择器 $(“div,p,li”) 获取多个元素 交集选择器 $(“li,current”) 交集选择器 演示123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;&lt;/div&gt; &lt;script&gt; $(function()&#123; //通过类选择器获取类为css的div盒子 console.dir($(".css")); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery隐式迭代 在jQuery中会对jQuery对象进行隐式迭代 也就是说jQuery会对获取到的所有对象迭代执行相同的操作，这样可以极大的简化我们编写的代码 演示12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;1&lt;/div&gt; &lt;div class="css"&gt;2&lt;/div&gt; &lt;div class="css"&gt;3&lt;/div&gt; &lt;div class="css"&gt;4&lt;/div&gt; &lt;script&gt; $(function()&#123; //利用jQuery的隐式迭代修改全部div的背景颜色 $('div').css("background-color","blue"); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery筛选选择器 可以在获取的jQuery对象伪数组中筛选 语法 用法 描述 :first $(“li:first”) 获取li后面第一个li元素 :last $(“li:last”) 获取li伪数组中的最后一个元素 :eq(&lt; index &gt;) $(“li:eq(2)”) 获取li伪数组中的2下标元素 :odd $(“li:odd”) 获取到li元素中,选择索引号为奇数的元素 :even $(“li:even”) 获取到li元素中,选择索引号为偶数的元素 演示修改指定位置div的颜色 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;1&lt;/div&gt; &lt;div class="css"&gt;2&lt;/div&gt; &lt;div class="css"&gt;3&lt;/div&gt; &lt;div class="css"&gt;4&lt;/div&gt; &lt;script&gt; $(function()&#123; //利用jQuery的隐式迭代修改全部div的背景颜色 $('div:eq(2)').css("background-color","blue"); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery筛选方法 语法 用法 说明 parent() $(“li”).parent() 查找li的父亲节点 children(selector) $(“ul”).children(“li”) 相当于$(“ul&gt;li”)，最近一级的（亲儿子） find(selector) $(“ul”).find(“li”) 相当于$(“ul li”)，后代选择器 siblings(selector) $(“.first”).siblings(‘li’) 查找兄弟节点不包括本身 nextAll([expr]) $(“.first”).nextAll() 查找当前元素之后所有同辈元素 prevtAll([expr]) $(“.last”).prevAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(‘div’).hasClass（”protected”) 检查当前的元素是否有包含特定的类，如果有返回true eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”) 演示让2下标的div盒子后面的div盒子变色 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="css"&gt;1&lt;/div&gt; &lt;div class="css"&gt;2&lt;/div&gt; &lt;div class="css"&gt;3&lt;/div&gt; &lt;div class="css"&gt;4&lt;/div&gt; &lt;script&gt; $(function()&#123; //利用jQuery的隐式迭代修改全部div的背景颜色 $('div:eq(2)').nextAll().css("background-color","blue"); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery排他思想 所谓排他是想也就是实现多选一的效果，设置当前元素的样式，清除兄弟元素的样式 核心函数就是$(“button”).siblings(“button”); 演示点击按钮变色，其余按钮清除原来颜色 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;script&gt; $(function()&#123; //隐式迭代 $("button").click(function(event) &#123; //当前元素添加效果 $(this).css("background","blue"); //清除兄弟节点的效果 $(this).siblings('button').css("background",""); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQuery链式编程 实际上链式操作仅仅是通过对象上的方法最后 return this 把对象再返回回来，对象当然可以继续调用方法啦，所以就可以链式操作了 演示将上面那个按钮排他变色案例改编 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; div&#123; height: 200px; width: 200px; border: 1px solid red; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;button&gt;哈哈哈&lt;/button&gt; &lt;script&gt; $(function()&#123; //隐式迭代 $("button").click(function(event) &#123; //链式编程 $(this).css("background","blue").siblings('button').css("background",""); &#125;); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>jQuery</tag>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>javaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis逆向工程--MybatisGenerator]]></title>
    <url>%2F2019%2F10%2F14%2FMybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-MybatisGenerator%2F</url>
    <content type="text"><![CDATA[Mybatis逆向工程 mybatis需要手动编写mapper和接口，以及pojo对象，这对于一个大型工程来说特别消耗时间，所有也就有了自动生成的工具就是MybatisGenerator 使用步骤1.导入maven坐标 12345 &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt; 2.配置Generator配置文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 配置数据库连接--&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/dirver" userId="root" password="123456"&gt; &lt;/jdbcConnection&gt; &lt;!-- java类型解析不需要动--&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 指定javabean生成位置--&gt; &lt;javaModelGenerator targetPackage="com.qs304.skydrive.entity" targetProject=".\src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 映射文件生成位置--&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject=".\src\main\resources"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 指定dao接口生成位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.qs304.skydrive.mapper" targetProject=".\src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定每个表的生成策略--&gt; &lt;table tableName="user" domainObjectName="User"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 3.然后新建一个java文件读取配置文件开始自动生成pojo对象和接口文件和mybatis配置文件 123456789101112131415161718192021222324252627import org.junit.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.io.IOException;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;public class Generator &#123; @Test public void mybatisGenerator() throws InterruptedException, SQLException, IOException, XMLParserException, InvalidConfigurationException &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File("D:\\code\\SSMCRUD\\src\\test\\mybatisGenerator.xml"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[快速搭建java项目配置文件模板]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAjava%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[web.xml(包含Spring和SpringMVC)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;!-- 中文乱码处理 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring配置文件信息 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- ContextLoaderListener监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 日志配置 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/springmvc/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/WEB-INF/errors/404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/WEB-INF/errors/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; applicationContext.xml(含C3P0配置和mybatis配置文件整合)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;&lt;!-- 配置扫描范围--&gt; &lt;context:component-scan base-package="com.qs304"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Component"/&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt; &lt;/context:component-scan&gt;&lt;!--加载数据源配置文件--&gt; &lt;context:property-placeholder location="classpath:config/db.properties"/&gt;&lt;!-- 配置C3P0数据源--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close" &gt; &lt;property name="driverClass" value="$&#123;jdbc.driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url"&gt;&lt;/property&gt; &lt;property name="user" value="$&#123;jdbc.username"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 扫描 po 包，使用别名 --&gt; &lt;property name="typeAliases" value="com.qs304.entity"&gt;&lt;/property&gt; &lt;!-- 扫描映射文件 --&gt; &lt;property name="mapperLocations" value="classpath:config/mapper/*.xml"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置扫描 dao 包，动态实现 dao 接口，注入到 spring 容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.ischoolbar.programmer.dao" /&gt; &lt;/bean&gt; &lt;!-- 事务管理器 （JDBC） --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;aop:config&gt;&lt;!-- 切入点表达式--&gt; &lt;aop:pointcut id="txPointcut" expression="execution(* com.qs304.servlet..*(..))"/&gt;&lt;!-- 配置事务增强--&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/&gt; &lt;/aop:config&gt;&lt;!-- 配置事务增强事务如何切入--&gt; &lt;tx:advice id="txAdvice"&gt; &lt;tx:attributes&gt;&lt;!-- 所有的方法都是事务方法--&gt; &lt;tx:method name="*"/&gt;&lt;!-- get开头的方法认为是查询进行调优--&gt; &lt;tx:method name="get*" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 启动声明式事务驱动 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;/beans&gt; springmvc.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:task="http://www.springframework.org/schema/task" xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd"&gt; &lt;!-- 只需要扫描包中的 Controller 注解 --&gt; &lt;context:component-scan base-package="com.ischoolbar.programmer.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- 启动 mvc 注解驱动 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 启动定时任务 --&gt; &lt;task:annotation-driven/&gt; &lt;!-- 静态资源处理 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 上传文件大小限制 --&gt; &lt;property name="maxUploadSize"&gt; &lt;value&gt;10485760&lt;/value&gt; &lt;/property&gt; &lt;!-- 请求的编码格式, 和 jsp 页面一致 --&gt; &lt;property name="defaultEncoding"&gt; &lt;value&gt;UTF-8&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 后台访问拦截器 --&gt; &lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**"/&gt; &lt;!--&lt;mvc:mapping path="/grade/*"/&gt;--&gt; &lt;mvc:exclude-mapping path="/system/login"/&gt; &lt;mvc:exclude-mapping path="/system/get_cpacha"/&gt; &lt;mvc:exclude-mapping path="/h-ui/**"/&gt; &lt;mvc:exclude-mapping path="/easyui/**"/&gt; &lt;mvc:exclude-mapping path="/home-resources/**"/&gt; &lt;mvc:exclude-mapping path="/home/**"/&gt; &lt;bean class="com.ischoolbar.programmer.interceptor.LoginInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;/beans&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM整合教程和步骤]]></title>
    <url>%2F2019%2F10%2F02%2FSSM%E6%95%B4%E5%90%88%E6%95%99%E7%A8%8B%E5%92%8C%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[SSM整合教程和步骤步骤1.配置spring和springmvc以及mybatis配置文件 2.配置web.xml文件先整合spring与springmvc 3.测试spring与springmvc整合情况 4.整合spring与springmvc与mybatis 教程1.配置spring和springmvc以及mybatis配置文件spring.xml 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--开启注解扫描但是不扫描Controller注解包含的类--&gt; &lt;context:component-scan base-package="com.qs304"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; springmvc.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--开启注解扫描但是只扫描Controller注解包含的类--&gt; &lt;context:component-scan base-package="com.qs304.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt; &lt;!--因为一会要使用注解，所有开启注解扫描,注解只扫描Controller--&gt; &lt;!--配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.配置web.xml文件先整合spring与springmvc web.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;!--配置监听器加载spring框架--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置springxml文档路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;!-- 解决中文乱码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 前端控制器映射拦截说有路径下 &lt;url-pattern&gt;/&lt;url-pattern/&gt;匹配类似于/xxxx的URL，不会匹配到/xxx.xxx类型的URL&lt;url-pattern&gt;/*&lt;url-pattern/&gt;会匹配所有类型、所有后缀的URL，包括：/xxx、/xxx.xxx --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.测试springmvc与spring整合情况4.整合spring与springmvc与mybatis首先单独写mybatis配置文件，例如名字叫做mybatis.xml mybatis.xml 然后测试mybatis能运行 之后吧mybatis配置文件整合到spring.xml配置文件中 spring.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.qs304"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/&gt; &lt;/context:component-scan&gt;&lt;!-- Spring整合mybatis框架--&gt;&lt;!-- 配置连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/demo"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="111"/&gt; &lt;/bean&gt;&lt;!-- 工厂注入来配置sqlsession--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt;&lt;!-- 配置接口所在的包--&gt; &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.qs304.dao"/&gt; &lt;/bean&gt;&lt;/beans&gt; 之后就运行成功啦，完结散花、]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis深入理解XML配置文件]]></title>
    <url>%2F2019%2F09%2F28%2FMybatis%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Mybatis体系结构SqlSessionFactory​ SqlSessionFactory是mybatis的关键对象，它是单个数据库映射关系经过编译后的内存镜像，SqlSessionFactor对象通过SqlSessionFactorBuilder对象创建获得。 SqlSessionFactorBuilder​ SqlSessionFactorBuilder可以从XML配置文件或者一个预先定制的Configguration的实例为核心构建，它是线程安全的。 SqlSession​ SqlSession也是mybatis的关键对象，它是执行持久化操作的对象，类似JDBC中的Connection对象，它是应用程序与持久化层之间执行交互操作的一个单线程对象， 每个线程都应该有他自己的SqlSession实例，SqlSession的实例不能共享，也是线程不安全的，所有绝对不能将SqlSession实例的引用放在一个类的静态字段中，也绝对不能放在任何类型的管理范围中，比如Serlvet中的HTTPSession对象中。 Mybatis的配置文件结构 configuration配置 propertes 属性 typeAliases 类型命名（别名） typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transationManager 事务管理器 dataSource 数据源 databaseIDProvider 数据库厂商标识 mapping 映射器 propertes 这些属性都是外部配置然后可以动态替换的演示:​ 在类路径下新建一个db.properties的java配置文件 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisusername=adminpassword=123456 然后在Mybatis主配置文件中添加元素 1&lt;properties resource="db.properties"/&gt; 之后就可以使用EL表达式获取对应的值 123456&lt;dataSoure type="POOLED"&gt; &lt;property name="driver" value="$&#123;dirver&#125;" /&gt; &lt;property name="url" value="$&#123;url&#125;" /&gt; &lt;property name="username" value="$&#123;username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt;&lt;/dataSoure&gt; settings设置这是Mybatis中非常重要的调整设置，他会改变Mybatis的运行时行为 配置参考 1234567891011121314151617&lt;settings&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;setting name="multipleResultSetsEnabled" value="true"/&gt; &lt;setting name="useColumnLabel" value="true"/&gt; &lt;setting name="useGeneratedKeys" value="false"/&gt; &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt; &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt; &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt; &lt;setting name="defaultStatementTimeout" value="30"/&gt; &lt;setting name="defaultFetchSize" value="200"/&gt; &lt;setting name="safeRowBoundsEnabled" value="false"/&gt; &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt; &lt;setting name="localCacheScope" value="SESSION"/&gt; &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt; &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;&lt;/settings&gt; typeAliases类型命名​ 类型别名时为java类型设置的一个短名字，存在的意义在于减少冗余的全限定类名 方法一1234&lt;!--这样配置后任何使用到com.qs304.beans.User的地方都能使用user代替--&gt;&lt;typeAliases&gt; &lt;typeAlias alias="user" type="com.qs304.beans.User"&gt;&lt;/typeAlias&gt;&lt;/typeAliases&gt; 方法二1234&lt;!--别名默认为类名首字母小写，指定这个包名后，mybatis会在下面的包中搜索--&gt;&lt;typeAliases&gt; &lt;pakage name="com.qs304.bean"/&gt;&lt;/typeAliases&gt; 若使用了注解这别名为注解的值，没有使用就是类名首字母小写 Mybatis已经为许多常见的java类型内建了相应的类型别名他们都是大小写不敏感的 参考：https://blog.csdn.net/lyf_ldh/article/details/77949004 mapper映射器Mybatis需要开发者告诉它去哪寻找映射文件这也就有了mapper 12345678910&lt;mappers&gt; &lt;!--使用类路径查找资源文件--&gt; &lt;mapper resource="com/qs304/dao/IStudent.xml"/&gt; &lt;!--使用绝对路径查找--&gt; &lt;mapper url="file:///C:/IStudent.xml"/&gt; &lt;!--使用接口查找--&gt; &lt;mapper class="com.qs304.dao.IStudent"/&gt; &lt;!--使用包名查找--&gt; &lt;package name="com.qs304.dao"/&gt;&lt;/mappers&gt; 深入理解Mapper XML映射文件SQL映射文件常用的元素 select 映射查询语句 insert 映射插入语句 update 映射删除语句 sql 可被其他语句引用的可重用语句块 cahe 给定命名空间的缓存配置 cache-ref 给其他命名空间缓存配置引用 resultMap 最复杂也是最强大的元素，用来描述如何从数据库结果集中加载对象 &lt;select&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;select &lt;!-- 1. id（必须配置） id是命名空间中的唯一标识符，可被用来代表这条语句 一个命名空间（namespace）对应一个dao接口 这个id也应该对应dao里面的某个方法（sql相当于方法的实现），因此id应该与方法名一致 --&gt; id="selectUser" &lt;!-- 2. parapeterType（可选配置，默认由mybatis自动选择处理） 将要传入语句的参数的完全限定名或别名，如果不配置，mybatis会通过ParamterHandler根据参数类型默认选择合适的typeHandler进行处理 paramterType 主要指定参数类型，可以是int, short, long, string等类型，也可以是复杂类型（如对象） --&gt; parapeterType="int" &lt;!-- 3. resultType（resultType 与 resultMap 二选一配置） 用来指定返回类型，指定的类型可以是基本类型，也可以是java容器，也可以是javabean --&gt; resultType="hashmap" &lt;!-- 4. resultMap（resultType 与 resultMap 二选一配置） 用于引用我们通过 resultMap 标签定义的映射类型，这也是mybatis组件高级复杂映射的关键 --&gt; resultMap="USER_RESULT_MAP" &lt;!-- 5. flushCache（可选配置） 将其设置为true，任何时候语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false --&gt; flushCache="false" &lt;!-- 6. useCache（可选配置） 将其设置为true，会导致本条语句的结果被二级缓存，默认值：对select元素为true --&gt; useCache="true" &lt;!-- 7. timeout（可选配置） 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数，默认值为：unset（依赖驱动） --&gt; timeout="10000" &lt;!-- 8. fetchSize（可选配置） 这是尝试影响驱动程序每次批量返回的结果行数和这个设置值相等。默认值为：unset（依赖驱动） --&gt; fetchSize="256" &lt;!-- 9. statementType（可选配置） STATEMENT, PREPARED或CALLABLE的一种，这会让MyBatis使用选择Statement, PrearedStatement或CallableStatement，默认值：PREPARED --&gt; statementType="PREPARED" &lt;!-- 10. resultSetType（可选配置） FORWARD_ONLY，SCROLL_SENSITIVE 或 SCROLL_INSENSITIVE 中的一个，默认值为：unset（依赖驱动） --&gt; resultSetType="FORWORD_ONLY"&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis一对多和多对一以及多对多]]></title>
    <url>%2F2019%2F09%2F28%2FMybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%92%8C%E5%A4%9A%E5%AF%B9%E4%B8%80%E4%BB%A5%E5%8F%8A%E5%A4%9A%E5%AF%B9%E5%A4%9A%2F</url>
    <content type="text"><![CDATA[ORM和MybatisORM​ ORM 全称为:object/relation mapping（对象\关系数据库映射），简单来说就是一种规范，它的出现就是为了解决面向对象编程语言与关系数据库发展不均衡的产物，允许开发者利用面向对象语言的简单易用性又能利用关系数据库的技术优势，于是把关系数据库包装成面向对象模型，这个工具就是ORM。 基本映射方式数据表映射类​ 持久化类被映射到一个数据表，即一个表对应一个Model类 数据表的行映射（即实例）​ 数据表的每行映射一个对象 数据库表列（字段）映射对象的属性​ 数据库表的每列映射一个对象 一对多和多对一查询一个班有多个学生，一个学生一个班 班级表12345CREATE TABLE `class` ( `id` int(11) NOT NULL AUTO_INCREMENT, `class_name` varchar(255) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4; 学生表12345678CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL, `class_id` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `class_id` (`class_id`), CONSTRAINT `class_id` FOREIGN KEY (`class_id`) REFERENCES `class` (`id`) ON DELETE CASCADE ON UPDATE CASCADE) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4; 首先导入pom.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.qs304&lt;/groupId&gt; &lt;artifactId&gt;MybatisQuery&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; pojo对象班级12345678910111213141516171819202122232425262728293031323334353637383940414243package com.qs304.beans;import java.io.Serializable;import java.util.List;public class Clazz implements Serializable &#123; private Integer id; private String className; private List&lt;Student&gt; students; @Override public String toString() &#123; return "Clazz&#123;" + "id=" + id + ", className='" + className + '\'' + ", students=" + students + '&#125;'; &#125; public List&lt;Student&gt; getStudents() &#123; return students; &#125; public void setStudents(List&lt;Student&gt; students) &#123; this.students = students; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getClassName() &#123; return className; &#125; public void setClassName(String className) &#123; this.className = className; &#125;&#125; 学生123456789101112131415161718192021222324252627282930313233343536373839404142package com.qs304.beans;import java.io.Serializable;public class Student implements Serializable &#123; private Integer id; private String name; private Clazz clazz; public Clazz getClazz() &#123; return clazz; &#125; public void setClazz(Clazz clazz) &#123; this.clazz = clazz; &#125; @Override public String toString() &#123; return "Student&#123;" + "id=" + id + ", name='" + name + '\'' + ", clazz=" + clazz + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125;&#125; utils包123456789101112131415package com.qs304.utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class SqlFactory &#123; public static SqlSessionFactory getSqlFactory() throws IOException &#123; InputStream in=Resources.getResourceAsStream("mybatisConfig.xml"); return new SqlSessionFactoryBuilder().build(in); &#125;&#125; dao包123456789101112131415161718192021222324package com.qs304.dao;import com.qs304.beans.Clazz;import com.qs304.beans.Student;import java.util.List;public interface ImplDao &#123; /** * 一对多查询 * 根据班级id获取班级所有的学生以及班级信息 * @param id 班级id * @return Clazz 班级对象 */ public Clazz findClazzById(int id); /** * 多对一查询 * 根据学生id获取对应学生所在班级以及个人信息 * @param id 学生id * @return Student 学生对象 */ public Student findStudentById(int id);&#125; dao包xml文件123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.qs304.dao.ImplDao"&gt; &lt;!--一对多映射配置--&gt; &lt;resultMap id="clazzStudentMap" type="com.qs304.beans.Clazz"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="className" column="class_name"&gt;&lt;/result&gt; &lt;collection property="students" ofType="student" &gt; &lt;id property="id" column="sid"&gt;&lt;/id&gt; &lt;result property="name" column="name"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;resultMap id="studentClazzMap" type="com.qs304.beans.Student"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="name" column="name"&gt;&lt;/result&gt; &lt;association property="clazz" column="class_id"&gt; &lt;id property="id" column="sid"&gt;&lt;/id&gt; &lt;result property="className" column="class_name"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findClazzById" parameterType="int" resultMap="clazzStudentMap"&gt; select class.*, student.id as sid,student.name from class left outer join student on class.id=student.class_id where class.id=#&#123;id&#125;; &lt;/select&gt; &lt;select id="findStudentById" parameterType="int" resultMap="studentClazzMap"&gt; select student.*,class.id as sid,class.class_name from student,class where class.id=student.class_id and student.id=#&#123;id&#125;; &lt;/select&gt;&lt;/mapper&gt; resourcesdb.properties1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/testusername=rootpassword=111 mybatisConfig.xml文件1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="db.properties"/&gt; &lt;typeAliases&gt; &lt;package name="com.qs304.beans"/&gt; &lt;/typeAliases&gt; &lt;environments default="mysql"&gt; &lt;environment id="mysql"&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;driver&#125;"/&gt; &lt;property name="url" value="$&#123;url&#125;"/&gt; &lt;property name="username" value="$&#123;username&#125;"/&gt; &lt;property name="password" value="$&#123;password&#125;"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;package name="com.qs304.dao"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; lof4j配置文件log4j.properties 1234567891011121314log4j.rootLogger = WARN,stdoutlog4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%p][%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l] %m%nlog4j.appender.D = org.apache.log4j.RollingFileAppenderlog4j.appender.D.File = log/Wifi_sy/Wifi_sy_warn.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = WARN log4j.appender.D.MaxFileSize = 10240KBlog4j.appender.D.MaxBackupIndex = 3 log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss&#125; [%c:%L:[%p]] %m%n 测试类123456789101112131415161718192021222324252627282930313233343536373839404142import com.qs304.beans.Clazz;import com.qs304.beans.Student;import com.qs304.dao.ImplDao;import com.qs304.utils.SqlFactory;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.util.logging.Logger;public class test &#123; SqlSession sqlSession=null; SqlSessionFactory sqlSessionFactory=null; @Before public void befor() throws IOException &#123; sqlSessionFactory= SqlFactory.getSqlFactory(); sqlSession=sqlSessionFactory.openSession(); &#125; @Test public void test()&#123; ImplDao dao=sqlSession.getMapper(ImplDao.class); Clazz clazz=dao.findClazzById(1); System.out.printf(clazz.toString()); &#125; @Test public void test1()&#123; ImplDao dao=sqlSession.getMapper(ImplDao.class); Student student=dao.findStudentById(1); System.out.printf(student.toString()); &#125; @After public void after()&#123; sqlSession.commit(); sqlSession.close(); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis第二天（连接池，动态SQL语句）]]></title>
    <url>%2F2019%2F09%2F16%2Fmybatis%E7%AC%AC%E4%BA%8C%E5%A4%A9%EF%BC%88%E8%BF%9E%E6%8E%A5%E6%B1%A0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mybatis连接池连接池数据源分类 UNPOOLED 不使用连接池的数据源 POOLED 使用传统的javax.sql.DataSource连接池的数据源 JNDI 使用JNDI实现的数据源 mybatis动态SQL语句作用：为了解决手动拼接SQL的麻烦元素:（注意由于markedown语法问题标签有空格） 标签名 说明 &lt; if &gt; 判断语句，用于但条件分支判断 &lt; choose &gt;(&lt; when &gt;,&lt; otherwise &gt;) 相当于switch语句，用于多条件分支判断 &lt; where &gt;,&lt; trim &gt;,&lt; set &gt; 辅助元素，用于处理一些SQL拼接，特殊字符问题 &lt; bind &gt; 从OGNL表达式中创建一个变量，并将其绑定到上下文，常用于模糊查询的Sql语句 代码演示：​ 假设有下面这个类 123456public class Person&#123; private Integer id; private String name; private Integer age; ...//以下的get和set方法以及toString方法省略&#125; &lt;if&gt;标签123456789101112131415161718192021&lt;select id="findPersonByidAndname" parameterType="com.qs304.domain.Person" resultType="com.qs304.domain.Person"&gt; select * from persons where 1=1 &lt;if test="id != null"&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test="name"&gt; and name = #&#123;name&#125; &lt;/if&gt;&lt;/select&gt;&lt;!--如果使用了where标签就可以不写where 1=1和and之类的--&gt;&lt;select id="findPersonByidAndname" parameterType="com.qs304.domain.Person" resultType="com.qs304.domain.Person"&gt; select * from persons &lt;where&gt; &lt;if test="id != null"&gt; id = #&#123;id&#125; &lt;/if&gt; &lt;if test="name"&gt; name = #&#123;name&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &lt;foreach&gt; 元素1234567891011121314&lt;!-- 判断id是否在这个集合里面 select * from pesrsons where id in(1,2,3,4); 类似这样--&gt;&lt;select id="findPersonByIds" parameterType="List" resultType="com.qs304.domain.Person"&gt; select * from pesrsons where id in &lt;!-- 判断为空可以用 list.size&gt;0--&gt; &lt;foreach item="id" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;id&#125; &lt;/foreach&gt; &lt;/select&gt; item：配置的是循环中当前的元素。 index：配置的是当前元素在集合的位置下标。 collection：配置的list是传递过来的参数类型（首字母小写），它可以是一个array、list（或collection）、Map集合的键、POJO包装类中数组或集合类型的属性名等。 open和close：配置的是以什么符号将这些集合元素包装起来。 separator：配置的是各个元素的间隔符。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis入门教程]]></title>
    <url>%2F2019%2F08%2F30%2FMybatis%2F</url>
    <content type="text"><![CDATA[Mybatis1.Mybatis简介:​ ​ MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，是一个基于Java的持久层框架。 持久层： 可以将业务数据存储到磁盘，具备长期存储能力，只要磁盘不损坏，在断电或者其他情况下，重新开启系统仍然可以读取到这些数据。 优点： 可以使用巨大的磁盘空间存储相当量的数据，并且很廉价 缺点：慢（相对于内存而言） 2.为什么要使用mybatis​ 在我们传统的 JDBC 中，我们除了需要自己提供 SQL 外，还必须操作 Connection、Statment、ResultSet，不仅如此，为了访问不同的表，不同字段的数据，我们需要些很多雷同模板化的代码，闲的繁琐又枯燥。 而我们在使用了 MyBatis 之后，只需要提供 SQL 语句就好了，其余的诸如：建立连接、操作 Statment、ResultSet，处理 JDBC 相关异常等等都可以交给 MyBatis 去处理，我们的关注点于是可以就此集中在 SQL 语句上，关注在增删改查这些操作层面上。 并且 MyBatis 支持使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。 3.mybatisDemomybatis的环境搭建​ 第一步：创建maven工程并导入坐标 ​ 第二步：创建实体类和dao接口（mybatis可以只有接口就能实现对数据库的增删改查，而且实体类就是要实体类的属性和数据库的表对应起来） ​ 第三步：创建mybatis的主配置文件 SqlMapConfig.xml（名字可以随意） ​ 第四步：创建映射配置文件 IUserDao.xml（名字可以随意） ​ 搭建注意事项: ​ 第一个:创建IUserDao.xml和IUserDao.java 在mybatis中 他把持久层的操作接口名称和映射文件叫做:Mapper ​ 第二个：在idea中创建目录的时候，他和包是不一样的， ​ 第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同 ​ 第四个：映射配置文件的操作配置（select）,id属性的取值必须是dao接口的方法名 ​ 第五个：映射配置文件的mapper标签和namespace属性的取值必须是dao接口的全限定类名 maven坐标 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 首先Bean包Account.java 12345678910111213141516171819202122232425262728293031323334353637383940package cn.Bean;public class Account &#123; private Integer id; private String name; private Double money; @Override public String toString() &#123; return "Account&#123;" + "id=" + id + ", name='" + name + '\'' + ", money=" + money + '&#125;'; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Double getMoney() &#123; return money; &#125; public void setMoney(Double money) &#123; this.money = money; &#125;&#125; 然后dao包下的IDao.java接口 123456789101112package cn.dao;import cn.Bean.Account;import java.util.List;/** * 获取所有的Account信息 */public interface IDao &#123; public List&lt;Account&gt; getAccountAll();&#125; 然后创建主配置文件MybatisConfig.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--配置环境--&gt; &lt;environments default="mysql"&gt;&lt;!--defult填写的子类必须也有--&gt; &lt;!--配置mysql的环境--&gt; &lt;environment id="mysql"&gt; &lt;!--配置事务的类型--&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt; &lt;!--配置数据源--&gt; &lt;dataSource type="POOLED"&gt; &lt;!--配置连接数据库--&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ee"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="123456"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--配置映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="cn/config/IDao.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 然后穿件cn目录下config目录下的IDao.xml映射IDao.java的配置文件，注意xml文件和java文件必须是统一限定目录 1234567891011&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace填写IDao接口的全限定类名--&gt;&lt;mapper namespace="cn.dao.IDao"&gt; &lt;!--配置查询所有 id必须是IDao方法的名称,resultType必须是实体类 --&gt; &lt;select id="getAccountAll" resultType="cn.Bean.Account"&gt; select * from account; &lt;/select&gt;&lt;/mapper&gt; 最后是测试类 12345678910111213141516171819202122232425262728293031import cn.Bean.Account;import cn.dao.IDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123; @org.junit.Test public void getALl() throws IOException &#123; //1.读取配置文件 InputStream in= Resources.getResourceAsStream("MybatisConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IDao dao=session.getMapper(IDao.class); //5.使用代理对象执行方法 List&lt;Account&gt; users=dao.getAccountAll(); for (Account user : users) &#123; System.out.println(user); &#125; &#125;&#125; 打印信息为 123456Sat Jul 27 15:54:14 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.Account&#123;id=1, name='aaa', money=600.0&#125;Account&#123;id=2, name='bbb', money=1200.0&#125;Account&#123;id=3, name='ccc', money=1000.0&#125;Account&#123;id=4, name='hhh', money=1000.0&#125;Account&#123;id=5, name='hhh', money=200.0&#125; 如果需要保存数据则把IDao.xml改成以下 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--namespace填写IDao接口的全限定类名--&gt;&lt;mapper namespace="cn.dao.IDao"&gt; &lt;!--配置查询所有 id必须是IDao方法的名称,resultType必须是实体类--&gt; &lt;select id="getAccountAll" resultType="cn.Bean.Account"&gt; select * from account; &lt;/select&gt; &lt;!--通过里面配置selectKey标签的方式可以获取插入数据后所对应的自增长id的值--&gt; &lt;select id="addAccount" parameterType="cn.Bean.Account"&gt; &lt;!--selectKey 会将 SELECT LAST_INSERT_ID()的结果放入到传入的model的主键里面， keyProperty 对应的model中的主键的属性名，这里是 user 中的id，因为它跟数据库的主键对应 order AFTER 表示 SELECT LAST_INSERT_ID() 在insert执行之后执行,多用与自增主键， BEFORE 表示 SELECT LAST_INSERT_ID() 在insert执行之前执行，这样的话就拿不到主键了， 这种适合那种主键不是自增的类型 resultType 主键类型 --&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="int" order="AFTER"&gt;&lt;/selectKey&gt; insert INTO account(name,money) values(#&#123;name&#125;,#&#123;money&#125;) &lt;/select&gt;&lt;/mapper&gt; 值得一提的是：resultType属性可以类型有简单类型或者pojo对象，或者pojo对象的包装对象（pojo对象的列表）。pojo对象就是javabean或者说是实体类对象 ​ 然后上述xml文件配置中就是用了OGNL表达式 OGNL表达式中省略的get关键字，即user.getName()变成了user.name; 在mybatis中标签属性resultType中提供了user对象的包名，所以可以直接使用name来达到user.name相同的效果 测试类里面： 1234567891011121314151617181920212223242526272829303132333435363738import cn.Bean.Account;import cn.dao.IDao;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.List;public class Test &#123; @org.junit.Test public void getALl() throws IOException &#123; //1.读取配置文件 InputStream in= Resources.getResourceAsStream("MybatisConfig.xml"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder=new SqlSessionFactoryBuilder(); SqlSessionFactory factory=builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session=factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IDao dao=session.getMapper(IDao.class); //5.使用代理对象执行方法 Account ac=new Account(); ac.setName("hha"); ac.setMoney(99999.0); dao.addAccount(ac); List&lt;Account&gt; users=dao.getAccountAll(); for (Account user : users) &#123; System.out.println(user); &#125; //如果没有正确提交到数据库需要手动提交事务 //session.commit(); &#125;&#125; 注解配置​ 首先可以把IDao.xml移除，在dao接口的方法上使用@Select注解，并且指定SQL语句，同时需要在SqlMapConfig.xml中的mapper配置时，使用class属性指定dao接口的全限定类名 实体类对象的属性名称与mysql数据库里面的列名不同解决方案：原因：​ mysql数据库里面的列不能和实体类对象的属性进行对应，说以要解决这个问题必须从解决对应关系下手 使用mysql的别名进行对应 使用mybatis里面的resultMap标签进行对应匹配（然后标签里面的resultType属性换成resultMap属性来使用配置的resultMap标签里面的内容）]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键操作]]></title>
    <url>%2F2019%2F06%2F27%2FIDEA%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[IDEA 快捷键操作1.搜索跳转 作用 快捷键 备注 多个窗口之间跳转 ctrl+alt+[或者] [跳转到上一个窗口,]跳转到下一个窗口 导航栏跳转 alt+数字键 侧边栏上面标注数字 万能搜索键 按两次shift键 可以打开万能的搜索窗口 跳转到上次编辑的地方 ctrl+shift+backspace 可以定位到上次编辑的地方 跳转到上次浏览的地方 ctrl+alt+左箭头 跳转到上次浏览的地方 跳转到上次浏览的地方返回 ctrl+alt+右箭头 跳转到上次浏览的地方返回 打开最近文件浏览列表 ctrl+E 方便快速的多文件跳转 文件标签 ctrl+F11 给文件添加标签 文件标签跳转 ctrl+标签名称 方便阅读别源代码 添加到喜爱代码库 alt+shift+f 放到类上面添加类到列表里面，放到方法上面添加方法到列表里面 搜索字符串 ctrl+shift+f 搜素所有的字符串 2.代码小助手注意定义 live Template动态模板还有postfix点模板 对选中的大小写进行转换 ctrl+shift+u 对选中的大小写进行转换 选中当前选中的元素进行多行处理 ctrl+shift+alt+j 选中当前选中的元素进行多行处理 格式化代码 ctrl+alt+L 格式化代码 重构变量 shift+f6 重构变量 重构方法 ctrl+f6 重构方法 抽取变量 ctrl+alt+v 抽取变量 将选中的代码块抽取成为函数 ctrl+alt+m 将选中的代码块抽取成为函数 查看选中的类或者接口的继承关系 Ctrl+shift+u 查看选中的类或者接口的继承关系]]></content>
      <categories>
        <category>学习</category>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
        <tag>IDEA</tag>
        <tag>IDE</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法树状数组]]></title>
    <url>%2F2019%2F05%2F27%2F%E7%AE%97%E6%B3%95%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[算法:树状数组1.适用场景​ 可以解决大部分基于区间上的更新以及求和问题 2.介绍1.单点查询 我们先从数组讲起(这个就不需要普及了吧)； A数组是我们传入数据的数组 C数组使我们建立起来的树状数组 然后就能显而易见的发现一个规律 12345678C1 = A1C2 = A1+A2C3 = A3C4 = A1+A2+A3+A4C5 = A5C6 = A5+A6C7 = A7C8 = A1+A2+A3+A4+A5+A6+A7+A8 接下来我们引入lowbit这个概念：(这个地方有一点需要注意：lowbit(0)会陷入死循环 ) 1234inline int lowbit(int x)&#123; return x &amp; (-x);&#125; 这返回的是这个数字最高位的1; 在这之前，又要引入一个补码的概念： 补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1) [+1] = [00000001]原 = [00000001]反 = [00000001]补 [-1] = [10000001]原 = [11111110]反 = [11111111]补 请注意，这里的第一位是指的是符号位，而不是数字位(这是1，因此数字位只有1) 对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值. 因此，&amp;是求与的一个符号，意思是 a 和 b 同时为 1 的时候返回这个最高位(不包括符号位) 在刚刚的找规律过程中，我们通过规律总结出了以下性质(lowbit是为了帮助程序代码的实现) 我们可以得到树状数组的一些性质：对于c[i]，他的儿子节点取决于i的所有因子中最多有2^j次幂，则向前取2^j个数作为儿子，即[i-2^j+1,i]。(这个时候就需要lowbit来帮助实现) 举一个栗子： 6的最大2次方因子为2，即2^1，则向前取2个数，则c[6]=a[5]+a[6]； 8的最大2次方因子为8，即2^3，则向前取8个数，则c[8]=a[1]+a[2]+…+a[8]。 2.单点修改 当我们要对最底层的值进行更新时，那么它相应的父亲节点存储的和也需要进行更新， 我们建立的树状数组结构是一个完整的结构，因此修改一个点也会需要所有相应的其父亲节点的点来修改，这样我们就实现了树状数组的修改。 代码如下： 12345678910void modify(int x,int k) //将 x 增加 k&#123; if(x &lt; 1) return ; while(x &lt;= n) &#123; c[i] += k; x += lowbit(x); //去寻找它的父亲 &#125; &#125; 3.单点查询 单点查询由于我们向前统计，因此需要向前查找，这个就不需要讲了吧(没弄明白请看上面) 1234567891011121314int query(int pos)&#123; int sum=0; for(int i=pos;i;i-=lowbit(i)) sum += c[pos]; /*两种写法 while(pos &gt; 0) &#123; sum += c[pos]; pos -= lowbit(pos); &#125; */ return sum;&#125; 1234567891011121314151617181920212223//这是完整的操作void change(int p, int x)&#123; //给位置p增加x while(p &lt;= n) &#123; sum[p] += x; p += p &amp; -p; &#125;&#125;int ask(int p)&#123; //求位置p的前缀和 int res = 0; while(p) &#123; res += sum[p]; p -= p &amp; -p; &#125; return res;&#125;int query(int l, int r)&#123; //区间求和 return ask(r) - ask(l - 1);&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC框架教程]]></title>
    <url>%2F2019%2F03%2F10%2FSpringMVC%E6%A1%86%E6%9E%B6%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SpringMVC框架教程前言为开发团队选择一款优秀的MVC框架是件难事儿，在众多可行的方案中决择需要很高的经验和水平。你的一个决定会影响团队未来的几年。要考虑方面太多： 1、简单易用，以提高开发效率。使小部分的精力在框架上，大部分的精力放在业务上。 2、性能优秀，这是一个最能吸引眼球的话题。 3、尽量使用大众的框架（避免使用小众的、私有的框架），新招聘来的开发人员有一些这方面技术积累，减低人员流动再适应的影响。 简介​ pring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架或集成其他MVC开发框架，如Struts]1(现在一般不用)，Struts 2(一般老项目使用)等。 SpringMVC框架优势1.清晰的角色划分：控制器(controller)、验证器(validator)、命令对象(command obect)、表单对象(form object)、模型对象(model object)、Servlet分发器(DispatcherServlet)、处理器映射(handler mapping)、试图解析器(view resoler)等等。每一个角色都可以由一个专门的对象来实现。 2.强大而直接的配置方式：将框架类和应用程序类都能作为JavaBean配置，支持跨多个context的引用，例如，在web控制器中对业务对象和验证器validator)的引用。 3.可适配、非侵入：可以根据不同的应用场景，选择何事的控制器子类(simple型、command型、from型、wizard型、multi-action型或者自定义)，而不是一个单一控制器(比如Action/ActionForm)继承。 4.可重用的业务代码：可以使用现有的业务对象作为命令或表单对象，而不需要去扩展某个特定框架的基类。 5.可定制的绑定(binding)和验证(validation)：比如将类型不匹配作为应用级的验证错误，这可以保证错误的值。再比如本地化的日期和数字绑定等等。在其他某些框架中，你只能使用字符串表单对象，需要手动解析它并转换到业务对象。 6.可定制的handler mapping和view resolution：Spring提供从最简单的URL映射，到复杂的、专用的定制策略。与某些web MVC框架强制开发人员使用单一特定技术相比，Spring显得更加灵活。 7.灵活的model转换：在Springweb框架中，使用基于Map的键/值对来达到轻易的与各种视图技术集成。 8.可定制的本地化和主题(theme)解析：支持在JSP中可选择地使用Spring标签库、支持JSTL、支持Velocity(不需要额外的中间层)等等。 9.简单而强大的JSP标签库(Spring Tag Library)：支持包括诸如数据绑定和主题(theme)之类的许多功能。他提供在标记方面的最大灵活性。 10.JSP表单标签库：在Spring2.0中引入的表单标签库，使用在JSP编写表单更加容易。 11.Spring Bean的生命周期：可以被限制在当前的HTTp Request或者HTTp Session。准确的说，这并非Spring MVC框架本身特性，而应归属于Spring MVC使用的WebApplicationContext容器。 SpringMVC与Struts2框架的对比拦截机制1、Struts2 a、Struts2框架是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype（否则会出现线程并发问题），然后通过setter，getter吧request数据注入到属性。b、Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。c、Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了2、SpringMVCa、SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。b、在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。 性能方面 SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。 四、拦截机制Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。 配置方面spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高（当然Struts2也可以通过不同的目录结构和相关配置做到SpringMVC一样的效果，但是需要xml配置的地方不少）。SpringMVC可以认为已经100%零配置。 设计思想Struts2更加符合OOP的编程思想， SpringMVC就比较谨慎，在servlet上扩展。 集成方面SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。 注解详解RequestMapping介绍你可以使用@RequestMapping来映射URL，比如/test到某个Controller类，或者是某个具体的方法。通常类上的注解@RequestMapping用来标记请求的路径，方法上的@RequestMapping注解的作用将是映射到特定的URL到某个具体的处理方法。 作用被添加注解的方法参数就是发起请求的参数，返回值就是通过跳转的页面名字 参数： value,请求的URL路径，支持URL模板，正则表达式。这也是我们最常用的一种映射方 method(多个)，指定接收请求的方法，有GET,POST,PUT等，RequestMethod枚举类，如果没有按规则会抛405 Method Not Allowed params(多个) 指定请求的参数，例如parame=”user” ，那么请求中必须携带user参数的key，如果是parame=”user=123” ，那么参数就key必须是user,value必须是123,否则不能正常执行而且抛出400 错误的请求 headers(多个) 指定请求的头 consumes,允许的媒体类型Media Types ），如consumes ＝ ”application/ison ”， 对应于请求的HTTP 的Content-Type 。 @RequestParam作用：在SpringMVC中如果方法上被添加了·RequestMappring注解且方法有参数，那么必须传入与方法参数同名的的参数名，当使用了这个就可以实现传入产生非同名范围:参数内示例 123456789@RequestMapping("/list")/***传入的参数必须与user同名，而非必须和username同名*/public String test(@RequestParam("user") String username )&#123; return null;&#125; @RequestBady作用：获取请求体的内容，其格式是key:value的格式，其中get请求不适用（get请求没有请求体，它把的参数在url中）,该注解经常使用在异步的方式中范围：参数内注意:方法的名字不能与请求的任何参数同名，因为在Springmvc框架中，任何同名的都被看成同名封装.示例 12345678@RequestMapping("/list")/***注意，方法的名字不能与请求的任何参数同名，因为在Springmvc框架中，任何同名的都被看成同名封装，*/public String test(@RequestBady String bady)&#123; System.out.println(bady);//打印结果将会是key：value的形式 return null;&#125; @PathVariable(REST编程风格)作用: 带占位符的 URL 是 Spring3.0 新增的功能，该功能在SpringMVC 向 REST 目标挺进发展过程中具有里程碑的意义 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 主要是根据请求方法进行类的区别 范围：参数内 示例: 123456789/***通过使用PathVariable注解实现占位符上数据的获取*参数发送格式应该是请求的url例如xxx/list/12*/@RequestMapping("/list/&#123;sid&#125;")public String test(@PathVariable(name="sid") String id)&#123; System.out.println(id);//结果因该为12 return null;&#125; @ModelAttribute作用： ​ 来处理传入的参数少的问题 ​ 添加在方法上面时候，该方法会优先执行 ​ 添加在参数上面的时候，需要一个map集合来处理传入的参数少的问题 范围：方法上和参数上 示例： 假设有个user的javaBean对象 ​ 第一种，注解添加在方法上 123456789@RequestMapping("/list/modelAttribute")public String test(User user)&#123; System.out.println(user); return null;&#125;@ModelAttributepublic User modelAttribute(User user)&#123;//返回值必须三user类型才能保证接下来的方法接收到参数,参数时user类本方法才能获取到传入的参数 System.out.println("先执行,同时可以做一些其他操作，比如补全user对象不全的信息");&#125; 第二种,注解添加在参数内 123456789@RequestMapping("/list/modelAttribute")public String test(@ModelAttribute("abc") User user)&#123;//获取abc的对象存入user System.out.println(user); return null;&#125;public void modelAttribute(User user,Map&lt;String,User&gt; map)&#123;//返回值就不是必须的，但是参数必须有个map，,map&lt;String,User&gt; System.out.println("先执行,同时可以做一些其他操作，比如补全user对象不全的信息"); map.put("abc",user);//进行一些操作&#125; SessionAttributes作用:​ 向Session对象存入值，于在多个请求之间传递参数，类似于Session的Attribute，但不完全一样，一般来说@SessionAttributes设置的参数只用于暂时的传递，而不是长期的保存，长期保存的数据还是要放到Session中。（向Requests域存入对象需要使用Model接口的实现类） 范围：类spring 请求参数绑定绑定简述​ 在SpringMVC中，被添加@RequestMapping的方法的参数就是请求的参数 简要介绍首先javabean类对象 1234567891011121314151617181920212223242526272829package com.qs304;import java.util.List;import java.util.Map;public class Beans &#123; private Integer account; private String password; private Person person; private Map&lt;String,String&gt; map; private List&lt;String&gt; list;&#125;class Person&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + '&#125;'; &#125;&#125; 参数绑定接收方法 123456789@Controller@RequestMapping("parme")public class HelloController &#123; @RequestMapping(value = "/hello",method = RequestMethod.POST) public String helloSpringMVC(Beans beans)&#123;//返回值表示要跳转的jsp页面的名字 System.out.println(beans); return "success"; &#125;&#125; jsp页面的提交 12345678&lt;form action="parme/hello" method="post"&gt; account&lt;input type="text" name="account"&gt;&lt;br/&gt; password&lt;input type="text" name="password"&gt;&lt;br/&gt; pseron.name&lt;input type="text" name="person.name"&gt;&lt;br/&gt; mapkey&lt;input type="text" name="map[key]"&gt;&lt;br/&gt; list&lt;input type="text" name="list[0]"&gt;&lt;br/&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; SpringMVC获取Servlet原生API在方法的上面的参数添加requests或者response的全限定类名即可 Spring MVC 自定义类型转换介绍​ 在SpringMVC框架中，视图层传递过来的参数都是String类型，但是在参数绑定的时候Spring框架会自动帮我们进行类型转换，但是当遇到无法转换的类型时，就需要我们自定义类型转换器 步骤：1.定义一个类，实现Converter接口，该接口有两个泛型，key表示接受类型，value表示转换后的类型 12345678public interface Converter&lt;S, T&gt; &#123;//S:表示接受的类型，T：表示目标类型 /** * 实现类型转换的方法 */ @Nullable T convert(S source); &#125; 1234567891011121314151617181920/** * 自定义类型转换器 */ public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; /* 用于把 String 类型转成日期类型 */ public Date convert(String source) &#123; DateFormat format = null; try &#123; if(StringUtils.isEmpty(source)) &#123; throw new NullPointerException("请输入要转换的日期"); &#125; format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(source); return date; &#125; catch (Exception e) &#123; throw new RuntimeException("输入日期有误"); &#125; &#125; &#125; 2.在配置文件中，注册该组件并使他生效 1234567891011&lt;!-- 配置类型转换器工厂 --&gt; &lt;bean id="converterService" class="org.springframework.context.support.ConversionServiceFactoryBean"&gt; &lt;!-- 给工厂注入一个新的类型转换器 --&gt; &lt;property name="converters"&gt; &lt;array&gt; &lt;!-- 配置自定义类型转换器 --&gt; &lt;bean class="com.study.web.converter.StringToDateConverter"&gt;&lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 123&lt;!-- 引用自定义类型转换器 --&gt; &lt;mvc:annotation-driven conversion-service="converterService"&gt;&lt;/mvc:annotation-driven&gt; SpringMVC五大组件DispatcherServlet:前端控制器​ 用户请求到达前端控制器，是整个流程控制的中心，当使用了静态文件，如js文件css文件，如果请求不到，要注意放弃前端控制器的请求拦截 HandlerMapping:处理器映射器HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 ViewResolver:视图解析器ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 Handler:处理器Handler是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。 View:视图SpringMVC框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。我们最常用的视图就是jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。 SpringMVC 框架快速搭建演示首先使用maven创建web项目 然后导入坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;qs.304&lt;/groupId&gt; &lt;artifactId&gt;SpringMVCDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;SpringMVCDemo Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;SpringMVCDemo&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.8.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.22.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 然后在web.xml配置前端控制器并且设置为第一次加载的时候加载spring容器 1234567891011121314151617181920212223&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置spring前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载spring容器--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--设置启动项目就加载spring容器--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 之后创建springmvc.xml文件配置视图解析器，并且指定视图解析器扫描的包和文件后缀 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.qs304"/&gt; &lt;!--配置视图解析器--&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--配置参数--&gt; &lt;property name="prefix" value="/WEB-INF/pages/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启springmvc注解支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt; 之后配置控制器controller 12345678910111213package com.qs304.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String helloSpringMVC()&#123;//返回值表示要跳转的jsp页面的名字 System.out.println("哈哈哈"); return "success"; &#125;&#125; 这是目录结构 springmvc框架运行流程 ModelAndVIew简介​ ModelAndView从这个名字我们不难看出，他的作用就是模型与视图之间进行交互。 而model,只能向request域进行存对象，所有就出现了，使用ModelAndView类用来存储处理完后的结果数据，以及显示该数据的视图。 用法 12345678public class testModelAndView&#123; @RequestMapping("/testModelAndView") public void testModelAndView()&#123; ModelAndView mv=new ModelAndView(); mv.addObject("asd","asd");//忘request域存取数据 mv.setViewName("123");//使用前端控制器跳转到123页面 &#125;&#125; 使用关键字进行转发或者重定向在返回值前写forward:路径这样会进行转发功能，使用redirect进行重定向注意，这种方法使用较少，而且使用后不能使用前端控制器]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA动态代理]]></title>
    <url>%2F2019%2F02%2F27%2FJAVA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[JAVA动态代理前言：​ 最近在学习spring框架，但是在学习（切面编程）aop的时候老师讲到了一个动态代理，这个东西听着很晕乎，听说在学习javaweb的时候讲filter过滤器也是这个原理，╮(╯▽╰)╭无奈当时没有注意底层也就没有学会，现在正好有机会就把这个动态代理好好学习一下吧。 1.什么是代理代理模式的定义：​ 代理模式给某一个对象提供一个代理对象，并有代理对象控制原对象的引用（╮(╯▽╰)╭，定义都是这么的晦涩难懂） 例子：​ 假如你现在想购买一个笔记本，于是乎当然只关心价格和性能售后啊，而且购买渠道要方便啊，当然厂家生产笔记本后不可能把货物分发到全球各地因为地球太大了，但是消费者想要购买的方便啊，对于消费者来说他要购买方便也就是买电脑的地方离自己比较近，并不关心厂家怎么把电脑弄过来，而且对于厂家来说他只要把电脑做出来做好售后就行了，为什么费这么大劲在各地建立销售网点呢，好钢当然是用在刀刃上面啦。于是乎电脑城这个奸商聚集地就出来了（带着有色眼镜看待的这个问题，不要喷我），奸商正好把厂家和消费者连接起来。而且消费者想维修之类的必须经过代理商也就是电脑城的奸商才能和厂家联系，于是乎这个代理商就起到了代理的作用。 2. 要想知道动态代理首先要知道代理模式的应用场景### 需求和分析：​ 假设有个需求，需要你不修改原有代码的基础上对一个类（Person）的功能进行增强，这下怎么办呢？ ​ 其实可以这样，首先写一个用来增强那个Person那个类的类并且继承Person类实现的那个接口，就叫他Proxy类吧，然后在Proxy类创建的时候可以吧Person这个类当做参数传进去，然后在Proxy类中调用同名的方法（哒哒哒，这就完成啦），其实这个过程就是静态代理模式。也就是说代理对象 = 增强代码 + 目标对象（原对象） 大概就是这样样子，画图比较丑，而且不会用xmind（╮(╯▽╰)╭） 静态代理模式的缺点：​ 这样有什么缺点呢，假设我们有很多个类需要被增强，那么我们要给每一个类都写一个对应的代理类，那么这样也忒麻烦了，代理类你这么麻烦搞的大家都不想和你玩了。 3.动态代理前言​ 动态代理之前要说其实还有一个class类，这个东西比较复杂，（先埋个坑，以后在填坑），class这个类可以获取任意类的构造方法，属性等等等之类的，也就是说我们可以用来复制一个类，代理类和目标类理应实现同一组接口。之所以实现相同接口，是为了尽可能保证代理对象的内部结构和目标对象一致，这样我们对代理对象的操作最终都可以转移到目标对象身上，代理对象只需专注于增强代码的编写。也就是说接口拥有代理类对象和目标对象共同的类信息，但是类信息不能创建对象。于是乎jdk提供了java.lang.reflect.InvocationHandler接口和java.lan.reflect.Proxy类。 Proxy类​ Proxy有个静态方法：getProxyClass(ClassLoader,interfaces),只要你给他传入类加载器和一组接口，他就会给你返回代理Class对象。 ​ 通俗点说就是，你给他传入接口的Class中，复制类结构到新的Class对象中，但新的Class对象带有构造器，是可以创建对象的。 所以Proxy.getProxyClass()这个方法的本质就是用Class造Class 动态代理的作用：​ Proxy类的代码量被固定下来，不会因为业务的逐渐庞大而庞大； ​ 可以实现AOP编程，实际上静态代理也可以实现，总的来说，AOP可以算作是代理模式的一个典型应用； ​ 解耦，通过参数就可以判断真实类，不需要事先实例化，更加灵活多变。 ### 代码演示电脑生产厂家类（被代理对象） 12 电脑城坑人类（代理对象） 12 销售接口: 12 Main类 12]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven入门教程]]></title>
    <url>%2F2019%2F02%2F20%2Fmaven%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[maven教程简介​ Maven 翻译为”专家”、”内行”，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片断能管理一个项目的构建、报告和文档等步骤。 Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 Maven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。（这是我百度复制过来的，╮(╯▽╰)╭，算是毛病吧） 特性跨平台：是指跨OS平台，跨IDE平台 标准化：项目构建标准化，和项目结构标准化 maven目录结构 命令4. 编译源代码： 1mvn compile 5. 编译测试代码： 1mvn test-compile 6. 运行测试: 1mvn test 7. 产生site： 1mvn site 8. 打包： 1mvn package 9. 在本地Repository中安装jar： 12mvn install例：installing D:\xxx\xx.jar to D:\xx\xxxx 10. 清除产生的项目： 1mvn clean 11. 生成eclipse项目： 1mvn eclipse:eclipse 12. 生成idea项目： 1mvn idea:idea 13. 组合使用goal命令，如只打包不测试： 1mvn -Dtest package 14. 编译测试的内容： 1mvn test-compile 15. 只打jar包: 1mvn jar:jar 16. 只测试而不编译，也不测试编译： 12mvn test -skipping compile -skipping test-compile ( -skipping 的灵活运用，当然也可以用于其他组合命令) 17. 清除eclipse的一些系统设置: 1mvn eclipse:clean 18.查看当前项目已被解析的依赖： 1mvn dependency:list 19.上传到私服： 1mvn deploy 20. 强制检查更新，由于快照版本的更新策略(一天更新几次、隔段时间更新一次)存在，如果想强制更新就会用到此命令: 1mvn clean install-U 21. 源码打包： 123mvn source:jar或mvn source:jar-no-fork]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>习惯</tag>
        <tag>maven</tag>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码注意细节]]></title>
    <url>%2F2019%2F02%2F20%2F%E4%BB%A3%E7%A0%81%E6%B3%A8%E6%84%8F%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[代码注意细节1.设计细节springspring配置类中父子关系的配置类更好 mysqlmysql中要严格遵守三大范式才能设计比较好的数据库 mysql中使用外键约束要注意进行级联操作，否则必须先修改依赖表 2.编码细节]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>习惯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架]]></title>
    <url>%2F2019%2F01%2F15%2FSpring%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Spring框架1.Spring简介: 为从大小与开销两方面而言Spring都是轻量的 通过控制反转（IoC）的技术达到松耦合的目的 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发 包含并管理应用对象的配置和生命周期，所以spring是一种容器 将简单的组件配置、组合成为复杂的应用，这个意义上是框架 2.spring的核心 控制反转（IoC）和面向切面编程（AOP） 1.什么事控制反转呢？​ 控制反转loC主要是用来解决耦合的问题的，一个类直接依赖另一个类，这样耦合性是很高的，但是我们可以通过创建一个工厂模式，对象创建另一个对象的时候通过查找map容器，如果map容器不存在，就在本地配置文件中查找类的类名来获取类。这样就把类与类之间的关系转化为了类与工厂与类的关系，从而解决了耦合性的问题。 控制反转loC演示首先创建两个类 Main类是主方法类用来调用Demo方法类里面的toString方法，通过loC控制反转调用 在resources包下面创建一个xml配置文件 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- id表示调用这个类的时候写的类名，class表示类的包名加类名,其中Java目录下的表示根目录 使用注解@Component 类型首字母要小写 --&gt; &lt;bean id="Demo" class="Demo"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;/beans&gt; 12345//ApplicationContext接口的实现对象ClassPathXmlApplicationContext来获取容器ApplicationContext ac= new ClassPathXmlApplicationContext("bean.xml");//通过反射机制获取Bean对象Demo de=ac.getBean("Demo",Demo.class);de.toString(); ApplicationContext接口的继承关系 ApplicationContext:读取配置文件的时候立即加载对象（单例对象适用，经常使用）BeanFatory:遇见getBean的时候才加载对象（多例对象适用）ApplicationConxt接口常用的实现类ClassPathXmlAppliationContext:加载类路径下的配置文件，要求配置文件必须在类路径下FileSystemXmlApplicationContext:加载磁盘任意路径下的配置文件AnnotationConfigAppliationContext:读取注解创建容器3.spring的核心容器Beans(管理bean)Core(核心)Context(上下文（配置文件）)Expresslon Language(SpEl表达式)3.SpringBeanSpringBean创建的三种方式12345678910&lt;!--第一种创建方式id表示调用这个类的时候写的类名，class表示类的包名加类名,其中Java目录下的表示根目录--&gt;&lt;!--使用默认无参构造方法创建--&gt; &lt;bean id="Demo" class="Demo"&gt;&lt;/bean&gt;&lt;!--第二种，使用普通工厂中的方法创建对象,并存入spring容器--&gt; &lt;!--创建Fatory工厂类--&gt; &lt;bean id="Fatory" class="DeFatorymo"&gt; &lt;/bean&gt; &lt;!--获得Service类通过Fatory工厂里面的getService方法--&gt; &lt;bean id="Service" fatory-bean="Fatory" fatory-method="getService"&gt;&lt;/bean&gt;&lt;!--第三种，使用工厂中静态方法创建对象，并存入spring容器--&gt; &lt;bean id="Service" class="Service" facctory-method="getService"&gt;&lt;/bean&gt; SpringBean的作用范围和生存周期Bean标签的scope属性可以指定对象的作用范围 singleton单例对象（默认）解析xml出生，也就是和容器一样 prototype多例对象 ，使用时出生，当对象长时间不使用，而且没有对象引用 的时候被垃圾回收器销毁 request作用于web应用的请求范围 session作用于web的应用的会话范围 global-session:作用于集群环境的会话范围，全局的会话范围 4.Spring注入概述（经常变化的数据不适合注入）​ 平常的Java开发中，程序员在某个类中需要依赖其它类的方法。 ​ 通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理。 ​ Spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过Spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。 ​ 依赖注入的另一种说法是”控制反转”。通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员。 ​ 而控制反转是指new实例工作不由我们程序员来做而是交给Spring容器来做。 详解如果使用注解的方式首先要在xml约束中添加 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--然后告诉spring创建容器时时要扫描的包--&gt; &lt;context:component-scan base-package="&lt;包名&gt;"&gt;&lt;/context:component-scan&gt; ​ 基本数据类型包装类型和String ​ 其他Bean类型（在配置文件中或者注解配置过的Bean） ​ 其他类型/集合类型 注入的方式使用构造函数​ 首先创建一个类,通过构造方法给成员变量进行赋值 12345678910111213141516171819202122import java.util.Date;public class Bean &#123; private int age; private String name; private Date newDate; @Override public String toString() &#123; return "Bean&#123;" + "age=" + age + ", name='" + name + '\'' + ", newDate=" + newDate + '&#125;'; &#125; private Bean(int age, String name, Date newDate)&#123; this.age=age; this.name=name; this.newDate=newDate; &#125;&#125; XML里面这样配置 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- constructor-arg标签属性详解-------------------------------------------------查找构造方法属性： type通过指定数据类型进行查找 index通过指定下标进行查找，下标从0开始 name通过名字进行查找（最常用的方式）---------------------------------------------------赋值： value给对象进行赋值，非String类型能自动转换，特殊类型需要使用rel rel指定其他Ioc核心容器里面的bean对象进行赋值--------------------------------------------------- 优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功 弊端：改变了bean实例化的方式，使我们在创建对象时，如果用不大这些数据，也必须提供 --&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;constructor-arg name="age" value="12"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="name" value="哈哈哈哈"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name="newDate" ref="newDate"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id="newDate" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 使用set方法（更常用）首先创建如下Bean对象 给里面的成员属性进行赋值 123456789101112131415161718192021222324252627import java.util.Date;public class Bean &#123; private int age; private String name; private Date newDate; public void setAge(int age) &#123; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setNewDate(Date newDate) &#123; this.newDate = newDate; &#125; @Override public String toString() &#123; return "Bean&#123;" + "age=" + age + ", name='" + name + '\'' + ", newDate=" + newDate + '&#125;'; &#125;&#125; 然后XML配置文件写 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;!-- constructor-arg标签属性详解-------------------------------------------------查找构造方法属性： name通过set方法名字进行查找---------------------------------------------------赋值： value给对象进行赋值，非String类型能自动转换，特殊类型需要使用rel rel指定其他Ioc核心容器里面的bean对象进行赋值--------------------------------------------------- 优势：创建对象的时候没有明显的限制，可以直接使用默认的无参构造方法进行构建 弊端：如果某个成员变量必须被赋值，则获取对象是有可能set方法没有被执行 --&gt; &lt;property name="age" value="12"&gt;&lt;/property&gt; &lt;property name="name" value="哈哈哈哈"&gt;&lt;/property&gt; &lt;property name="newDate" ref="newDate"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="newDate" class="java.util.Date"&gt;&lt;/bean&gt;&lt;/beans&gt; 针对复杂的集合数据类型进行set注入Bean类 12345678910111213141516171819202122232425262728293031import java.util.Arrays;import java.util.Date;import java.util.List;import java.util.Map;public class Bean &#123; private String[] strs; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; @Override public String toString() &#123; return "Bean&#123;" + "strs=" + Arrays.toString(strs) + ", list=" + list + ", map=" + map + '&#125;'; &#125; public void setMap(Map&lt;String, String&gt; map) &#123; this.map = map; &#125; public void setStrs(String[] strs) &#123; this.strs = strs; &#125; public void setList(List&lt;String&gt; list) &#123; this.list = list; &#125;&#125; XML配置 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="Bean" class="Bean"&gt; &lt;property name="strs"&gt; &lt;array&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;BBB&lt;/value&gt; &lt;value&gt;CCC&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="map"&gt; &lt;map&gt; &lt;entry key="123" value="aaa"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 使用注解代替xml配置的注解@Configuration：说明当前类是一个配置类​ @ComponentScan:指定spring在创建容器时要扫描的包 ​ 属性 value和basePackages作用一样 ​ 等同于在xml中的: 1&lt;context:component-scan base-package="&lt;类路径&gt;"&gt;&lt;/context:component-scan&gt; 当使用了AnnotationConfigApplicationContext();这个类的时候可以不使用这个标签，但是如果有多个配置类，需要在ComponentScan注解中包含另一个配置类，并且另一个配置类必须使用Configuration注解来表示他是一个注解类，或者使用import来避免使用Configuration注解这个问题 演示 1234567891011package com.cofing;import org.springframework.beans.factory.annotation.Configurable;import org.springframework.context.annotation.ComponentScan;//首先要声明当前类是一个注解类@Configurable@ComponentScan("类路径")public class Config &#123;&#125; @import导入其他配置类 （有这个注解的配置类也被称为父配置类，那么被包含的配置类被称为子配置类）如果使用AnnotationConfigApplicationContext();导入了主配置类，那么可以通过在主配置类上面填写@import导入其他配置类，而且此时不能被@ComponentScan注解替代 创建对象的注解@Component 作用把当前类对象存入spring容器中​ 属性：value,用于指定bean的id，当我们不写的时候，默认值是当前类名的首字小写 和上面作用一样Controller:用在表现层 Service:用在业务层 Repository:用在持久层 注入数据的注解@Autowired:​ 作用：自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，或者和他的接口父类类型匹配，就注入成功，如果有多个匹配类型按照名字相同的进行匹配，否则匹配失败。 出现位置:可以是变量上，也可以是方法上细节：在使用注解注入时，set方法就不说必须的了。@Qualifier:在按照类型注入的基础之上再按照名称注入，给类成员注入时不能单独使用，给方法参数注入是可以单独使用​ 属性： value:要注入bean的id @Resource: 可以单独使用​ 属性为：name直接按照id进行注入 上面的三个注入都只能对其他bean类型进行注入，不能对基本类型和String类型进行注入，而且集合类型只能使用xml进行注入。 @value作用，用于注入基本类型和String类型的数据而且可以使用spEL表达式@Bean:作用吧当前方法的返回值作为bean对象存入spring的ioc容器中​ 属性：name用于指定bean的id,当不写时，默认值是当前方法的名称 改变作用范围的注解@Scope :用于指定bean的作用范围 不声明默认是单例的​ 属性:value:指定范围的取值，常用取值:singleton prototype ​ 和生命周期相关的注解@PreDestroy​ 作用:用于指定销毁方法 @PostConstruct​ 作用:用于自定初始化方法 @PropertySource 作用:用来指定properties文件的位置（然后@Value标签就可以用spEL表达式去获取值）​ 属性value：指定文件的名称和路径 ​ 关键字classpath表示类路径下 JAVA的动态代理代理模式 （可以进一步增强代码的复用性）​ 代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。​ 按照代理的创建时期，代理类可以分为两种。 ​ 静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。​ 动态代理：在程序运行时，运用反射机制动态创建而成。 (个人觉的类似于javaweb的监听器概念) 接下来代码演示 Main.java 123456789101112131415161718192021222324252627282930import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Main &#123; public static void main(String[] args) &#123; final Factory fatory=new Factory(); //消费者通过动态代理购买商品 //ClassLoader:类加载器，加载代理对象的字节码，和被代理对象相同的类加载器 //Class[] 让代理对象和被代理对象有相同方法，固定写法 //InvoactionHandler 用于代理的方法 IProxy proxy=(IProxy) Proxy.newProxyInstance(fatory.getClass().getClassLoader(), fatory.getClass().getInterfaces(), new InvocationHandler() &#123; /** * 执行被代理对象的热河接口和方法都会经过该方法 * @param proxy 代理对象的引用 * @param method 当前执行的方法 * @param args 当前执行方法所需要的参数 * @return 和配代理对象具有相同的返回值 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(method.getName().equals("salfMoney")==true)&#123; System.out.print("代理商坑人了"); &#125; return method.invoke(fatory,args); &#125; &#125;); proxy.salfMoney(5000); &#125;&#125; Factory.java 123456789/** * 生产厂家,被代理类 * 要想使用动态代理模式必须要继承一个接口 */public class Factory implements IProxy&#123; public void salfMoney(float money) &#123; System.out.print("卖了"+money+"元"); &#125;&#125; Iproxy.java 1234567/** * 代理接口 */public interface IProxy &#123; //销售商品接口 public void salfMoney(float money);&#125; AOP编程实例​ 使用spring Aop编程除了要加入Spring的spring-aop jar包，还要加入aspectjrt.jar，aspectjweaver.jar，以及aopalliance_1.0.jar 以下两个是与aspectj相关的包,用来支持切面编程的 aspectjrt包是aspectj的runtime包 aspectjweaver是aspectj的织入包 Cglib包是用来动态代理用的,基于类的代理 1.切入点表达式​ 例如：dao包下public void addAccount(int i);和dao包下的public int reAccount(); ​ 手写访问修饰符可以省略不写 12//匹配public void addAccount(int i)可以写成void addAccount(int) 1.返回值类型可以使用通配符* 表示任意返回值2.包名必须用·进行分割 比如 * . * . *形式3.或者使用* .. 匹配多级目录4.方法名称也可以使用通配符 *5.参数列表可以使用float之类的基本数据类型，如果是复杂数据类型需要些包名加类名如果参数列表使用 * 进行通配符匹配只能匹配有参数的方法，要想匹配所有参数列表的需要使用 ..进行匹配2. 4种通知类型1234&lt;aop:before method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:before&gt;&lt;!--前置通知--&gt;&lt;aop:after-returning method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after-returning&gt;&lt;!--后置通知--&gt;&lt;aop:after-throwing method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after-throwing&gt;&lt;!--异常通知--&gt;&lt;aop:after method="通知的方法名" pointcut="execution(包名.类名.方法名)"&gt;&lt;/aop:after&gt;&lt;!--最终通知--&gt; 环绕通知是spring框架为我们提供的一种可以做在代码中手动控制增强方法合适执行的一种方式如果觉得配置execution比较麻烦可以使用切入点表达式解决项目目录通过xml的方式实现AOP开发步骤​ 1.把通知bean交给spring来管理（LogMessage类） ​ 2.使用aop:config标签表明开始配置切面 ​ 3.使用aop:aspet标签表明配置切面 ​ id属性，是给切面提供一个唯一标识 ​ ref属性：是指定通知类bean的id ​ 4.在aop:aspet标签的内部使用对应标签来配置通知的类型 ​ aop:before标识前置通知 ​ method属性，用于指定Logger类中那个方法是前置通知 pom.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;AOPDmo&lt;/groupId&gt; &lt;artifactId&gt;AOPDmo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; LogMessage.java 用于增强service类的前置 123456789101112package log;/** * 打印日志类 * 用来增强其他类 */public class LogMessage &#123; public void logMessage()&#123; System.out.print("执行了争抢方法的内容"); &#125;&#125; Iservice接口 123456789package service;/** * service接口 */public interface Iservice &#123; public void addAccout(); public void deletAccount(int i);&#125; Service类 123456789101112package service;public class Service implements Iservice&#123; public void addAccout() &#123; System.out.print("添加了账户"); &#125; public void deletAccount(int i) &#123; System.out.print("删除了账户信息"); &#125;&#125; springconfig.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="logmessage" class="log.LogMessage"&gt;&lt;/bean&gt; &lt;bean id="service" class="service.Service"&gt;&lt;/bean&gt; &lt;!--开始aop配置--&gt; &lt;aop:config&gt; &lt;!--开始配置切面--&gt; &lt;aop:aspect id="aoplog" ref="logmessage"&gt; &lt;!--进行前置切面配置--&gt; &lt;aop:before method="logMessage" pointcut="execution(public void service.Service.addAccout())"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; main.java 12345678910111213import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import service.Iservice;import service.Service;public class Main &#123; public static void main(String[] args) &#123; ApplicationContext ac=new ClassPathXmlApplicationContext("springconfig.xml"); //注意--必须是service的接口类型， Iservice ser= (Iservice) ac.getBean("service"); ser.addAccout(); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>JAVA</tag>
        <tag>Spring</tag>
        <tag>框架</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++语言位运算基本用法和骚操作]]></title>
    <url>%2F2018%2F08%2F27%2FCC%2B%2B%E8%AF%AD%E8%A8%80%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E5%92%8C%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[C/C++语言位运算基本用法和骚操作前言:​ 前几天打了徐州ACM的网络模拟赛，其中有个题觉得很容易做出来，但是死活都是卡时间和卡内存，于是乎就百度了一下题解（╮(╯▽╰)╭手动狗头），结果学到了一个新的算法，叫做区间数组，然后就学了学，结果学的云里雾里的，其中区间数组核心的一个确定区间的函数 123lowbit(int x)&#123; return x&amp;(-x);&#125; 更是云里雾里。然后就结束今天的新的吧。 位运算基本用法 操作符 作用 解释 &amp; 位AND 如果 x 和 y 都为 1，则得到 1；如果 x 或 y 任何一个为 0，或都为0，则得到 0 | 位OR 如果 x 或 y 为 1，或都为 1，则得到 1；如果 x 和 y 都为 0，则得到 0 ^ 位 XOR 如果 x 或 y 的值不同，则得到 1；如果两个值相同，则得到 0 ~ 位 NOT（I的补码） 如果 x 为 0，则得到 1，如果 x 是 1，则得到 0 运算符 意义 示例 结果 &lt;&lt; 向左移位 x&lt;&lt;y x 的每个位向左移动 y 个位 &gt;&gt; 向右移位 x&gt;&gt;y x 的每个位向右移动 y 个位 骚操作判断一个整形最后一位是否是1(用来判断奇偶数)123if(n&amp;1)&#123; printf("是奇数");&#125; ### 演示​ 将输入的一个n（int类型整数）转换成二进制小数（n&gt;=0） 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;stack&gt;using namespace std;int main(void)&#123; int n; while(true) &#123; cin&gt;&gt;n; stack&lt;int&gt; sta; while(n&gt;0)//输出二进制末尾小数打印出并且进行移位 &#123; if(n&amp;1) sta.push(1); else sta.push(0); n&gt;&gt;=1; &#125; while(!sta.empty()) &#123; cout&lt;&lt;sta.top(); sta.pop(); &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 实现两个数互换12345int num1=10;int num2=10;num1=num1^num2;num2=num1^num2;num1=num1^num2;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>语言</tag>
        <tag>C</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow入门教程]]></title>
    <url>%2F2018%2F05%2F27%2F1.tensorflow%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1.tensorflow基本介绍1.TensorFlow 简介​ TensorFlow是一个基于数据流编程的符号数学系统，被广泛应用于各类机器学习算法的编程实现，其前身是谷歌的神经网络算法库 2.TensorFlow基本术语张量（tensor）：​ 张量就是基于向量和矩阵的推广，通俗点理解就是可以将标量看成零阶张量，向量看成一阶张量，矩阵就是二阶张量。 图（graph）​ 代表着一段内存地址，也可以理解成所有的节点和张量的集合 节点（op）​ 每个运算和张量都是一个节点，每个节点就是一个op 会话(Session)​ 会话的作用就是执行图的计算，众所周知在TensorFlow中会话之前的都是图的定义或者是op的定义，只能表示关系不参与计算，所以需要用会话让图真正的执行起来 2.张量（tensor）的使用以及注意事项1.张量的基本概念​ 张量就是基于向量和矩阵的推广，通俗点理解就是可以将标量看成零阶张量，向量看成一阶张量，矩阵就是二阶张量。 2.张量的数据类型 数据类型 Python类型 描述 DT_FLOAT tf.float32 32位浮点数 DT_DOUBLE tf.float64 64位浮点数（精度和float32精度一致） DT_INT64 tf.int64 64位有符号整数 DT_INT32 tf.int32 32位有符号整数（精度和int32精度一致） DT_INT13 tf.int16 16位有符号整数 DT_INT8 tf.int8 8位有符号整数 DT_STRING tf.string 可变长度的字节数组，每一个张量元素都是一个字节数组。 DT_BOOL tf.bool 布尔型 DT_COMPLEX64 tf.compiex64 由两个32位浮点数组组成的复数：实数和虚数 DT_QINT32 tf.qint32 用于量化Ops的8位有符号整数 DT.QINT8 tf.qint8 用于量化Ops的8位有符号整形 DT_QUINT8 tf.quint8 用于量化Ops的8位无符号整形 3.张量的代码12345678#导入tensorflow包，简写为tfimport tensorflow as tf#定义一个3.0的常量的张量tensor=tf.constant(3.0)#显示tensor的结果print(tensor)#结果将会是：Tensor("Const:0", shape=(), dtype=float32) 其中Const表示进行的op操作名字shape表示张量的维度,()表示标量，（1）表示向量，（2，3）表示2行3列的张量dtype表示张量的数据类型4.生成张量创建一个常数张量tf.constant(value,dtype=None,shape=None,name=”Const”) 创建一个dtype类型的维度为shape的常数张量 固定值初始化tf.zeros([n,m],tf.dtype)获取一个n行m列的零元素tf.dtype类型的张量 tf.ones([n,m],tf.dtype)获取一个n行m列的1元素tf.dtype类型的张量 随机值初始化tf.random_normal([n,m],mean=2.0,stddev=4,seed=12)创建一个n行m列的正态分布（高斯分布）平均值为2.0，方差为4,随机种子为12张量 5.占位符1tf.placeholder(dtype,shape,name) dtype张量的数据类型 shape张量的维度 [2,3]生成一个2行3列的占位符,[None,3]表示生成一个不确定行和3列的占位符 6.张量的维度调整区别如果调整的过程中生成了新的张量，这种调整称作动态调整 静态调整语法: 张量名字.set_shape([n,m]) 调整张量为n行m列 注意 静态张量只能调整之前不确定维度的张量，比如shape=[None,3]的张量 动态调整语法: tf.reshape(tensor,shape,name=None)动态张量会生成新的张量而且可以跨维度修改，也就是二阶张量可以向n阶张量改变，但是改变前和改变后其总个数必须一致，如果不知道具体维度，需要填写成-1 7.改变张量的类型1tf.cast(x,dtype,name="None") 将x张量转换为dtype类型的张量 1tf.cast([[1,2,3],[4,5,6],[7,8,9]],tf.float32) 将列表从整形转换成float32类型 8.张量的切片和扩展 1tf.concat(value,axis,name="concat") 可以将连个张量拼接起来 value 可以是个列表 axis 表示按行合并还是按列合并 0表示按行合并，1表示按列合并 1234567891011121314151617181920212223242526import tensorflow as tf#定义两个列表a=[[1,2,3],[4,5,6]]b=[[7,8,9],[10,11,12]]#合并两个列表hangCat=tf.concat([a,b],axis=0)lieCat=tf.concat([a,b],axis=1)#由于上面只是搭建了个图结果并没有实际运行,接下来进行实际运行。with tf.Session() as sess: print("行合并") print(sess.run(hangCat)) print("列合并") print(sess.run(lieCat)) #运行结果为：行合并[[ 1 2 3] [ 4 5 6] [ 7 8 9] [10 11 12]]列合并[[ 1 2 3 7 8 9] [ 4 5 6 10 11 12]] 3.会话（Session）​ 会话的作用就是执行图的计算，众所周知在TensorFlow中会话之前的都是图的定义或者是op的定义，只能表示关系不参与计算，所以需要用会话让图真正的运行起来 基本写法12with tf.Session() as sess: sess.run(fetches,feed_dict=None,options=None,run_metadata=None) 1.run方法fetches 运行ops和计算tensorfeed_dict 可选项（字典类型），提取使用占位符之后给图提供数据4.变量（Variable）​ 变量是一种特殊的张量，也是一种op,它能够被存储持久化，他们的值就是张量，默认被训练 1.变量的定义1tf.Variable(initial_balue=None,name=None,trainable=True) initial_value 值 可以用正态分布或者固定生成张量的值 注意：使用变量的时候必须先运行全局初始化初始化 tf.global_variables_initializer() 例子： 12345678910import tensorflow as tf#使用正态分布分配变量的值var=tf.Variable(tf.random_normal([2,3],mean=2.0,stddev=1.0))#开启会话并运行初始化with tf.Session() as sess: #运行初始化(运行全局初始化变量前变量var并未被真正赋值) sess.run(tf.global_variables_initializer()) print(sess.run(var)) 4.TensorBoard 的使用和用法1.TensorBoard的简介​ TensorBoard是Tensorflow的可视化工具，它可以通过Tensorflow程序运行过程中输出的日志文件可视化Tensorflow程序的运行状态。TensorBoard和Tensorflow程序跑在不同的进程中，TensorBoard会自动读取最新的TensorFlow日志文件，并呈现当前TensorFlow程序运行的最新状态。 2.TensorBoard代码写入事务文件需要找到TensorFlow包里面的事务包summary里面的FileWriter方法 1tf.summary.FileWriter(logdir,graph=None) logdir事务文件的绝对路径graph写出事务文件的图1234#收集变量tf.summary.scalar(name="",tensor)#收集损失函数和准确率tf.summary.histogram(name="",tensor)#收集高纬度的变量参数tf.summary.image(name="",tensor)#收集输入的图片张量，能显示图片 name 表示TensorBoard里面显示的名称tensor表示要收集的张量123mergin=tf.summary.merge_all()#收集所有的张量summary=sess.run(mergin)#每次迭代都要运行的合并FileWriter.add_summary(summary,i)#每次迭代都要添加到事务文件 3.TensorBoard的演示​ 首先代码 1234567891011121314151617#通过两个变量的相加演示tensorboard的用法import tensorflow as tf#定义两个正态分布的随机变量var1=tf.Variable(tf.random_normal([2,3],mean=2.0,stddev=1.0))var2=tf.Variable(tf.random_normal([2,3],mean=3.0,stddev=2.0))#定义加法opadd=tf.add(var1,var2)init_variable=tf.global_variables_initializer()#开启会话with tf.Session() as sess: #初始化变量 sess.run(init_variable) #导出事务文件 tf.summary.FileWriter("./board",graph=sess.graph) print(sess.run(add)) ​ 然后启动命令行，打出下列命令 1tensorboard --logdir="D:\code\python\tensortflow\board" ​ 之后显示命令行下面显示如下信息 1TensorBoard 1.5.1 at http://By:6006 (Press CTRL+C to quit) 这就表示TensorBoard正常启动了，在浏览器输入（http://By:6006）就能正常访问tensorboard了 5.损失函数1.均方误差​ 计算方法是求预测值与真实值之间距离的平方和 ​ 公式如图所示： 6.梯度下降算法1.基本思想梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。2.代码1tf.tarin.GradientDescentOptimizer(learning_rate) learning_rate 学习率 通常填写0.0到1.0之间的浮点数6.简单的线性回归案例12345678910111213141516171819202122232425262728293031#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢?import tensorflow as tf#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(0.1).minimize(loss)#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): sess.run(train_op) print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) 7.梯度爆炸12345678910111213141516171819202122232425262728293031#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢?import tensorflow as tf#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(1).minimize(loss)#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): sess.run(train_op) print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) 1.简述​ 上述代码学习率是1，运行后就会发现权重和偏置变成了NAV，这就是梯度爆炸，也就是说学习率过大或者神经网络模型的某些原因就会导致梯度爆炸，但是学习率也不能过小，过小会得不到好的效果。 2.解决方法 重新设计神经网络 调整学习率 使用梯度阶段（在训练过程中检查和限制梯度的大小） 使用激活函数 8.模型的保存和加载1.代码1234saver=tf.train.Saver(var_list=None,max_to_keep=5)#在会话里面saver.restpre(sess,"")#读取模型saver.save(sess,"")#保存模型 var_list:自定要保持和还原的变量。他可以作为一个dict或者一个列表传进去max_to_keep:制定要保留的最近检查点文件的最大数量，创建新的文件的时候会删除比较旧的文件，默认值5“” 这个路径包含路径和文件名1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#假设有一个函数关系式y=x*0.7+0.2 也就是y=x*w+b这个关系，若只知道y的结果和x的结果若干组，那么能否正确让w为0.7 b为0.2呢import tensorflow as tfimport os#1.生成100组x的xDist=tf.random_normal([100,1],mean=0.5,stddev=0.5,name="xDist")#生成目标值y的结果y_true=tf.matmul(xDist,[[0.7]])+0.2#2.建立线性回归模型#因为权重和偏置是需要不断训练改变的，所有需要定义成变量w=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=1.0),name="w")b=tf.Variable(tf.random_normal([1,1],mean=0.0,stddev=0.0),name="b")y=tf.matmul(xDist,w)+b#损失函数和使用梯度下降优化器优化，使用最小损失优化，学习率为0.1loss=tf.reduce_mean(tf.square(y_true-y))train_op=tf.train.GradientDescentOptimizer(0.1).minimize(loss)#收集张量tf.summary.scalar("loss",loss)tf.summary.histogram("W",w)#合并所有的收集到的张量margin=tf.summary.merge_all()#4.定义全局变量全局初始化init_var=tf.global_variables_initializer()#定义保存saver=tf.train.Saver()#4.开启会话开始训练with tf.Session() as sess: #运行初始化变量 sess.run(init_var) # 读取模型 if os.path.exists("./model/checkpoint"): saver.restore(sess, "./model/123") #写出事务文件 fileWiter=tf.summary.FileWriter("./board",graph=sess.graph) #打印训练前权重和偏值,因为权重和偏置并没有被运行，所以需要使用eval方法实时获取权重和偏置 print("训练前权重:%f权重:%f" % (w.eval(),b.eval())) for i in range(300): summary = sess.run(margin) sess.run(train_op) fileWiter.add_summary(summary,i) # 运行变量的合并 print("%d轮，权重为:%f,偏置为:%f" % (i,w.eval(),b.eval())) saver.save(sess,"./model/123") 2.保存的文件格式​ .data-00000-of-00001和.index文件 ​ checkpoint文件：checkpoint_dir目录下还有checkpoint文件，该文件是个文本文件，里面记录了保存的最新的checkpoint文件以及其它checkpoint文件列表。在inference时，可以通过修改这个文件，指定使用哪个model。加载restore时的文件路径名是以checkpoint文件中的“model_checkpoint_path”值决定的。 ​ 保存模型时，只会保存变量的值，placeholder里面的值不会被保存。 9.队列机制1.简述​ TensorFlow提供了专门的队列机制,专门用来处理文件读取的问题 2.代码1queue=tf.FIFOQueue(capatity,dtype)#定义一个队列 capatity 队列的容量dtype队列存储的数据类型1queue.dequeue()#出队列并且移除 12queue.enqueue()#入队列int=queue.enqueue_many(list)#入队一个列表元素 演示:1234567891011121314151617181920#定义一个队列，不断出队列和入队列import tensorflow as tf#定义一个队列queue=tf.FIFOQueue()#添加队列元素int=queue.enqueue_many([[1.0,2.0,3.0],])#定义图结构item=queue.dequeue()data=item+1en=queue.enqueue(data)#开始执行图结构with tf.Session() as sess: #运行添加元素结构 sess.run(int) for i in range(20): sess.run(en) for i in range(queue.size().eval()): print(queue.dequeue().eval()) 10.文件读取1.文件读取的过程1.构造文件队列2.构造阅读器3.对于每个样本进行解码4.批处理文件2.文件读取的API介绍构造文件队列1tf.tarin.string_inpput_producer(string_tensor,shuffle=True) string_tensor 含有文件名的一阶张量（包含路径以及文件名的列表）shuffle 是否乱序 默认乱序num_epochs 过几遍数据，默认无限过数据构造文件阅读器 所有阅读器解码出来形状都是不固定的，注意后边进行形状固定 要根据文件类型选择对应的文件阅读区 每个read方法返回key，和value参数，其中key表示文件名称，value表示每个样本 文本文件和CSV文件: 12class reader=tf.TextLineReader()#构造文件阅读器 reader.read(file_queue)#读取一个样本 文本文件阅读器，默认按行读取，（因为对于csv文件和文本文件来说，一行就是一个样本）return 返回阅读器实例read(file_queue)file_queue 从队列里面读取内容二进制文件阅读器12class reader=tf.FixedLengthRecordReader(record_bytes)#构造文件阅读器 reader.read(file_queue)#读取一个样本文件 读取每个样本是按固定数量的字节读取的二进制文件record_bytes:整形，指定每次读取的字节数return 返回阅读器实例图片文件阅读器12class reader=tf.WholeFileReader()#构造图片文件阅读器 reader.read(file_queue)#读取一个图片样本 每个样本进行解码CSV文件解码1tf.decode_csv(value,record_defaults=None) value表示待解码的内容record_defaults 表示每个样本如何解码，并且缺失的时候的默认值 [[1]]表示一个样本按整形解码，缺失的时候为1，[[“None”],[1.0]] 表示样本有两个第一个按string类型解码，缺失的时候是None,第二个按float类型解码，丢失按1.0处理图片文件解码 123456tf.image.decode_jpeg(contents)#将JPEG编码的图像解码为uint8的张亮#return:uint8张量3-D形状[height,width,hannels]tf.image.decode_png(contents)#将PNG图片的图像解码为uint8或者uint16的张量#return:张量类型，3-D形状[height,width,hannels] 图片文件缩放 123tf.image.resize_images(images,size)images:4-D形状[batch,height,width,channels]或者3-D的形状的张量[height,width,channels]size图片的新尺寸，new_height,new_width 管道批处理文件 12#批处理 batch_size表示每批的数量，num_threads进行的线程数量，capacity批处理管道的容量 ones,twos=tf.train.batch([one,two],batch_size=6,num_threads=1,capacity=9) 3.文件读取的简单演示1234567891011121314151617181920212223242526272829303132333435363738394041424344#1.构造文件队列（路径加文件名）#2.构造文件阅读器#3.按每个样本解码（转化为张量 ）#4.构造批处理###在同目录下有个data文件夹，里面的csv文件里面都有两行且都是string类型import tensorflow as tfimport os#找到对应的文件目录获取文件路径加列表def fileRead(path): fileName=os.listdir(path) filePath=[os.path.join(path,file) for file in fileName] return filePathdef csvRead(fileList): #构造文件队列 fileQueue=tf.train.string_input_producer(fileList) #构造阅读器 reader=tf.TextLineReader() key,value=reader.read(fileQueue) #对文件进行解码 #设定每行的类型以及每行的默认值 cord=[["None"],["None"]] one,two=tf.decode_csv(value,record_defaults=cord) #批处理 batch_size表示每批的数量，num_threads进行的线程数量，capacity批处理管道的容量 ones,twos=tf.train.batch([one,two],batch_size=6,num_threads=1,capacity=9) return ones,twosif __name__ == "__main__": fileList=fileRead("./data") one,two=csvRead(fileList) with tf.Session() as sess: #定义一个线程协调器 coord=tf.train.Coordinator() #开启一个线程 thread=tf.train.start_queue_runners(sess,coord=coord) print(sess.run([one,two])) #回收子线程 coord.request_stop() coord.join(thread) 图片文件的读取简单演示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#读取当前文件夹下面的data目录下面所有的jpg格式图片的信息#步骤# 1.获取path文件下面的所有图片的全路径列表# 2.构造文件队列# 3.构造图片阅读器# 4.图片解码# 5.图片缩放# 6.图片调整维度# 7.批处理import tensorflow as tfimport os#读取path目录下所有的图片信息def getPath(path): fileNames=os.listdir(path) filePath=[os.path.join(path,fileName) for fileName in fileNames] return filePath#读取图片并进行批处理def readImg(filePathList): #1.构造文件队列 fileQueue=tf.train.string_input_producer(filePathList) #1.构造图片阅读器 reader=tf.WholeFileReader() key,value=reader.read(fileQueue) print("构造完阅读器",value) #3.图片解码 image=tf.image.decode_jpeg(value) print("解码",image) #4.图片缩放 reImage=tf.image.resize_images(image,[200,200]) print("图片放缩后",reImage) #5.图片定型 静态调整 reImage.set_shape([200,200,3]) print("图片静态调整后",reImage) #文件批处理 jpg=tf.train.batch([reImage],batch_size=5,num_threads=2,capacity=5) return reImageif __name__ == "__main__": filePathList=getPath("./data") jpg=readImg(filePathList) #开启会话 with tf.Session() as sess: #定义一个线程协调器 coord=tf.train.Coordinator() #定义一个线程 thread=tf.train.start_queue_runners(sess,coord=coord) print(sess.run(jpg)) #回收子线程 coord.request_stop() coord.join(thread) 注意打印结果: 构造完阅读器 Tensor(“ReaderReadV2:1”, shape=(), dtype=string)解码 Tensor(“DecodeJpeg:0”, shape=(?, ?, ?), dtype=uint8)图片放缩后 Tensor(“Squeeze:0”, shape=(200, 200, ?), dtype=float32)图片静态调整后 Tensor(“Squeeze:0”, shape=(200, 200, 3), dtype=float32) 11.交叉熵损失计算和softMax计算1.softMax计算​ 假设我们有一个数组，V，Vi表示V中的第i个元素，那么这个元素的Softmax值就是 ​ 可以计算n个结果之间发生的概率 2.交叉熵损失​ 可以和onehost编码与softMax计算损失 123456#SoftMax和交叉熵损失计算tf.nn.softmax_cross_entropy_with_logits(babels=None,logits=None,name)#计算logits和labels之间的交叉熵损失#labels:真实值#logits:预测值#return:返回所有样本的损失值列表 3.演示12345678910111213141516def argmax(input, axis=None, name=None, dimension=None, output_type=dtypes.int64)numpy.argmax(a, axis=None, out=None) 返回沿轴axis最大值的索引。Parameters: input: array_like，数组axis : int, 可选，默认情况下，索引的是平铺的数组，否则沿指定的轴。 out : array, 可选 如果提供，结果以合适的形状和类型被插入到此数组中。 Returns: index_array : ndarray of ints 索引数组。它具有与a.shape相同的形状，其中axis被移除。 12345678910111213141516171819202122232425262728293031323334353637383940#简单的神经网络识别手写数字#1.定义占位符#2.搭建神经网络#3.计算损失#4.反向传播优化损失#5.计算准确率#6.开启会话训练import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets("./MNIST_data", one_hot=True)def imgNn(): #1.定义占位符 xDist=tf.placeholder(tf.float32,[None,784]) yTrue=tf.placeholder(tf.float32,[None,10]) #2.初始化变量搭建神经网络 w=tf.Variable(tf.random_normal([784,10],mean=0.0,stddev=1.0)) b=tf.Variable(tf.random_normal([10],mean=0.0,stddev=1.0)) y=tf.matmul(xDist,w)+b #3.计算平均交叉熵损失率 loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=yTrue,logits=y)) #4.反向传播最小优化学习率0.1 trainOp=tf.train.GradientDescentOptimizer(0.1).minimize(loss) #5.计算准确率 arg_max会反正正确结果的下标 1表示按同行比较 0表示同列 equal_list=tf.equal(tf.arg_max(yTrue,1),tf.arg_max(y,1)) acuracy=tf.reduce_mean(tf.cast(equal_list,tf.float32)) initOp=tf.global_variables_initializer() #6.开启会话开始训练 with tf.Session() as sess: sess.run(initOp) for i in range(3000): #取出特征值和目标值 minstX,minstY=mnist.train.next_batch(50) sess.run(trainOp,feed_dict=&#123;xDist:minstX,yTrue:minstY&#125;) print("%d步准确率%f" % (i,sess.run(acuracy,feed_dict=&#123;xDist:minstX,yTrue:minstY&#125;)))if __name__ =="__main__": imgNn() 12.卷积神经网络1.概述​ 卷积神经网络（Convolutional Neural Networks / CNNs / ConvNets）与普通神经网络非常相似，它们都由具有可学习的权重和偏置常量(biases)的神经元组成。每个神经元都接收一些输入，并做一些点积计算，输出是每个分类的分数，普通神经网络里的一些计算技巧到这里依旧适用。 具有三维体积的神经元(3D volumes of neurons) ​ 卷积神经网络利用输入是图片的特点，把神经元设计成三个维度 ： width, height, depth(注意这个depth不是神经网络的深度，而是用来描述神经元的) 。比如输入的图片大小是 32 × 32 × 3 (rgb)，那么输入神经元就也具有 32×32×3 的维度。 2.卷积神经网络分层卷积层—&gt;激活层—&gt;池化层—&gt;全连接层##### 卷积层：​ 卷积神经网路中每层卷积层由若干卷积单元组成，每个卷积单元的参数都是通过反向传播算法优化得到的。卷积运算的目的是提取输入的不同特征，第一层卷积层可能只能提取一些低级的特征如边缘、线条和角等层级，更多层的网络能从低级特征中迭代提取更复杂的特征。 激活层：​ 通过Relu激活函数可以增加网络的非线性分割能力 池化层：​ 用来减少数据量 3.填充算法SAME：​ 当filter过滤到边缘的时候自动填充0 - 越过边缘取样，取样的面积和输入的图像像素长度和宽度相同VALID： 当filter过滤到边缘的时候跳过，所有会丢失部分特征，取样的面积和输入的图像像素长度和宽度会略小 计算公式为：输入体积大小h1 * w1 * d1 ，filter数量为k,filter大小为f,步长为s,填充大小为p 那么 h2=(h1-f+2p)/s+1 w2=(w1-f+2p)/s+1 d2=k 4.API介绍12#卷积层tf.nn.conv2d(input,filter,strides=,padding=,name=None) input: 输入的4-D张量，具有[batch,height,width,channel],类型为float32，或者float64([每批数,图片长度，图片宽度，图片通道数])filter:指定过滤器4-D随机初始化的张量：,类型为float32或者float64([过滤器长度，过滤器宽度，输入的通道数，输出的通道数])，——- 注意需要传入4-D张量，而不是简单的填入维度strides:strides=[1,stride,stride,1],步长（[1，长上步长，宽上步长，1]）padding=:”SAME”，“VALID”，使用的填充算法类型.12#relu激活函数tf.nn.relu(feacutes,name=None) features:卷积后加上偏置的结果return :结果12#池化tf.nn.max_pool(value,ksize=,strides=,padding=,name=None) value:4-D tensor形状[batch,height,width,channels]，也就是激活函数处理后的结果ksize池化窗口大小，[1,ksize,ksize,1]步长大小,[1,strides,strides,1]padding :”SAME”,”VALID”填充算法5.演示两层卷积神经网络识别手写数字​ 1.输入数据形状[None,784] ##### 第一层卷积神经网络卷积层​ 2.因为卷积API的input即输入为4-D张量，所以动态改变形状改为[None,28,28,1],使用32个filter的5*5大小，步长为1，SAME填充算法的过滤器且卷积后输出的形状为[None,28,28,32]，有多少个filter就有多少个偏置所以为32，权重就是每个filter的值. ###### 激活层​ 3.不改变数据大小，所以输出还是[None,28,28,32] ###### 池化​ 4.大小为2 *2，步长为2，填充算法为“SAME”(这里SAME后的大小比原来小)将[None,28,28,32]的图像池化为[None,14,14,32] 第一层卷积神经网络卷积层​ 2.因为卷积API的input即输入为4-D张量，输入为[None,14,14,32],使用64个filter的5*5大小，步长为1，SAME填充算法的过滤器且卷积后输出的形状为[None,14,14,64]，有多少个filter就有多少个偏置所以为64,权重就是每个filter的值. 激活层​ 3.不改变数据大小，所以输出还是[None,14,14,64] 池化​ 4.大小为2*2，步长为2，填充算法为“SAME”(这里SAME后的大小比原来小)将[None,14,14,64]的图像池化为[None,7,7,64] 全连接层​ 因为池化后数据为[None,7,7,64],而且矩阵乘法只能处理二维数据，所以动态调整形状为[None,7 * 7 *64],又因为输出是10种结果，所以全连接层为[7 * 7 *64,10],所以权重[7 * 7 *64,10]偏置有10个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475##### 两层卷积神经网络识别手写数字import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_datadef getVarRandom_normal(shape): return tf.Variable(tf.random_normal(shape=shape,mean=0.0,stddev=1.0))#搭建神经网络def conV(): #1.定义占位符 xDist=tf.placeholder(tf.float32,[None,784]) yTrue=tf.placeholder(tf.float32,[None,10]) #2.搭建第一层卷积网络 filter 有32个 大小为5*5，步长为1， with tf.name_scope("con1"): xshape=tf.reshape(xDist,[-1,28,28,1]) filterW=getVarRandom_normal([5,5,1,32]) b=getVarRandom_normal([32]) #卷积层 con1=tf.nn.conv2d(xshape,filterW,strides=[1,1,1,1],padding="SAME")+b #激活层 relu=tf.nn.relu(con1) #池化层 大小为2*2 步长为2 [None,28,28,32]----&gt;[None,14,14,32] pool=tf.nn.max_pool(relu,ksize=[1,2,2,1],strides=[1,2,2,1],padding="SAME") #3.搭建第二层卷积网络 filter有64个，大小为5*5，步长为1 with tf.name_scope("con2"): filterW2=getVarRandom_normal([5,5,32,64]) b1=getVarRandom_normal([64]) #卷积层 con2=tf.nn.conv2d(pool,filterW2,strides=[1,1,1,1],padding="SAME")+b1 #激活层 relu2=tf.nn.relu(con2) #池化层 pool2=tf.nn.max_pool(relu2,ksize=[1,2,2,1],strides=[1,2,2,1],padding="SAME") #全连接层 w3=getVarRandom_normal([7*7*64,10]) b3=getVarRandom_normal([10]) shape = tf.reshape(pool2, [-1, 7*7*64]) grop=tf.matmul(shape,w3)+b3 return xDist,yTrue,gropif __name__ == "__main__": xDist,yTrue,opInt=conV() mnist = input_data.read_data_sets("./MNIST_data", one_hot=True) #计算平均交叉熵损失 loss=tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=yTrue,logits=opInt)) #反向传播 trainOp=tf.train.GradientDescentOptimizer(0.00001).minimize(loss) #计算准确率 equal_list = tf.equal(tf.argmax(yTrue, 1), tf.argmax(opInt, 1)) acuracy = tf.reduce_mean(tf.cast(equal_list, tf.float32)) initOp = tf.global_variables_initializer() # 6.开启会话开始训练 with tf.Session() as sess: sess.run(initOp) for i in range(3000000): # 取出特征值和目标值 minstX, minstY = mnist.train.next_batch(50) sess.run(trainOp, feed_dict=&#123;xDist: minstX, yTrue: minstY&#125;) print("%d步准确率%f" % (i, sess.run(acuracy, feed_dict=&#123;xDist: minstX, yTrue: minstY&#125;)))]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语言</tag>
        <tag>编程</tag>
        <tag>日常学习</tag>
        <tag>TensorFlow</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用入门]]></title>
    <url>%2F2018%2F05%2F27%2FGit%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Git使用入门前言​ 之前在网上接私活的时候使用了一下github,当时一下都惊艳到我了，（见识短╮(╯▽╰)╭），当时因为用的c#语言开发，使用的vs2017，他继承的那个git是中文的，特别好用，但是也导致了我啥也没学会，正好今天有空，就填补一下这个大坑吧 简介​ 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。（百度粘贴过来的，╮(╯▽╰)╭） 概念介绍​ git可以将工作区（Working Directory）的代码放到暂存区，最后统一把暂存区的代码合并到我们的git仓库中（这个仓库其实还是本地的仓库）。（╮(╯▽╰)╭我觉得解释的很不清楚） 12345st=&gt;start: git仓库e=&gt;end: 工作空间item=&gt;subroutine: 暂存区e-&gt;item-&gt;st 使用git工具要先进行初始化1234git config --global user.name "yang295513"//这个name一定要填写github上面的名称git config --global user.email "15993343299@163.com"//对应的邮箱//这个不是必须的但是新建git仓库就要进去进行这个命令，然后git工具会生成一个隐藏文件.gitgit init 就这样，之后就可以愉快的玩耍了 指令介绍 指令名 作用 注释 git status 显示当前文件的状态 用来确定文件在三个区的位置 git add 文件名.文件类型 将文件添加到暂存区 把工作空间的文件添加到暂存区 git commit -m “提交描述” 把暂存区所有的文件提交到仓库 提交描述用来标识文件的改动，也就是说本次提交的注释 git push 将本地代码提交到git远程 仓库中 将本地代码提交到git远程仓库中 git clone 仓库地址 将远程git的代码下载下来 案例演示首先这里新建了一个演示项目 然后我们通过git clone命令把这个项目下载下来，其中项目的链接在这里： 然后我们使用git工具克隆下来 这是本地生成的文件 其中那个.git的隐藏文件就隐藏着配置信息 githubTest就是咱们的测试信息 githubTest文件里面的信息可以看到和我们的远端github仓库中的一模一样 接下来我们在本地创建一个Test.java的类，来模拟我们的项目 然后使用git add命令和git commit -m和git push命令依次提交到git远端仓库中 然后去github来查看是否已经被提交了 完美,收场，学习新东西去不不不，还有一些使用细节得介绍一下 你提交了那些文件那些文件才会被替换，也就是说你同时修改了A和B文件，那三连 都是针对B文件的，那么你提交到远端git仓库在只会修改你提交的B文件，没有B文件进行创建,有B文件更新 如果提交到远端失败的话，要注意是否是name和Email书写错误，或者说该仓库是priavte（私有的）如果是私有的去对应配置文件下修改账号密码即可]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>日常学习</tag>
      </tags>
  </entry>
</search>
